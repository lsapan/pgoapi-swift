// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "POGOProtos.Data.Battle.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public func == (lhs: Pogoprotos.Data.Battle.BattleAction, rhs: Pogoprotos.Data.Battle.BattleAction) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasActionStartMs == rhs.hasActionStartMs) && (!lhs.hasActionStartMs || lhs.actionStartMs == rhs.actionStartMs)
  fieldCheck = fieldCheck && (lhs.hasDurationMs == rhs.hasDurationMs) && (!lhs.hasDurationMs || lhs.durationMs == rhs.durationMs)
  fieldCheck = fieldCheck && (lhs.hasEnergyDelta == rhs.hasEnergyDelta) && (!lhs.hasEnergyDelta || lhs.energyDelta == rhs.energyDelta)
  fieldCheck = fieldCheck && (lhs.hasAttackerIndex == rhs.hasAttackerIndex) && (!lhs.hasAttackerIndex || lhs.attackerIndex == rhs.attackerIndex)
  fieldCheck = fieldCheck && (lhs.hasTargetIndex == rhs.hasTargetIndex) && (!lhs.hasTargetIndex || lhs.targetIndex == rhs.targetIndex)
  fieldCheck = fieldCheck && (lhs.hasActivePokemonId == rhs.hasActivePokemonId) && (!lhs.hasActivePokemonId || lhs.activePokemonId == rhs.activePokemonId)
  fieldCheck = fieldCheck && (lhs.hasPlayerJoined == rhs.hasPlayerJoined) && (!lhs.hasPlayerJoined || lhs.playerJoined == rhs.playerJoined)
  fieldCheck = fieldCheck && (lhs.hasBattleResults == rhs.hasBattleResults) && (!lhs.hasBattleResults || lhs.battleResults == rhs.battleResults)
  fieldCheck = fieldCheck && (lhs.hasDamageWindowsStartTimestampMss == rhs.hasDamageWindowsStartTimestampMss) && (!lhs.hasDamageWindowsStartTimestampMss || lhs.damageWindowsStartTimestampMss == rhs.damageWindowsStartTimestampMss)
  fieldCheck = fieldCheck && (lhs.hasDamageWindowsEndTimestampMss == rhs.hasDamageWindowsEndTimestampMss) && (!lhs.hasDamageWindowsEndTimestampMss || lhs.damageWindowsEndTimestampMss == rhs.damageWindowsEndTimestampMss)
  fieldCheck = fieldCheck && (lhs.hasPlayerLeft == rhs.hasPlayerLeft) && (!lhs.hasPlayerLeft || lhs.playerLeft == rhs.playerLeft)
  fieldCheck = fieldCheck && (lhs.hasTargetPokemonId == rhs.hasTargetPokemonId) && (!lhs.hasTargetPokemonId || lhs.targetPokemonId == rhs.targetPokemonId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Data.Battle.BattleLog, rhs: Pogoprotos.Data.Battle.BattleLog) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasState == rhs.hasState) && (!lhs.hasState || lhs.state == rhs.state)
  fieldCheck = fieldCheck && (lhs.hasBattleType == rhs.hasBattleType) && (!lhs.hasBattleType || lhs.battleType == rhs.battleType)
  fieldCheck = fieldCheck && (lhs.hasServerMs == rhs.hasServerMs) && (!lhs.hasServerMs || lhs.serverMs == rhs.serverMs)
  fieldCheck = fieldCheck && (lhs.battleActions == rhs.battleActions)
  fieldCheck = fieldCheck && (lhs.hasBattleStartTimestampMs == rhs.hasBattleStartTimestampMs) && (!lhs.hasBattleStartTimestampMs || lhs.battleStartTimestampMs == rhs.battleStartTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasBattleEndTimestampMs == rhs.hasBattleEndTimestampMs) && (!lhs.hasBattleEndTimestampMs || lhs.battleEndTimestampMs == rhs.battleEndTimestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Data.Battle.BattleParticipant, rhs: Pogoprotos.Data.Battle.BattleParticipant) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasActivePokemon == rhs.hasActivePokemon) && (!lhs.hasActivePokemon || lhs.activePokemon == rhs.activePokemon)
  fieldCheck = fieldCheck && (lhs.hasTrainerPublicProfile == rhs.hasTrainerPublicProfile) && (!lhs.hasTrainerPublicProfile || lhs.trainerPublicProfile == rhs.trainerPublicProfile)
  fieldCheck = fieldCheck && (lhs.reversePokemon == rhs.reversePokemon)
  fieldCheck = fieldCheck && (lhs.defeatedPokemon == rhs.defeatedPokemon)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Data.Battle.BattlePokemonInfo, rhs: Pogoprotos.Data.Battle.BattlePokemonInfo) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasCurrentHealth == rhs.hasCurrentHealth) && (!lhs.hasCurrentHealth || lhs.currentHealth == rhs.currentHealth)
  fieldCheck = fieldCheck && (lhs.hasCurrentEnergy == rhs.hasCurrentEnergy) && (!lhs.hasCurrentEnergy || lhs.currentEnergy == rhs.currentEnergy)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Data.Battle.BattleResults, rhs: Pogoprotos.Data.Battle.BattleResults) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGymState == rhs.hasGymState) && (!lhs.hasGymState || lhs.gymState == rhs.gymState)
  fieldCheck = fieldCheck && (lhs.attackers == rhs.attackers)
  fieldCheck = fieldCheck && (lhs.playerExperienceAwarded == rhs.playerExperienceAwarded)
  fieldCheck = fieldCheck && (lhs.hasNextDefenderPokemonId == rhs.hasNextDefenderPokemonId) && (!lhs.hasNextDefenderPokemonId || lhs.nextDefenderPokemonId == rhs.nextDefenderPokemonId)
  fieldCheck = fieldCheck && (lhs.hasGymPointsDelta == rhs.hasGymPointsDelta) && (!lhs.hasGymPointsDelta || lhs.gymPointsDelta == rhs.gymPointsDelta)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Pogoprotos.Data.Battle {
  public struct PogoprotosDataBattleRoot {
    public static var sharedInstance : PogoprotosDataBattleRoot {
     struct Static {
         static let instance : PogoprotosDataBattleRoot = PogoprotosDataBattleRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Player.PogoprotosDataPlayerRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.PogoprotosDataRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Gym.PogoprotosDataGymRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum BattleActionType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case ActionUnset = 0
    case ActionAttack = 1
    case ActionDodge = 2
    case ActionSpecialAttack = 3
    case ActionSwapPokemon = 4
    case ActionFaint = 5
    case ActionPlayerJoin = 6
    case ActionPlayerQuit = 7
    case ActionVictory = 8
    case ActionDefeat = 9
    case ActionTimedOut = 10
    public func toString() -> String {
      switch self {
      case .ActionUnset: return "ACTION_UNSET"
      case .ActionAttack: return "ACTION_ATTACK"
      case .ActionDodge: return "ACTION_DODGE"
      case .ActionSpecialAttack: return "ACTION_SPECIAL_ATTACK"
      case .ActionSwapPokemon: return "ACTION_SWAP_POKEMON"
      case .ActionFaint: return "ACTION_FAINT"
      case .ActionPlayerJoin: return "ACTION_PLAYER_JOIN"
      case .ActionPlayerQuit: return "ACTION_PLAYER_QUIT"
      case .ActionVictory: return "ACTION_VICTORY"
      case .ActionDefeat: return "ACTION_DEFEAT"
      case .ActionTimedOut: return "ACTION_TIMED_OUT"
      }
    }
    public static func fromString(str:String) throws -> Pogoprotos.Data.Battle.BattleActionType {
      switch str {
      case "ACTION_UNSET":  return .ActionUnset
      case "ACTION_ATTACK":  return .ActionAttack
      case "ACTION_DODGE":  return .ActionDodge
      case "ACTION_SPECIAL_ATTACK":  return .ActionSpecialAttack
      case "ACTION_SWAP_POKEMON":  return .ActionSwapPokemon
      case "ACTION_FAINT":  return .ActionFaint
      case "ACTION_PLAYER_JOIN":  return .ActionPlayerJoin
      case "ACTION_PLAYER_QUIT":  return .ActionPlayerQuit
      case "ACTION_VICTORY":  return .ActionVictory
      case "ACTION_DEFEAT":  return .ActionDefeat
      case "ACTION_TIMED_OUT":  return .ActionTimedOut
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
            case .ActionUnset: return ".ActionUnset"
            case .ActionAttack: return ".ActionAttack"
            case .ActionDodge: return ".ActionDodge"
            case .ActionSpecialAttack: return ".ActionSpecialAttack"
            case .ActionSwapPokemon: return ".ActionSwapPokemon"
            case .ActionFaint: return ".ActionFaint"
            case .ActionPlayerJoin: return ".ActionPlayerJoin"
            case .ActionPlayerQuit: return ".ActionPlayerQuit"
            case .ActionVictory: return ".ActionVictory"
            case .ActionDefeat: return ".ActionDefeat"
            case .ActionTimedOut: return ".ActionTimedOut"
        }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum BattleState:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case StateUnset = 0
    case Active = 1
    case Victory = 2
    case Defeated = 3
    case TimedOut = 4
    public func toString() -> String {
      switch self {
      case .StateUnset: return "STATE_UNSET"
      case .Active: return "ACTIVE"
      case .Victory: return "VICTORY"
      case .Defeated: return "DEFEATED"
      case .TimedOut: return "TIMED_OUT"
      }
    }
    public static func fromString(str:String) throws -> Pogoprotos.Data.Battle.BattleState {
      switch str {
      case "STATE_UNSET":  return .StateUnset
      case "ACTIVE":  return .Active
      case "VICTORY":  return .Victory
      case "DEFEATED":  return .Defeated
      case "TIMED_OUT":  return .TimedOut
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
            case .StateUnset: return ".StateUnset"
            case .Active: return ".Active"
            case .Victory: return ".Victory"
            case .Defeated: return ".Defeated"
            case .TimedOut: return ".TimedOut"
        }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum BattleType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case BattleTypeUnset = 0
    case Normal = 1
    case Training = 2
    public func toString() -> String {
      switch self {
      case .BattleTypeUnset: return "BATTLE_TYPE_UNSET"
      case .Normal: return "NORMAL"
      case .Training: return "TRAINING"
      }
    }
    public static func fromString(str:String) throws -> Pogoprotos.Data.Battle.BattleType {
      switch str {
      case "BATTLE_TYPE_UNSET":  return .BattleTypeUnset
      case "NORMAL":  return .Normal
      case "TRAINING":  return .Training
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
            case .BattleTypeUnset: return ".BattleTypeUnset"
            case .Normal: return ".Normal"
            case .Training: return ".Training"
        }
    }
  }

  //Enum type declaration end 

  final public class BattleAction : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var types:Pogoprotos.Data.Battle.BattleActionType = Pogoprotos.Data.Battle.BattleActionType.ActionUnset
    public private(set) var hasTypes:Bool = false
    public private(set) var hasActionStartMs:Bool = false
    public private(set) var actionStartMs:Int64 = Int64(0)

    public private(set) var hasDurationMs:Bool = false
    public private(set) var durationMs:Int32 = Int32(0)

    public private(set) var hasEnergyDelta:Bool = false
    public private(set) var energyDelta:Int32 = Int32(0)

    public private(set) var hasAttackerIndex:Bool = false
    public private(set) var attackerIndex:Int32 = Int32(0)

    public private(set) var hasTargetIndex:Bool = false
    public private(set) var targetIndex:Int32 = Int32(0)

    public private(set) var hasActivePokemonId:Bool = false
    public private(set) var activePokemonId:UInt64 = UInt64(0)

    public private(set) var hasPlayerJoined:Bool = false
    public private(set) var playerJoined:Pogoprotos.Data.Battle.BattleParticipant!
    public private(set) var hasBattleResults:Bool = false
    public private(set) var battleResults:Pogoprotos.Data.Battle.BattleResults!
    public private(set) var hasDamageWindowsStartTimestampMss:Bool = false
    public private(set) var damageWindowsStartTimestampMss:Int64 = Int64(0)

    public private(set) var hasDamageWindowsEndTimestampMss:Bool = false
    public private(set) var damageWindowsEndTimestampMss:Int64 = Int64(0)

    public private(set) var hasPlayerLeft:Bool = false
    public private(set) var playerLeft:Pogoprotos.Data.Battle.BattleParticipant!
    public private(set) var hasTargetPokemonId:Bool = false
    public private(set) var targetPokemonId:UInt64 = UInt64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasTypes {
        try output.writeEnum(1, value:types.rawValue)
      }
      if hasActionStartMs {
        try output.writeInt64(2, value:actionStartMs)
      }
      if hasDurationMs {
        try output.writeInt32(3, value:durationMs)
      }
      if hasEnergyDelta {
        try output.writeInt32(5, value:energyDelta)
      }
      if hasAttackerIndex {
        try output.writeInt32(6, value:attackerIndex)
      }
      if hasTargetIndex {
        try output.writeInt32(7, value:targetIndex)
      }
      if hasActivePokemonId {
        try output.writeFixed64(8, value:activePokemonId)
      }
      if hasPlayerJoined {
        try output.writeMessage(9, value:playerJoined)
      }
      if hasBattleResults {
        try output.writeMessage(10, value:battleResults)
      }
      if hasDamageWindowsStartTimestampMss {
        try output.writeInt64(11, value:damageWindowsStartTimestampMss)
      }
      if hasDamageWindowsEndTimestampMss {
        try output.writeInt64(12, value:damageWindowsEndTimestampMss)
      }
      if hasPlayerLeft {
        try output.writeMessage(13, value:playerLeft)
      }
      if hasTargetPokemonId {
        try output.writeFixed64(14, value:targetPokemonId)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasTypes) {
        serialize_size += types.rawValue.computeEnumSize(1)
      }
      if hasActionStartMs {
        serialize_size += actionStartMs.computeInt64Size(2)
      }
      if hasDurationMs {
        serialize_size += durationMs.computeInt32Size(3)
      }
      if hasEnergyDelta {
        serialize_size += energyDelta.computeInt32Size(5)
      }
      if hasAttackerIndex {
        serialize_size += attackerIndex.computeInt32Size(6)
      }
      if hasTargetIndex {
        serialize_size += targetIndex.computeInt32Size(7)
      }
      if hasActivePokemonId {
        serialize_size += activePokemonId.computeFixed64Size(8)
      }
      if hasPlayerJoined {
          if let varSizeplayerJoined = playerJoined?.computeMessageSize(9) {
              serialize_size += varSizeplayerJoined
          }
      }
      if hasBattleResults {
          if let varSizebattleResults = battleResults?.computeMessageSize(10) {
              serialize_size += varSizebattleResults
          }
      }
      if hasDamageWindowsStartTimestampMss {
        serialize_size += damageWindowsStartTimestampMss.computeInt64Size(11)
      }
      if hasDamageWindowsEndTimestampMss {
        serialize_size += damageWindowsEndTimestampMss.computeInt64Size(12)
      }
      if hasPlayerLeft {
          if let varSizeplayerLeft = playerLeft?.computeMessageSize(13) {
              serialize_size += varSizeplayerLeft
          }
      }
      if hasTargetPokemonId {
        serialize_size += targetPokemonId.computeFixed64Size(14)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Data.Battle.BattleAction> {
      var mergedArray = Array<Pogoprotos.Data.Battle.BattleAction>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleAction? {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Data.Battle.BattleAction.Builder {
      return Pogoprotos.Data.Battle.BattleAction.classBuilder() as! Pogoprotos.Data.Battle.BattleAction.Builder
    }
    public func getBuilder() -> Pogoprotos.Data.Battle.BattleAction.Builder {
      return classBuilder() as! Pogoprotos.Data.Battle.BattleAction.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleAction.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleAction.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
      return try Pogoprotos.Data.Battle.BattleAction.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Data.Battle.BattleAction) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
      return try Pogoprotos.Data.Battle.BattleAction.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasTypes {
        jsonMap["type"] = types.toString()
      }
      if hasActionStartMs {
        jsonMap["actionStartMs"] = "\(actionStartMs)"
      }
      if hasDurationMs {
        jsonMap["durationMs"] = NSNumber(int:durationMs)
      }
      if hasEnergyDelta {
        jsonMap["energyDelta"] = NSNumber(int:energyDelta)
      }
      if hasAttackerIndex {
        jsonMap["attackerIndex"] = NSNumber(int:attackerIndex)
      }
      if hasTargetIndex {
        jsonMap["targetIndex"] = NSNumber(int:targetIndex)
      }
      if hasActivePokemonId {
        jsonMap["activePokemonId"] = "\(activePokemonId)"
      }
      if hasPlayerJoined {
        jsonMap["playerJoined"] = try playerJoined.encode()
      }
      if hasBattleResults {
        jsonMap["battleResults"] = try battleResults.encode()
      }
      if hasDamageWindowsStartTimestampMss {
        jsonMap["damageWindowsStartTimestampMss"] = "\(damageWindowsStartTimestampMss)"
      }
      if hasDamageWindowsEndTimestampMss {
        jsonMap["damageWindowsEndTimestampMss"] = "\(damageWindowsEndTimestampMss)"
      }
      if hasPlayerLeft {
        jsonMap["playerLeft"] = try playerLeft.encode()
      }
      if hasTargetPokemonId {
        jsonMap["targetPokemonId"] = "\(targetPokemonId)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Data.Battle.BattleAction {
      return try Pogoprotos.Data.Battle.BattleAction.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasTypes) {
        output += "\(indent) types: \(types.description)\n"
      }
      if hasActionStartMs {
        output += "\(indent) actionStartMs: \(actionStartMs) \n"
      }
      if hasDurationMs {
        output += "\(indent) durationMs: \(durationMs) \n"
      }
      if hasEnergyDelta {
        output += "\(indent) energyDelta: \(energyDelta) \n"
      }
      if hasAttackerIndex {
        output += "\(indent) attackerIndex: \(attackerIndex) \n"
      }
      if hasTargetIndex {
        output += "\(indent) targetIndex: \(targetIndex) \n"
      }
      if hasActivePokemonId {
        output += "\(indent) activePokemonId: \(activePokemonId) \n"
      }
      if hasPlayerJoined {
        output += "\(indent) playerJoined {\n"
        if let outDescPlayerJoined = playerJoined {
          output += try outDescPlayerJoined.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasBattleResults {
        output += "\(indent) battleResults {\n"
        if let outDescBattleResults = battleResults {
          output += try outDescBattleResults.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasDamageWindowsStartTimestampMss {
        output += "\(indent) damageWindowsStartTimestampMss: \(damageWindowsStartTimestampMss) \n"
      }
      if hasDamageWindowsEndTimestampMss {
        output += "\(indent) damageWindowsEndTimestampMss: \(damageWindowsEndTimestampMss) \n"
      }
      if hasPlayerLeft {
        output += "\(indent) playerLeft {\n"
        if let outDescPlayerLeft = playerLeft {
          output += try outDescPlayerLeft.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasTargetPokemonId {
        output += "\(indent) targetPokemonId: \(targetPokemonId) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasTypes {
               hashCode = (hashCode &* 31) &+ Int(types.rawValue)
            }
            if hasActionStartMs {
               hashCode = (hashCode &* 31) &+ actionStartMs.hashValue
            }
            if hasDurationMs {
               hashCode = (hashCode &* 31) &+ durationMs.hashValue
            }
            if hasEnergyDelta {
               hashCode = (hashCode &* 31) &+ energyDelta.hashValue
            }
            if hasAttackerIndex {
               hashCode = (hashCode &* 31) &+ attackerIndex.hashValue
            }
            if hasTargetIndex {
               hashCode = (hashCode &* 31) &+ targetIndex.hashValue
            }
            if hasActivePokemonId {
               hashCode = (hashCode &* 31) &+ activePokemonId.hashValue
            }
            if hasPlayerJoined {
                if let hashValueplayerJoined = playerJoined?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerJoined
                }
            }
            if hasBattleResults {
                if let hashValuebattleResults = battleResults?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebattleResults
                }
            }
            if hasDamageWindowsStartTimestampMss {
               hashCode = (hashCode &* 31) &+ damageWindowsStartTimestampMss.hashValue
            }
            if hasDamageWindowsEndTimestampMss {
               hashCode = (hashCode &* 31) &+ damageWindowsEndTimestampMss.hashValue
            }
            if hasPlayerLeft {
                if let hashValueplayerLeft = playerLeft?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerLeft
                }
            }
            if hasTargetPokemonId {
               hashCode = (hashCode &* 31) &+ targetPokemonId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Data.Battle.BattleAction"
    }
    override public func className() -> String {
        return "Pogoprotos.Data.Battle.BattleAction"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Data.Battle.BattleAction.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Data.Battle.BattleAction = Pogoprotos.Data.Battle.BattleAction()
      public func getMessage() -> Pogoprotos.Data.Battle.BattleAction {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasTypes:Bool{
            get {
                return builderResult.hasTypes
            }
        }
        public var types:Pogoprotos.Data.Battle.BattleActionType {
            get {
                return builderResult.types
            }
            set (value) {
                builderResult.hasTypes = true
                builderResult.types = value
            }
        }
        public func setTypes(value:Pogoprotos.Data.Battle.BattleActionType) -> Pogoprotos.Data.Battle.BattleAction.Builder {
          self.types = value
          return self
        }
        public func clearTypes() -> Pogoprotos.Data.Battle.BattleAction.Builder {
           builderResult.hasTypes = false
           builderResult.types = .ActionUnset
           return self
        }
      public var hasActionStartMs:Bool {
           get {
                return builderResult.hasActionStartMs
           }
      }
      public var actionStartMs:Int64 {
           get {
                return builderResult.actionStartMs
           }
           set (value) {
               builderResult.hasActionStartMs = true
               builderResult.actionStartMs = value
           }
      }
      public func setActionStartMs(value:Int64) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.actionStartMs = value
        return self
      }
      public func clearActionStartMs() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasActionStartMs = false
           builderResult.actionStartMs = Int64(0)
           return self
      }
      public var hasDurationMs:Bool {
           get {
                return builderResult.hasDurationMs
           }
      }
      public var durationMs:Int32 {
           get {
                return builderResult.durationMs
           }
           set (value) {
               builderResult.hasDurationMs = true
               builderResult.durationMs = value
           }
      }
      public func setDurationMs(value:Int32) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.durationMs = value
        return self
      }
      public func clearDurationMs() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasDurationMs = false
           builderResult.durationMs = Int32(0)
           return self
      }
      public var hasEnergyDelta:Bool {
           get {
                return builderResult.hasEnergyDelta
           }
      }
      public var energyDelta:Int32 {
           get {
                return builderResult.energyDelta
           }
           set (value) {
               builderResult.hasEnergyDelta = true
               builderResult.energyDelta = value
           }
      }
      public func setEnergyDelta(value:Int32) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.energyDelta = value
        return self
      }
      public func clearEnergyDelta() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasEnergyDelta = false
           builderResult.energyDelta = Int32(0)
           return self
      }
      public var hasAttackerIndex:Bool {
           get {
                return builderResult.hasAttackerIndex
           }
      }
      public var attackerIndex:Int32 {
           get {
                return builderResult.attackerIndex
           }
           set (value) {
               builderResult.hasAttackerIndex = true
               builderResult.attackerIndex = value
           }
      }
      public func setAttackerIndex(value:Int32) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.attackerIndex = value
        return self
      }
      public func clearAttackerIndex() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasAttackerIndex = false
           builderResult.attackerIndex = Int32(0)
           return self
      }
      public var hasTargetIndex:Bool {
           get {
                return builderResult.hasTargetIndex
           }
      }
      public var targetIndex:Int32 {
           get {
                return builderResult.targetIndex
           }
           set (value) {
               builderResult.hasTargetIndex = true
               builderResult.targetIndex = value
           }
      }
      public func setTargetIndex(value:Int32) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.targetIndex = value
        return self
      }
      public func clearTargetIndex() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasTargetIndex = false
           builderResult.targetIndex = Int32(0)
           return self
      }
      public var hasActivePokemonId:Bool {
           get {
                return builderResult.hasActivePokemonId
           }
      }
      public var activePokemonId:UInt64 {
           get {
                return builderResult.activePokemonId
           }
           set (value) {
               builderResult.hasActivePokemonId = true
               builderResult.activePokemonId = value
           }
      }
      public func setActivePokemonId(value:UInt64) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.activePokemonId = value
        return self
      }
      public func clearActivePokemonId() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasActivePokemonId = false
           builderResult.activePokemonId = UInt64(0)
           return self
      }
      public var hasPlayerJoined:Bool {
           get {
               return builderResult.hasPlayerJoined
           }
      }
      public var playerJoined:Pogoprotos.Data.Battle.BattleParticipant! {
           get {
               if playerJoinedBuilder_ != nil {
                  builderResult.playerJoined = playerJoinedBuilder_.getMessage()
               }
               return builderResult.playerJoined
           }
           set (value) {
               builderResult.hasPlayerJoined = true
               builderResult.playerJoined = value
           }
      }
      private var playerJoinedBuilder_:Pogoprotos.Data.Battle.BattleParticipant.Builder! {
           didSet {
              builderResult.hasPlayerJoined = true
           }
      }
      public func getPlayerJoinedBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if playerJoinedBuilder_ == nil {
           playerJoinedBuilder_ = Pogoprotos.Data.Battle.BattleParticipant.Builder()
           builderResult.playerJoined = playerJoinedBuilder_.getMessage()
           if playerJoined != nil {
              try! playerJoinedBuilder_.mergeFrom(playerJoined)
           }
        }
        return playerJoinedBuilder_
      }
      public func setPlayerJoined(value:Pogoprotos.Data.Battle.BattleParticipant!) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.playerJoined = value
        return self
      }
      public func mergePlayerJoined(value:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        if builderResult.hasPlayerJoined {
          builderResult.playerJoined = try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(builderResult.playerJoined).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerJoined = value
        }
        builderResult.hasPlayerJoined = true
        return self
      }
      public func clearPlayerJoined() -> Pogoprotos.Data.Battle.BattleAction.Builder {
        playerJoinedBuilder_ = nil
        builderResult.hasPlayerJoined = false
        builderResult.playerJoined = nil
        return self
      }
      public var hasBattleResults:Bool {
           get {
               return builderResult.hasBattleResults
           }
      }
      public var battleResults:Pogoprotos.Data.Battle.BattleResults! {
           get {
               if battleResultsBuilder_ != nil {
                  builderResult.battleResults = battleResultsBuilder_.getMessage()
               }
               return builderResult.battleResults
           }
           set (value) {
               builderResult.hasBattleResults = true
               builderResult.battleResults = value
           }
      }
      private var battleResultsBuilder_:Pogoprotos.Data.Battle.BattleResults.Builder! {
           didSet {
              builderResult.hasBattleResults = true
           }
      }
      public func getBattleResultsBuilder() -> Pogoprotos.Data.Battle.BattleResults.Builder {
        if battleResultsBuilder_ == nil {
           battleResultsBuilder_ = Pogoprotos.Data.Battle.BattleResults.Builder()
           builderResult.battleResults = battleResultsBuilder_.getMessage()
           if battleResults != nil {
              try! battleResultsBuilder_.mergeFrom(battleResults)
           }
        }
        return battleResultsBuilder_
      }
      public func setBattleResults(value:Pogoprotos.Data.Battle.BattleResults!) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.battleResults = value
        return self
      }
      public func mergeBattleResults(value:Pogoprotos.Data.Battle.BattleResults) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        if builderResult.hasBattleResults {
          builderResult.battleResults = try Pogoprotos.Data.Battle.BattleResults.builderWithPrototype(builderResult.battleResults).mergeFrom(value).buildPartial()
        } else {
          builderResult.battleResults = value
        }
        builderResult.hasBattleResults = true
        return self
      }
      public func clearBattleResults() -> Pogoprotos.Data.Battle.BattleAction.Builder {
        battleResultsBuilder_ = nil
        builderResult.hasBattleResults = false
        builderResult.battleResults = nil
        return self
      }
      public var hasDamageWindowsStartTimestampMss:Bool {
           get {
                return builderResult.hasDamageWindowsStartTimestampMss
           }
      }
      public var damageWindowsStartTimestampMss:Int64 {
           get {
                return builderResult.damageWindowsStartTimestampMss
           }
           set (value) {
               builderResult.hasDamageWindowsStartTimestampMss = true
               builderResult.damageWindowsStartTimestampMss = value
           }
      }
      public func setDamageWindowsStartTimestampMss(value:Int64) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.damageWindowsStartTimestampMss = value
        return self
      }
      public func clearDamageWindowsStartTimestampMss() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasDamageWindowsStartTimestampMss = false
           builderResult.damageWindowsStartTimestampMss = Int64(0)
           return self
      }
      public var hasDamageWindowsEndTimestampMss:Bool {
           get {
                return builderResult.hasDamageWindowsEndTimestampMss
           }
      }
      public var damageWindowsEndTimestampMss:Int64 {
           get {
                return builderResult.damageWindowsEndTimestampMss
           }
           set (value) {
               builderResult.hasDamageWindowsEndTimestampMss = true
               builderResult.damageWindowsEndTimestampMss = value
           }
      }
      public func setDamageWindowsEndTimestampMss(value:Int64) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.damageWindowsEndTimestampMss = value
        return self
      }
      public func clearDamageWindowsEndTimestampMss() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasDamageWindowsEndTimestampMss = false
           builderResult.damageWindowsEndTimestampMss = Int64(0)
           return self
      }
      public var hasPlayerLeft:Bool {
           get {
               return builderResult.hasPlayerLeft
           }
      }
      public var playerLeft:Pogoprotos.Data.Battle.BattleParticipant! {
           get {
               if playerLeftBuilder_ != nil {
                  builderResult.playerLeft = playerLeftBuilder_.getMessage()
               }
               return builderResult.playerLeft
           }
           set (value) {
               builderResult.hasPlayerLeft = true
               builderResult.playerLeft = value
           }
      }
      private var playerLeftBuilder_:Pogoprotos.Data.Battle.BattleParticipant.Builder! {
           didSet {
              builderResult.hasPlayerLeft = true
           }
      }
      public func getPlayerLeftBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if playerLeftBuilder_ == nil {
           playerLeftBuilder_ = Pogoprotos.Data.Battle.BattleParticipant.Builder()
           builderResult.playerLeft = playerLeftBuilder_.getMessage()
           if playerLeft != nil {
              try! playerLeftBuilder_.mergeFrom(playerLeft)
           }
        }
        return playerLeftBuilder_
      }
      public func setPlayerLeft(value:Pogoprotos.Data.Battle.BattleParticipant!) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.playerLeft = value
        return self
      }
      public func mergePlayerLeft(value:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        if builderResult.hasPlayerLeft {
          builderResult.playerLeft = try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(builderResult.playerLeft).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerLeft = value
        }
        builderResult.hasPlayerLeft = true
        return self
      }
      public func clearPlayerLeft() -> Pogoprotos.Data.Battle.BattleAction.Builder {
        playerLeftBuilder_ = nil
        builderResult.hasPlayerLeft = false
        builderResult.playerLeft = nil
        return self
      }
      public var hasTargetPokemonId:Bool {
           get {
                return builderResult.hasTargetPokemonId
           }
      }
      public var targetPokemonId:UInt64 {
           get {
                return builderResult.targetPokemonId
           }
           set (value) {
               builderResult.hasTargetPokemonId = true
               builderResult.targetPokemonId = value
           }
      }
      public func setTargetPokemonId(value:UInt64) -> Pogoprotos.Data.Battle.BattleAction.Builder {
        self.targetPokemonId = value
        return self
      }
      public func clearTargetPokemonId() -> Pogoprotos.Data.Battle.BattleAction.Builder{
           builderResult.hasTargetPokemonId = false
           builderResult.targetPokemonId = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Data.Battle.BattleAction.Builder {
        builderResult = Pogoprotos.Data.Battle.BattleAction()
        return self
      }
      override public func clone() throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        return try Pogoprotos.Data.Battle.BattleAction.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Data.Battle.BattleAction {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Data.Battle.BattleAction {
        let returnMe:Pogoprotos.Data.Battle.BattleAction = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Data.Battle.BattleAction) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        if other == Pogoprotos.Data.Battle.BattleAction() {
         return self
        }
        if other.hasTypes {
             types = other.types
        }
        if other.hasActionStartMs {
             actionStartMs = other.actionStartMs
        }
        if other.hasDurationMs {
             durationMs = other.durationMs
        }
        if other.hasEnergyDelta {
             energyDelta = other.energyDelta
        }
        if other.hasAttackerIndex {
             attackerIndex = other.attackerIndex
        }
        if other.hasTargetIndex {
             targetIndex = other.targetIndex
        }
        if other.hasActivePokemonId {
             activePokemonId = other.activePokemonId
        }
        if (other.hasPlayerJoined) {
            try mergePlayerJoined(other.playerJoined)
        }
        if (other.hasBattleResults) {
            try mergeBattleResults(other.battleResults)
        }
        if other.hasDamageWindowsStartTimestampMss {
             damageWindowsStartTimestampMss = other.damageWindowsStartTimestampMss
        }
        if other.hasDamageWindowsEndTimestampMss {
             damageWindowsEndTimestampMss = other.damageWindowsEndTimestampMss
        }
        if (other.hasPlayerLeft) {
            try mergePlayerLeft(other.playerLeft)
        }
        if other.hasTargetPokemonId {
             targetPokemonId = other.targetPokemonId
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueInttypes = try input.readEnum()
            if let enumstypes = Pogoprotos.Data.Battle.BattleActionType(rawValue:valueInttypes){
                 types = enumstypes
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueInttypes))
            }

          case 16:
            actionStartMs = try input.readInt64()

          case 24:
            durationMs = try input.readInt32()

          case 40:
            energyDelta = try input.readInt32()

          case 48:
            attackerIndex = try input.readInt32()

          case 56:
            targetIndex = try input.readInt32()

          case 65:
            activePokemonId = try input.readFixed64()

          case 74:
            let subBuilder:Pogoprotos.Data.Battle.BattleParticipant.Builder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
            if hasPlayerJoined {
              try subBuilder.mergeFrom(playerJoined)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerJoined = subBuilder.buildPartial()

          case 82:
            let subBuilder:Pogoprotos.Data.Battle.BattleResults.Builder = Pogoprotos.Data.Battle.BattleResults.Builder()
            if hasBattleResults {
              try subBuilder.mergeFrom(battleResults)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            battleResults = subBuilder.buildPartial()

          case 88:
            damageWindowsStartTimestampMss = try input.readInt64()

          case 96:
            damageWindowsEndTimestampMss = try input.readInt64()

          case 106:
            let subBuilder:Pogoprotos.Data.Battle.BattleParticipant.Builder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
            if hasPlayerLeft {
              try subBuilder.mergeFrom(playerLeft)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerLeft = subBuilder.buildPartial()

          case 113:
            targetPokemonId = try input.readFixed64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        let resultDecodedBuilder = Pogoprotos.Data.Battle.BattleAction.Builder()
        if let jsonValueTypes = jsonMap["type"] as? String {
          resultDecodedBuilder.types = try Pogoprotos.Data.Battle.BattleActionType.fromString(jsonValueTypes)
        }
        if let jsonValueActionStartMs = jsonMap["actionStartMs"] as? String {
          resultDecodedBuilder.actionStartMs = Int64(jsonValueActionStartMs)!
        }
        if let jsonValueDurationMs = jsonMap["durationMs"] as? NSNumber {
          resultDecodedBuilder.durationMs = jsonValueDurationMs.intValue
        }
        if let jsonValueEnergyDelta = jsonMap["energyDelta"] as? NSNumber {
          resultDecodedBuilder.energyDelta = jsonValueEnergyDelta.intValue
        }
        if let jsonValueAttackerIndex = jsonMap["attackerIndex"] as? NSNumber {
          resultDecodedBuilder.attackerIndex = jsonValueAttackerIndex.intValue
        }
        if let jsonValueTargetIndex = jsonMap["targetIndex"] as? NSNumber {
          resultDecodedBuilder.targetIndex = jsonValueTargetIndex.intValue
        }
        if let jsonValueActivePokemonId = jsonMap["activePokemonId"] as? String {
          resultDecodedBuilder.activePokemonId = UInt64(jsonValueActivePokemonId)!
        }
        if let jsonValuePlayerJoined = jsonMap["playerJoined"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerJoined = try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsonValuePlayerJoined).build()

        }
        if let jsonValueBattleResults = jsonMap["battleResults"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.battleResults = try Pogoprotos.Data.Battle.BattleResults.Builder.decodeToBuilder(jsonValueBattleResults).build()

        }
        if let jsonValueDamageWindowsStartTimestampMss = jsonMap["damageWindowsStartTimestampMss"] as? String {
          resultDecodedBuilder.damageWindowsStartTimestampMss = Int64(jsonValueDamageWindowsStartTimestampMss)!
        }
        if let jsonValueDamageWindowsEndTimestampMss = jsonMap["damageWindowsEndTimestampMss"] as? String {
          resultDecodedBuilder.damageWindowsEndTimestampMss = Int64(jsonValueDamageWindowsEndTimestampMss)!
        }
        if let jsonValuePlayerLeft = jsonMap["playerLeft"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerLeft = try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsonValuePlayerLeft).build()

        }
        if let jsonValueTargetPokemonId = jsonMap["targetPokemonId"] as? String {
          resultDecodedBuilder.targetPokemonId = UInt64(jsonValueTargetPokemonId)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Data.Battle.BattleAction.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Data.Battle.BattleAction.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class BattleLog : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var state:Pogoprotos.Data.Battle.BattleState = Pogoprotos.Data.Battle.BattleState.StateUnset
    public private(set) var hasState:Bool = false
    public private(set) var battleType:Pogoprotos.Data.Battle.BattleType = Pogoprotos.Data.Battle.BattleType.BattleTypeUnset
    public private(set) var hasBattleType:Bool = false
    public private(set) var hasServerMs:Bool = false
    public private(set) var serverMs:Int64 = Int64(0)

    public private(set) var battleActions:Array<Pogoprotos.Data.Battle.BattleAction>  = Array<Pogoprotos.Data.Battle.BattleAction>()
    public private(set) var hasBattleStartTimestampMs:Bool = false
    public private(set) var battleStartTimestampMs:Int64 = Int64(0)

    public private(set) var hasBattleEndTimestampMs:Bool = false
    public private(set) var battleEndTimestampMs:Int64 = Int64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasState {
        try output.writeEnum(1, value:state.rawValue)
      }
      if hasBattleType {
        try output.writeEnum(2, value:battleType.rawValue)
      }
      if hasServerMs {
        try output.writeInt64(3, value:serverMs)
      }
      for oneElementBattleActions in battleActions {
          try output.writeMessage(4, value:oneElementBattleActions)
      }
      if hasBattleStartTimestampMs {
        try output.writeInt64(5, value:battleStartTimestampMs)
      }
      if hasBattleEndTimestampMs {
        try output.writeInt64(6, value:battleEndTimestampMs)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasState) {
        serialize_size += state.rawValue.computeEnumSize(1)
      }
      if (hasBattleType) {
        serialize_size += battleType.rawValue.computeEnumSize(2)
      }
      if hasServerMs {
        serialize_size += serverMs.computeInt64Size(3)
      }
      for oneElementBattleActions in battleActions {
          serialize_size += oneElementBattleActions.computeMessageSize(4)
      }
      if hasBattleStartTimestampMs {
        serialize_size += battleStartTimestampMs.computeInt64Size(5)
      }
      if hasBattleEndTimestampMs {
        serialize_size += battleEndTimestampMs.computeInt64Size(6)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Data.Battle.BattleLog> {
      var mergedArray = Array<Pogoprotos.Data.Battle.BattleLog>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleLog? {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
      return Pogoprotos.Data.Battle.BattleLog.classBuilder() as! Pogoprotos.Data.Battle.BattleLog.Builder
    }
    public func getBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
      return classBuilder() as! Pogoprotos.Data.Battle.BattleLog.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleLog.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleLog.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
      return try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
      return try Pogoprotos.Data.Battle.BattleLog.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasState {
        jsonMap["state"] = state.toString()
      }
      if hasBattleType {
        jsonMap["battleType"] = battleType.toString()
      }
      if hasServerMs {
        jsonMap["serverMs"] = "\(serverMs)"
      }
      if !battleActions.isEmpty {
        var jsonArrayBattleActions:Array<Dictionary<String,AnyObject>> = []
          for oneValueBattleActions in battleActions {
            let ecodedMessageBattleActions = try oneValueBattleActions.encode()
            jsonArrayBattleActions += [ecodedMessageBattleActions]
          }
        jsonMap["battleActions"] = jsonArrayBattleActions
      }
      if hasBattleStartTimestampMs {
        jsonMap["battleStartTimestampMs"] = "\(battleStartTimestampMs)"
      }
      if hasBattleEndTimestampMs {
        jsonMap["battleEndTimestampMs"] = "\(battleEndTimestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Data.Battle.BattleLog {
      return try Pogoprotos.Data.Battle.BattleLog.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasState) {
        output += "\(indent) state: \(state.description)\n"
      }
      if (hasBattleType) {
        output += "\(indent) battleType: \(battleType.description)\n"
      }
      if hasServerMs {
        output += "\(indent) serverMs: \(serverMs) \n"
      }
      var battleActionsElementIndex:Int = 0
      for oneElementBattleActions in battleActions {
          output += "\(indent) battleActions[\(battleActionsElementIndex)] {\n"
          output += try oneElementBattleActions.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          battleActionsElementIndex += 1
      }
      if hasBattleStartTimestampMs {
        output += "\(indent) battleStartTimestampMs: \(battleStartTimestampMs) \n"
      }
      if hasBattleEndTimestampMs {
        output += "\(indent) battleEndTimestampMs: \(battleEndTimestampMs) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasState {
               hashCode = (hashCode &* 31) &+ Int(state.rawValue)
            }
            if hasBattleType {
               hashCode = (hashCode &* 31) &+ Int(battleType.rawValue)
            }
            if hasServerMs {
               hashCode = (hashCode &* 31) &+ serverMs.hashValue
            }
            for oneElementBattleActions in battleActions {
                hashCode = (hashCode &* 31) &+ oneElementBattleActions.hashValue
            }
            if hasBattleStartTimestampMs {
               hashCode = (hashCode &* 31) &+ battleStartTimestampMs.hashValue
            }
            if hasBattleEndTimestampMs {
               hashCode = (hashCode &* 31) &+ battleEndTimestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Data.Battle.BattleLog"
    }
    override public func className() -> String {
        return "Pogoprotos.Data.Battle.BattleLog"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Data.Battle.BattleLog.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Data.Battle.BattleLog = Pogoprotos.Data.Battle.BattleLog()
      public func getMessage() -> Pogoprotos.Data.Battle.BattleLog {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasState:Bool{
            get {
                return builderResult.hasState
            }
        }
        public var state:Pogoprotos.Data.Battle.BattleState {
            get {
                return builderResult.state
            }
            set (value) {
                builderResult.hasState = true
                builderResult.state = value
            }
        }
        public func setState(value:Pogoprotos.Data.Battle.BattleState) -> Pogoprotos.Data.Battle.BattleLog.Builder {
          self.state = value
          return self
        }
        public func clearState() -> Pogoprotos.Data.Battle.BattleLog.Builder {
           builderResult.hasState = false
           builderResult.state = .StateUnset
           return self
        }
        public var hasBattleType:Bool{
            get {
                return builderResult.hasBattleType
            }
        }
        public var battleType:Pogoprotos.Data.Battle.BattleType {
            get {
                return builderResult.battleType
            }
            set (value) {
                builderResult.hasBattleType = true
                builderResult.battleType = value
            }
        }
        public func setBattleType(value:Pogoprotos.Data.Battle.BattleType) -> Pogoprotos.Data.Battle.BattleLog.Builder {
          self.battleType = value
          return self
        }
        public func clearBattleType() -> Pogoprotos.Data.Battle.BattleLog.Builder {
           builderResult.hasBattleType = false
           builderResult.battleType = .BattleTypeUnset
           return self
        }
      public var hasServerMs:Bool {
           get {
                return builderResult.hasServerMs
           }
      }
      public var serverMs:Int64 {
           get {
                return builderResult.serverMs
           }
           set (value) {
               builderResult.hasServerMs = true
               builderResult.serverMs = value
           }
      }
      public func setServerMs(value:Int64) -> Pogoprotos.Data.Battle.BattleLog.Builder {
        self.serverMs = value
        return self
      }
      public func clearServerMs() -> Pogoprotos.Data.Battle.BattleLog.Builder{
           builderResult.hasServerMs = false
           builderResult.serverMs = Int64(0)
           return self
      }
      public var battleActions:Array<Pogoprotos.Data.Battle.BattleAction> {
           get {
               return builderResult.battleActions
           }
           set (value) {
               builderResult.battleActions = value
           }
      }
      public func setBattleActions(value:Array<Pogoprotos.Data.Battle.BattleAction>) -> Pogoprotos.Data.Battle.BattleLog.Builder {
        self.battleActions = value
        return self
      }
      public func clearBattleActions() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        builderResult.battleActions.removeAll(keepCapacity: false)
        return self
      }
      public var hasBattleStartTimestampMs:Bool {
           get {
                return builderResult.hasBattleStartTimestampMs
           }
      }
      public var battleStartTimestampMs:Int64 {
           get {
                return builderResult.battleStartTimestampMs
           }
           set (value) {
               builderResult.hasBattleStartTimestampMs = true
               builderResult.battleStartTimestampMs = value
           }
      }
      public func setBattleStartTimestampMs(value:Int64) -> Pogoprotos.Data.Battle.BattleLog.Builder {
        self.battleStartTimestampMs = value
        return self
      }
      public func clearBattleStartTimestampMs() -> Pogoprotos.Data.Battle.BattleLog.Builder{
           builderResult.hasBattleStartTimestampMs = false
           builderResult.battleStartTimestampMs = Int64(0)
           return self
      }
      public var hasBattleEndTimestampMs:Bool {
           get {
                return builderResult.hasBattleEndTimestampMs
           }
      }
      public var battleEndTimestampMs:Int64 {
           get {
                return builderResult.battleEndTimestampMs
           }
           set (value) {
               builderResult.hasBattleEndTimestampMs = true
               builderResult.battleEndTimestampMs = value
           }
      }
      public func setBattleEndTimestampMs(value:Int64) -> Pogoprotos.Data.Battle.BattleLog.Builder {
        self.battleEndTimestampMs = value
        return self
      }
      public func clearBattleEndTimestampMs() -> Pogoprotos.Data.Battle.BattleLog.Builder{
           builderResult.hasBattleEndTimestampMs = false
           builderResult.battleEndTimestampMs = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        builderResult = Pogoprotos.Data.Battle.BattleLog()
        return self
      }
      override public func clone() throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
        return try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Data.Battle.BattleLog {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Data.Battle.BattleLog {
        let returnMe:Pogoprotos.Data.Battle.BattleLog = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
        if other == Pogoprotos.Data.Battle.BattleLog() {
         return self
        }
        if other.hasState {
             state = other.state
        }
        if other.hasBattleType {
             battleType = other.battleType
        }
        if other.hasServerMs {
             serverMs = other.serverMs
        }
        if !other.battleActions.isEmpty  {
           builderResult.battleActions += other.battleActions
        }
        if other.hasBattleStartTimestampMs {
             battleStartTimestampMs = other.battleStartTimestampMs
        }
        if other.hasBattleEndTimestampMs {
             battleEndTimestampMs = other.battleEndTimestampMs
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstate = try input.readEnum()
            if let enumsstate = Pogoprotos.Data.Battle.BattleState(rawValue:valueIntstate){
                 state = enumsstate
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstate))
            }

          case 16:
            let valueIntbattleType = try input.readEnum()
            if let enumsbattleType = Pogoprotos.Data.Battle.BattleType(rawValue:valueIntbattleType){
                 battleType = enumsbattleType
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntbattleType))
            }

          case 24:
            serverMs = try input.readInt64()

          case 34:
            let subBuilder = Pogoprotos.Data.Battle.BattleAction.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            battleActions += [subBuilder.buildPartial()]

          case 40:
            battleStartTimestampMs = try input.readInt64()

          case 48:
            battleEndTimestampMs = try input.readInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
        let resultDecodedBuilder = Pogoprotos.Data.Battle.BattleLog.Builder()
        if let jsonValueState = jsonMap["state"] as? String {
          resultDecodedBuilder.state = try Pogoprotos.Data.Battle.BattleState.fromString(jsonValueState)
        }
        if let jsonValueBattleType = jsonMap["battleType"] as? String {
          resultDecodedBuilder.battleType = try Pogoprotos.Data.Battle.BattleType.fromString(jsonValueBattleType)
        }
        if let jsonValueServerMs = jsonMap["serverMs"] as? String {
          resultDecodedBuilder.serverMs = Int64(jsonValueServerMs)!
        }
        if let jsonValueBattleActions = jsonMap["battleActions"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayBattleActions:Array<Pogoprotos.Data.Battle.BattleAction> = []
          for oneValueBattleActions in jsonValueBattleActions {
            let messageFromStringBattleActions = try Pogoprotos.Data.Battle.BattleAction.Builder.decodeToBuilder(oneValueBattleActions).build()

            jsonArrayBattleActions += [messageFromStringBattleActions]
          }
          resultDecodedBuilder.battleActions = jsonArrayBattleActions
        }
        if let jsonValueBattleStartTimestampMs = jsonMap["battleStartTimestampMs"] as? String {
          resultDecodedBuilder.battleStartTimestampMs = Int64(jsonValueBattleStartTimestampMs)!
        }
        if let jsonValueBattleEndTimestampMs = jsonMap["battleEndTimestampMs"] as? String {
          resultDecodedBuilder.battleEndTimestampMs = Int64(jsonValueBattleEndTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Data.Battle.BattleLog.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class BattleParticipant : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasActivePokemon:Bool = false
    public private(set) var activePokemon:Pogoprotos.Data.Battle.BattlePokemonInfo!
    public private(set) var hasTrainerPublicProfile:Bool = false
    public private(set) var trainerPublicProfile:Pogoprotos.Data.Player.PlayerPublicProfile!
    public private(set) var reversePokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo>  = Array<Pogoprotos.Data.Battle.BattlePokemonInfo>()
    public private(set) var defeatedPokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo>  = Array<Pogoprotos.Data.Battle.BattlePokemonInfo>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasActivePokemon {
        try output.writeMessage(1, value:activePokemon)
      }
      if hasTrainerPublicProfile {
        try output.writeMessage(2, value:trainerPublicProfile)
      }
      for oneElementReversePokemon in reversePokemon {
          try output.writeMessage(3, value:oneElementReversePokemon)
      }
      for oneElementDefeatedPokemon in defeatedPokemon {
          try output.writeMessage(4, value:oneElementDefeatedPokemon)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasActivePokemon {
          if let varSizeactivePokemon = activePokemon?.computeMessageSize(1) {
              serialize_size += varSizeactivePokemon
          }
      }
      if hasTrainerPublicProfile {
          if let varSizetrainerPublicProfile = trainerPublicProfile?.computeMessageSize(2) {
              serialize_size += varSizetrainerPublicProfile
          }
      }
      for oneElementReversePokemon in reversePokemon {
          serialize_size += oneElementReversePokemon.computeMessageSize(3)
      }
      for oneElementDefeatedPokemon in defeatedPokemon {
          serialize_size += oneElementDefeatedPokemon.computeMessageSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Data.Battle.BattleParticipant> {
      var mergedArray = Array<Pogoprotos.Data.Battle.BattleParticipant>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleParticipant? {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
      return Pogoprotos.Data.Battle.BattleParticipant.classBuilder() as! Pogoprotos.Data.Battle.BattleParticipant.Builder
    }
    public func getBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
      return classBuilder() as! Pogoprotos.Data.Battle.BattleParticipant.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleParticipant.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleParticipant.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
      return try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasActivePokemon {
        jsonMap["activePokemon"] = try activePokemon.encode()
      }
      if hasTrainerPublicProfile {
        jsonMap["trainerPublicProfile"] = try trainerPublicProfile.encode()
      }
      if !reversePokemon.isEmpty {
        var jsonArrayReversePokemon:Array<Dictionary<String,AnyObject>> = []
          for oneValueReversePokemon in reversePokemon {
            let ecodedMessageReversePokemon = try oneValueReversePokemon.encode()
            jsonArrayReversePokemon += [ecodedMessageReversePokemon]
          }
        jsonMap["reversePokemon"] = jsonArrayReversePokemon
      }
      if !defeatedPokemon.isEmpty {
        var jsonArrayDefeatedPokemon:Array<Dictionary<String,AnyObject>> = []
          for oneValueDefeatedPokemon in defeatedPokemon {
            let ecodedMessageDefeatedPokemon = try oneValueDefeatedPokemon.encode()
            jsonArrayDefeatedPokemon += [ecodedMessageDefeatedPokemon]
          }
        jsonMap["defeatedPokemon"] = jsonArrayDefeatedPokemon
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Data.Battle.BattleParticipant {
      return try Pogoprotos.Data.Battle.BattleParticipant.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasActivePokemon {
        output += "\(indent) activePokemon {\n"
        if let outDescActivePokemon = activePokemon {
          output += try outDescActivePokemon.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasTrainerPublicProfile {
        output += "\(indent) trainerPublicProfile {\n"
        if let outDescTrainerPublicProfile = trainerPublicProfile {
          output += try outDescTrainerPublicProfile.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var reversePokemonElementIndex:Int = 0
      for oneElementReversePokemon in reversePokemon {
          output += "\(indent) reversePokemon[\(reversePokemonElementIndex)] {\n"
          output += try oneElementReversePokemon.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          reversePokemonElementIndex += 1
      }
      var defeatedPokemonElementIndex:Int = 0
      for oneElementDefeatedPokemon in defeatedPokemon {
          output += "\(indent) defeatedPokemon[\(defeatedPokemonElementIndex)] {\n"
          output += try oneElementDefeatedPokemon.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          defeatedPokemonElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasActivePokemon {
                if let hashValueactivePokemon = activePokemon?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueactivePokemon
                }
            }
            if hasTrainerPublicProfile {
                if let hashValuetrainerPublicProfile = trainerPublicProfile?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetrainerPublicProfile
                }
            }
            for oneElementReversePokemon in reversePokemon {
                hashCode = (hashCode &* 31) &+ oneElementReversePokemon.hashValue
            }
            for oneElementDefeatedPokemon in defeatedPokemon {
                hashCode = (hashCode &* 31) &+ oneElementDefeatedPokemon.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Data.Battle.BattleParticipant"
    }
    override public func className() -> String {
        return "Pogoprotos.Data.Battle.BattleParticipant"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Data.Battle.BattleParticipant.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Data.Battle.BattleParticipant = Pogoprotos.Data.Battle.BattleParticipant()
      public func getMessage() -> Pogoprotos.Data.Battle.BattleParticipant {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasActivePokemon:Bool {
           get {
               return builderResult.hasActivePokemon
           }
      }
      public var activePokemon:Pogoprotos.Data.Battle.BattlePokemonInfo! {
           get {
               if activePokemonBuilder_ != nil {
                  builderResult.activePokemon = activePokemonBuilder_.getMessage()
               }
               return builderResult.activePokemon
           }
           set (value) {
               builderResult.hasActivePokemon = true
               builderResult.activePokemon = value
           }
      }
      private var activePokemonBuilder_:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder! {
           didSet {
              builderResult.hasActivePokemon = true
           }
      }
      public func getActivePokemonBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if activePokemonBuilder_ == nil {
           activePokemonBuilder_ = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
           builderResult.activePokemon = activePokemonBuilder_.getMessage()
           if activePokemon != nil {
              try! activePokemonBuilder_.mergeFrom(activePokemon)
           }
        }
        return activePokemonBuilder_
      }
      public func setActivePokemon(value:Pogoprotos.Data.Battle.BattlePokemonInfo!) -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        self.activePokemon = value
        return self
      }
      public func mergeActivePokemon(value:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if builderResult.hasActivePokemon {
          builderResult.activePokemon = try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(builderResult.activePokemon).mergeFrom(value).buildPartial()
        } else {
          builderResult.activePokemon = value
        }
        builderResult.hasActivePokemon = true
        return self
      }
      public func clearActivePokemon() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        activePokemonBuilder_ = nil
        builderResult.hasActivePokemon = false
        builderResult.activePokemon = nil
        return self
      }
      public var hasTrainerPublicProfile:Bool {
           get {
               return builderResult.hasTrainerPublicProfile
           }
      }
      public var trainerPublicProfile:Pogoprotos.Data.Player.PlayerPublicProfile! {
           get {
               if trainerPublicProfileBuilder_ != nil {
                  builderResult.trainerPublicProfile = trainerPublicProfileBuilder_.getMessage()
               }
               return builderResult.trainerPublicProfile
           }
           set (value) {
               builderResult.hasTrainerPublicProfile = true
               builderResult.trainerPublicProfile = value
           }
      }
      private var trainerPublicProfileBuilder_:Pogoprotos.Data.Player.PlayerPublicProfile.Builder! {
           didSet {
              builderResult.hasTrainerPublicProfile = true
           }
      }
      public func getTrainerPublicProfileBuilder() -> Pogoprotos.Data.Player.PlayerPublicProfile.Builder {
        if trainerPublicProfileBuilder_ == nil {
           trainerPublicProfileBuilder_ = Pogoprotos.Data.Player.PlayerPublicProfile.Builder()
           builderResult.trainerPublicProfile = trainerPublicProfileBuilder_.getMessage()
           if trainerPublicProfile != nil {
              try! trainerPublicProfileBuilder_.mergeFrom(trainerPublicProfile)
           }
        }
        return trainerPublicProfileBuilder_
      }
      public func setTrainerPublicProfile(value:Pogoprotos.Data.Player.PlayerPublicProfile!) -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        self.trainerPublicProfile = value
        return self
      }
      public func mergeTrainerPublicProfile(value:Pogoprotos.Data.Player.PlayerPublicProfile) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if builderResult.hasTrainerPublicProfile {
          builderResult.trainerPublicProfile = try Pogoprotos.Data.Player.PlayerPublicProfile.builderWithPrototype(builderResult.trainerPublicProfile).mergeFrom(value).buildPartial()
        } else {
          builderResult.trainerPublicProfile = value
        }
        builderResult.hasTrainerPublicProfile = true
        return self
      }
      public func clearTrainerPublicProfile() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        trainerPublicProfileBuilder_ = nil
        builderResult.hasTrainerPublicProfile = false
        builderResult.trainerPublicProfile = nil
        return self
      }
      public var reversePokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo> {
           get {
               return builderResult.reversePokemon
           }
           set (value) {
               builderResult.reversePokemon = value
           }
      }
      public func setReversePokemon(value:Array<Pogoprotos.Data.Battle.BattlePokemonInfo>) -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        self.reversePokemon = value
        return self
      }
      public func clearReversePokemon() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        builderResult.reversePokemon.removeAll(keepCapacity: false)
        return self
      }
      public var defeatedPokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo> {
           get {
               return builderResult.defeatedPokemon
           }
           set (value) {
               builderResult.defeatedPokemon = value
           }
      }
      public func setDefeatedPokemon(value:Array<Pogoprotos.Data.Battle.BattlePokemonInfo>) -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        self.defeatedPokemon = value
        return self
      }
      public func clearDefeatedPokemon() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        builderResult.defeatedPokemon.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        builderResult = Pogoprotos.Data.Battle.BattleParticipant()
        return self
      }
      override public func clone() throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        return try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Data.Battle.BattleParticipant {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Data.Battle.BattleParticipant {
        let returnMe:Pogoprotos.Data.Battle.BattleParticipant = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if other == Pogoprotos.Data.Battle.BattleParticipant() {
         return self
        }
        if (other.hasActivePokemon) {
            try mergeActivePokemon(other.activePokemon)
        }
        if (other.hasTrainerPublicProfile) {
            try mergeTrainerPublicProfile(other.trainerPublicProfile)
        }
        if !other.reversePokemon.isEmpty  {
           builderResult.reversePokemon += other.reversePokemon
        }
        if !other.defeatedPokemon.isEmpty  {
           builderResult.defeatedPokemon += other.defeatedPokemon
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            if hasActivePokemon {
              try subBuilder.mergeFrom(activePokemon)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            activePokemon = subBuilder.buildPartial()

          case 18:
            let subBuilder:Pogoprotos.Data.Player.PlayerPublicProfile.Builder = Pogoprotos.Data.Player.PlayerPublicProfile.Builder()
            if hasTrainerPublicProfile {
              try subBuilder.mergeFrom(trainerPublicProfile)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            trainerPublicProfile = subBuilder.buildPartial()

          case 26:
            let subBuilder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            reversePokemon += [subBuilder.buildPartial()]

          case 34:
            let subBuilder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            defeatedPokemon += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        let resultDecodedBuilder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
        if let jsonValueActivePokemon = jsonMap["activePokemon"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.activePokemon = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonValueActivePokemon).build()

        }
        if let jsonValueTrainerPublicProfile = jsonMap["trainerPublicProfile"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.trainerPublicProfile = try Pogoprotos.Data.Player.PlayerPublicProfile.Builder.decodeToBuilder(jsonValueTrainerPublicProfile).build()

        }
        if let jsonValueReversePokemon = jsonMap["reversePokemon"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayReversePokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo> = []
          for oneValueReversePokemon in jsonValueReversePokemon {
            let messageFromStringReversePokemon = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(oneValueReversePokemon).build()

            jsonArrayReversePokemon += [messageFromStringReversePokemon]
          }
          resultDecodedBuilder.reversePokemon = jsonArrayReversePokemon
        }
        if let jsonValueDefeatedPokemon = jsonMap["defeatedPokemon"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayDefeatedPokemon:Array<Pogoprotos.Data.Battle.BattlePokemonInfo> = []
          for oneValueDefeatedPokemon in jsonValueDefeatedPokemon {
            let messageFromStringDefeatedPokemon = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(oneValueDefeatedPokemon).build()

            jsonArrayDefeatedPokemon += [messageFromStringDefeatedPokemon]
          }
          resultDecodedBuilder.defeatedPokemon = jsonArrayDefeatedPokemon
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class BattlePokemonInfo : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasCurrentHealth:Bool = false
    public private(set) var currentHealth:Int32 = Int32(0)

    public private(set) var hasCurrentEnergy:Bool = false
    public private(set) var currentEnergy:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasPokemonData {
        try output.writeMessage(1, value:pokemonData)
      }
      if hasCurrentHealth {
        try output.writeInt32(2, value:currentHealth)
      }
      if hasCurrentEnergy {
        try output.writeInt32(3, value:currentEnergy)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(1) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCurrentHealth {
        serialize_size += currentHealth.computeInt32Size(2)
      }
      if hasCurrentEnergy {
        serialize_size += currentEnergy.computeInt32Size(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Data.Battle.BattlePokemonInfo> {
      var mergedArray = Array<Pogoprotos.Data.Battle.BattlePokemonInfo>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo? {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
      return Pogoprotos.Data.Battle.BattlePokemonInfo.classBuilder() as! Pogoprotos.Data.Battle.BattlePokemonInfo.Builder
    }
    public func getBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
      return classBuilder() as! Pogoprotos.Data.Battle.BattlePokemonInfo.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCurrentHealth {
        jsonMap["currentHealth"] = NSNumber(int:currentHealth)
      }
      if hasCurrentEnergy {
        jsonMap["currentEnergy"] = NSNumber(int:currentEnergy)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
      return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCurrentHealth {
        output += "\(indent) currentHealth: \(currentHealth) \n"
      }
      if hasCurrentEnergy {
        output += "\(indent) currentEnergy: \(currentEnergy) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCurrentHealth {
               hashCode = (hashCode &* 31) &+ currentHealth.hashValue
            }
            if hasCurrentEnergy {
               hashCode = (hashCode &* 31) &+ currentEnergy.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Data.Battle.BattlePokemonInfo"
    }
    override public func className() -> String {
        return "Pogoprotos.Data.Battle.BattlePokemonInfo"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Data.Battle.BattlePokemonInfo.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Data.Battle.BattlePokemonInfo = Pogoprotos.Data.Battle.BattlePokemonInfo()
      public func getMessage() -> Pogoprotos.Data.Battle.BattlePokemonInfo {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCurrentHealth:Bool {
           get {
                return builderResult.hasCurrentHealth
           }
      }
      public var currentHealth:Int32 {
           get {
                return builderResult.currentHealth
           }
           set (value) {
               builderResult.hasCurrentHealth = true
               builderResult.currentHealth = value
           }
      }
      public func setCurrentHealth(value:Int32) -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        self.currentHealth = value
        return self
      }
      public func clearCurrentHealth() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder{
           builderResult.hasCurrentHealth = false
           builderResult.currentHealth = Int32(0)
           return self
      }
      public var hasCurrentEnergy:Bool {
           get {
                return builderResult.hasCurrentEnergy
           }
      }
      public var currentEnergy:Int32 {
           get {
                return builderResult.currentEnergy
           }
           set (value) {
               builderResult.hasCurrentEnergy = true
               builderResult.currentEnergy = value
           }
      }
      public func setCurrentEnergy(value:Int32) -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        self.currentEnergy = value
        return self
      }
      public func clearCurrentEnergy() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder{
           builderResult.hasCurrentEnergy = false
           builderResult.currentEnergy = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        builderResult = Pogoprotos.Data.Battle.BattlePokemonInfo()
        return self
      }
      override public func clone() throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        return try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Data.Battle.BattlePokemonInfo {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Data.Battle.BattlePokemonInfo {
        let returnMe:Pogoprotos.Data.Battle.BattlePokemonInfo = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if other == Pogoprotos.Data.Battle.BattlePokemonInfo() {
         return self
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if other.hasCurrentHealth {
             currentHealth = other.currentHealth
        }
        if other.hasCurrentEnergy {
             currentEnergy = other.currentEnergy
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 16:
            currentHealth = try input.readInt32()

          case 24:
            currentEnergy = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        let resultDecodedBuilder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueCurrentHealth = jsonMap["currentHealth"] as? NSNumber {
          resultDecodedBuilder.currentHealth = jsonValueCurrentHealth.intValue
        }
        if let jsonValueCurrentEnergy = jsonMap["currentEnergy"] as? NSNumber {
          resultDecodedBuilder.currentEnergy = jsonValueCurrentEnergy.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class BattleResults : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasGymState:Bool = false
    public private(set) var gymState:Pogoprotos.Data.Gym.GymState!
    public private(set) var attackers:Array<Pogoprotos.Data.Battle.BattleParticipant>  = Array<Pogoprotos.Data.Battle.BattleParticipant>()
    public private(set) var playerExperienceAwarded:Array<Int32> = Array<Int32>()
    private var playerExperienceAwardedMemoizedSerializedSize:Int32 = -1
    public private(set) var hasNextDefenderPokemonId:Bool = false
    public private(set) var nextDefenderPokemonId:Int64 = Int64(0)

    public private(set) var hasGymPointsDelta:Bool = false
    public private(set) var gymPointsDelta:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasGymState {
        try output.writeMessage(1, value:gymState)
      }
      for oneElementAttackers in attackers {
          try output.writeMessage(2, value:oneElementAttackers)
      }
      if !playerExperienceAwarded.isEmpty {
        try output.writeRawVarint32(26)
        try output.writeRawVarint32(playerExperienceAwardedMemoizedSerializedSize)
        for oneValueplayerExperienceAwarded in playerExperienceAwarded {
          try output.writeInt32NoTag(oneValueplayerExperienceAwarded)
        }
      }
      if hasNextDefenderPokemonId {
        try output.writeInt64(4, value:nextDefenderPokemonId)
      }
      if hasGymPointsDelta {
        try output.writeInt32(5, value:gymPointsDelta)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasGymState {
          if let varSizegymState = gymState?.computeMessageSize(1) {
              serialize_size += varSizegymState
          }
      }
      for oneElementAttackers in attackers {
          serialize_size += oneElementAttackers.computeMessageSize(2)
      }
      var dataSizePlayerExperienceAwarded:Int32 = 0
      for oneValueplayerExperienceAwarded in playerExperienceAwarded {
          dataSizePlayerExperienceAwarded += oneValueplayerExperienceAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizePlayerExperienceAwarded
      if !playerExperienceAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizePlayerExperienceAwarded.computeInt32SizeNoTag()
      }
      playerExperienceAwardedMemoizedSerializedSize = dataSizePlayerExperienceAwarded
      if hasNextDefenderPokemonId {
        serialize_size += nextDefenderPokemonId.computeInt64Size(4)
      }
      if hasGymPointsDelta {
        serialize_size += gymPointsDelta.computeInt32Size(5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Data.Battle.BattleResults> {
      var mergedArray = Array<Pogoprotos.Data.Battle.BattleResults>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleResults? {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Data.Battle.BattleResults.Builder {
      return Pogoprotos.Data.Battle.BattleResults.classBuilder() as! Pogoprotos.Data.Battle.BattleResults.Builder
    }
    public func getBuilder() -> Pogoprotos.Data.Battle.BattleResults.Builder {
      return classBuilder() as! Pogoprotos.Data.Battle.BattleResults.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleResults.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Data.Battle.BattleResults.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
      return try Pogoprotos.Data.Battle.BattleResults.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Data.Battle.BattleResults) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
      return try Pogoprotos.Data.Battle.BattleResults.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasGymState {
        jsonMap["gymState"] = try gymState.encode()
      }
      if !attackers.isEmpty {
        var jsonArrayAttackers:Array<Dictionary<String,AnyObject>> = []
          for oneValueAttackers in attackers {
            let ecodedMessageAttackers = try oneValueAttackers.encode()
            jsonArrayAttackers += [ecodedMessageAttackers]
          }
        jsonMap["attackers"] = jsonArrayAttackers
      }
      if !playerExperienceAwarded.isEmpty {
        var jsonArrayPlayerExperienceAwarded:Array<NSNumber> = []
          for oneValuePlayerExperienceAwarded in playerExperienceAwarded {
            jsonArrayPlayerExperienceAwarded += [NSNumber(int:oneValuePlayerExperienceAwarded)]
          }
        jsonMap["playerExperienceAwarded"] = jsonArrayPlayerExperienceAwarded
      }
      if hasNextDefenderPokemonId {
        jsonMap["nextDefenderPokemonId"] = "\(nextDefenderPokemonId)"
      }
      if hasGymPointsDelta {
        jsonMap["gymPointsDelta"] = NSNumber(int:gymPointsDelta)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Data.Battle.BattleResults {
      return try Pogoprotos.Data.Battle.BattleResults.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasGymState {
        output += "\(indent) gymState {\n"
        if let outDescGymState = gymState {
          output += try outDescGymState.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      var attackersElementIndex:Int = 0
      for oneElementAttackers in attackers {
          output += "\(indent) attackers[\(attackersElementIndex)] {\n"
          output += try oneElementAttackers.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          attackersElementIndex += 1
      }
      var playerExperienceAwardedElementIndex:Int = 0
      for oneValuePlayerExperienceAwarded in playerExperienceAwarded  {
          output += "\(indent) playerExperienceAwarded[\(playerExperienceAwardedElementIndex)]: \(oneValuePlayerExperienceAwarded)\n"
          playerExperienceAwardedElementIndex += 1
      }
      if hasNextDefenderPokemonId {
        output += "\(indent) nextDefenderPokemonId: \(nextDefenderPokemonId) \n"
      }
      if hasGymPointsDelta {
        output += "\(indent) gymPointsDelta: \(gymPointsDelta) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasGymState {
                if let hashValuegymState = gymState?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegymState
                }
            }
            for oneElementAttackers in attackers {
                hashCode = (hashCode &* 31) &+ oneElementAttackers.hashValue
            }
            for oneValuePlayerExperienceAwarded in playerExperienceAwarded {
                hashCode = (hashCode &* 31) &+ oneValuePlayerExperienceAwarded.hashValue
            }
            if hasNextDefenderPokemonId {
               hashCode = (hashCode &* 31) &+ nextDefenderPokemonId.hashValue
            }
            if hasGymPointsDelta {
               hashCode = (hashCode &* 31) &+ gymPointsDelta.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Data.Battle.BattleResults"
    }
    override public func className() -> String {
        return "Pogoprotos.Data.Battle.BattleResults"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Data.Battle.BattleResults.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Data.Battle.BattleResults = Pogoprotos.Data.Battle.BattleResults()
      public func getMessage() -> Pogoprotos.Data.Battle.BattleResults {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasGymState:Bool {
           get {
               return builderResult.hasGymState
           }
      }
      public var gymState:Pogoprotos.Data.Gym.GymState! {
           get {
               if gymStateBuilder_ != nil {
                  builderResult.gymState = gymStateBuilder_.getMessage()
               }
               return builderResult.gymState
           }
           set (value) {
               builderResult.hasGymState = true
               builderResult.gymState = value
           }
      }
      private var gymStateBuilder_:Pogoprotos.Data.Gym.GymState.Builder! {
           didSet {
              builderResult.hasGymState = true
           }
      }
      public func getGymStateBuilder() -> Pogoprotos.Data.Gym.GymState.Builder {
        if gymStateBuilder_ == nil {
           gymStateBuilder_ = Pogoprotos.Data.Gym.GymState.Builder()
           builderResult.gymState = gymStateBuilder_.getMessage()
           if gymState != nil {
              try! gymStateBuilder_.mergeFrom(gymState)
           }
        }
        return gymStateBuilder_
      }
      public func setGymState(value:Pogoprotos.Data.Gym.GymState!) -> Pogoprotos.Data.Battle.BattleResults.Builder {
        self.gymState = value
        return self
      }
      public func mergeGymState(value:Pogoprotos.Data.Gym.GymState) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        if builderResult.hasGymState {
          builderResult.gymState = try Pogoprotos.Data.Gym.GymState.builderWithPrototype(builderResult.gymState).mergeFrom(value).buildPartial()
        } else {
          builderResult.gymState = value
        }
        builderResult.hasGymState = true
        return self
      }
      public func clearGymState() -> Pogoprotos.Data.Battle.BattleResults.Builder {
        gymStateBuilder_ = nil
        builderResult.hasGymState = false
        builderResult.gymState = nil
        return self
      }
      public var attackers:Array<Pogoprotos.Data.Battle.BattleParticipant> {
           get {
               return builderResult.attackers
           }
           set (value) {
               builderResult.attackers = value
           }
      }
      public func setAttackers(value:Array<Pogoprotos.Data.Battle.BattleParticipant>) -> Pogoprotos.Data.Battle.BattleResults.Builder {
        self.attackers = value
        return self
      }
      public func clearAttackers() -> Pogoprotos.Data.Battle.BattleResults.Builder {
        builderResult.attackers.removeAll(keepCapacity: false)
        return self
      }
      public var playerExperienceAwarded:Array<Int32> {
           get {
               return builderResult.playerExperienceAwarded
           }
           set (array) {
               builderResult.playerExperienceAwarded = array
           }
      }
      public func setPlayerExperienceAwarded(value:Array<Int32>) -> Pogoprotos.Data.Battle.BattleResults.Builder {
        self.playerExperienceAwarded = value
        return self
      }
      public func clearPlayerExperienceAwarded() -> Pogoprotos.Data.Battle.BattleResults.Builder {
         builderResult.playerExperienceAwarded.removeAll(keepCapacity: false)
         return self
      }
      public var hasNextDefenderPokemonId:Bool {
           get {
                return builderResult.hasNextDefenderPokemonId
           }
      }
      public var nextDefenderPokemonId:Int64 {
           get {
                return builderResult.nextDefenderPokemonId
           }
           set (value) {
               builderResult.hasNextDefenderPokemonId = true
               builderResult.nextDefenderPokemonId = value
           }
      }
      public func setNextDefenderPokemonId(value:Int64) -> Pogoprotos.Data.Battle.BattleResults.Builder {
        self.nextDefenderPokemonId = value
        return self
      }
      public func clearNextDefenderPokemonId() -> Pogoprotos.Data.Battle.BattleResults.Builder{
           builderResult.hasNextDefenderPokemonId = false
           builderResult.nextDefenderPokemonId = Int64(0)
           return self
      }
      public var hasGymPointsDelta:Bool {
           get {
                return builderResult.hasGymPointsDelta
           }
      }
      public var gymPointsDelta:Int32 {
           get {
                return builderResult.gymPointsDelta
           }
           set (value) {
               builderResult.hasGymPointsDelta = true
               builderResult.gymPointsDelta = value
           }
      }
      public func setGymPointsDelta(value:Int32) -> Pogoprotos.Data.Battle.BattleResults.Builder {
        self.gymPointsDelta = value
        return self
      }
      public func clearGymPointsDelta() -> Pogoprotos.Data.Battle.BattleResults.Builder{
           builderResult.hasGymPointsDelta = false
           builderResult.gymPointsDelta = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Data.Battle.BattleResults.Builder {
        builderResult = Pogoprotos.Data.Battle.BattleResults()
        return self
      }
      override public func clone() throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        return try Pogoprotos.Data.Battle.BattleResults.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Data.Battle.BattleResults {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Data.Battle.BattleResults {
        let returnMe:Pogoprotos.Data.Battle.BattleResults = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Data.Battle.BattleResults) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        if other == Pogoprotos.Data.Battle.BattleResults() {
         return self
        }
        if (other.hasGymState) {
            try mergeGymState(other.gymState)
        }
        if !other.attackers.isEmpty  {
           builderResult.attackers += other.attackers
        }
        if !other.playerExperienceAwarded.isEmpty {
            builderResult.playerExperienceAwarded += other.playerExperienceAwarded
        }
        if other.hasNextDefenderPokemonId {
             nextDefenderPokemonId = other.nextDefenderPokemonId
        }
        if other.hasGymPointsDelta {
             gymPointsDelta = other.gymPointsDelta
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Data.Gym.GymState.Builder = Pogoprotos.Data.Gym.GymState.Builder()
            if hasGymState {
              try subBuilder.mergeFrom(gymState)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            gymState = subBuilder.buildPartial()

          case 18:
            let subBuilder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            attackers += [subBuilder.buildPartial()]

          case 26:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.playerExperienceAwarded += [try input.readInt32()]
            }
            input.popLimit(limit)

          case 32:
            nextDefenderPokemonId = try input.readInt64()

          case 40:
            gymPointsDelta = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        let resultDecodedBuilder = Pogoprotos.Data.Battle.BattleResults.Builder()
        if let jsonValueGymState = jsonMap["gymState"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.gymState = try Pogoprotos.Data.Gym.GymState.Builder.decodeToBuilder(jsonValueGymState).build()

        }
        if let jsonValueAttackers = jsonMap["attackers"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayAttackers:Array<Pogoprotos.Data.Battle.BattleParticipant> = []
          for oneValueAttackers in jsonValueAttackers {
            let messageFromStringAttackers = try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(oneValueAttackers).build()

            jsonArrayAttackers += [messageFromStringAttackers]
          }
          resultDecodedBuilder.attackers = jsonArrayAttackers
        }
        if let jsonValuePlayerExperienceAwarded = jsonMap["playerExperienceAwarded"] as? Array<NSNumber> {
          var jsonArrayPlayerExperienceAwarded:Array<Int32> = []
          for oneValuePlayerExperienceAwarded in jsonValuePlayerExperienceAwarded {
            jsonArrayPlayerExperienceAwarded += [oneValuePlayerExperienceAwarded.intValue]
          }
          resultDecodedBuilder.playerExperienceAwarded = jsonArrayPlayerExperienceAwarded
        }
        if let jsonValueNextDefenderPokemonId = jsonMap["nextDefenderPokemonId"] as? String {
          resultDecodedBuilder.nextDefenderPokemonId = Int64(jsonValueNextDefenderPokemonId)!
        }
        if let jsonValueGymPointsDelta = jsonMap["gymPointsDelta"] as? NSNumber {
          resultDecodedBuilder.gymPointsDelta = jsonValueGymPointsDelta.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Data.Battle.BattleResults.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Data.Battle.BattleResults.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
