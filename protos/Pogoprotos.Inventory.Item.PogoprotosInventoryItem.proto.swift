// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "POGOProtos.Inventory.Item.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public func == (lhs: Pogoprotos.Inventory.Item.ItemAward, rhs: Pogoprotos.Inventory.Item.ItemAward) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasItemCount == rhs.hasItemCount) && (!lhs.hasItemCount || lhs.itemCount == rhs.itemCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Inventory.Item.ItemData, rhs: Pogoprotos.Inventory.Item.ItemData) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasItemId == rhs.hasItemId) && (!lhs.hasItemId || lhs.itemId == rhs.itemId)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.hasUnseen == rhs.hasUnseen) && (!lhs.hasUnseen || lhs.unseen == rhs.unseen)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Pogoprotos.Inventory.Item {
  public struct PogoprotosInventoryItemRoot {
    public static var sharedInstance : PogoprotosInventoryItemRoot {
     struct Static {
         static let instance : PogoprotosInventoryItemRoot = PogoprotosInventoryItemRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum ItemId:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case ItemUnknown = 0
    case ItemPokeBall = 1
    case ItemGreatBall = 2
    case ItemUltraBall = 3
    case ItemMasterBall = 4
    case ItemPotion = 101
    case ItemSuperPotion = 102
    case ItemHyperPotion = 103
    case ItemMaxPotion = 104
    case ItemRevive = 201
    case ItemMaxRevive = 202
    case ItemLuckyEgg = 301
    case ItemIncenseOrdinary = 401
    case ItemIncenseSpicy = 402
    case ItemIncenseCool = 403
    case ItemIncenseFloral = 404
    case ItemTroyDisk = 501
    case ItemXAttack = 602
    case ItemXDefense = 603
    case ItemXMiracle = 604
    case ItemRazzBerry = 701
    case ItemBlukBerry = 702
    case ItemNanabBerry = 703
    case ItemWeparBerry = 704
    case ItemPinapBerry = 705
    case ItemSpecialCamera = 801
    case ItemIncubatorBasicUnlimited = 901
    case ItemIncubatorBasic = 902
    case ItemPokemonStorageUpgrade = 1001
    case ItemItemStorageUpgrade = 1002
    public func toString() -> String {
      switch self {
      case .ItemUnknown: return "ITEM_UNKNOWN"
      case .ItemPokeBall: return "ITEM_POKE_BALL"
      case .ItemGreatBall: return "ITEM_GREAT_BALL"
      case .ItemUltraBall: return "ITEM_ULTRA_BALL"
      case .ItemMasterBall: return "ITEM_MASTER_BALL"
      case .ItemPotion: return "ITEM_POTION"
      case .ItemSuperPotion: return "ITEM_SUPER_POTION"
      case .ItemHyperPotion: return "ITEM_HYPER_POTION"
      case .ItemMaxPotion: return "ITEM_MAX_POTION"
      case .ItemRevive: return "ITEM_REVIVE"
      case .ItemMaxRevive: return "ITEM_MAX_REVIVE"
      case .ItemLuckyEgg: return "ITEM_LUCKY_EGG"
      case .ItemIncenseOrdinary: return "ITEM_INCENSE_ORDINARY"
      case .ItemIncenseSpicy: return "ITEM_INCENSE_SPICY"
      case .ItemIncenseCool: return "ITEM_INCENSE_COOL"
      case .ItemIncenseFloral: return "ITEM_INCENSE_FLORAL"
      case .ItemTroyDisk: return "ITEM_TROY_DISK"
      case .ItemXAttack: return "ITEM_X_ATTACK"
      case .ItemXDefense: return "ITEM_X_DEFENSE"
      case .ItemXMiracle: return "ITEM_X_MIRACLE"
      case .ItemRazzBerry: return "ITEM_RAZZ_BERRY"
      case .ItemBlukBerry: return "ITEM_BLUK_BERRY"
      case .ItemNanabBerry: return "ITEM_NANAB_BERRY"
      case .ItemWeparBerry: return "ITEM_WEPAR_BERRY"
      case .ItemPinapBerry: return "ITEM_PINAP_BERRY"
      case .ItemSpecialCamera: return "ITEM_SPECIAL_CAMERA"
      case .ItemIncubatorBasicUnlimited: return "ITEM_INCUBATOR_BASIC_UNLIMITED"
      case .ItemIncubatorBasic: return "ITEM_INCUBATOR_BASIC"
      case .ItemPokemonStorageUpgrade: return "ITEM_POKEMON_STORAGE_UPGRADE"
      case .ItemItemStorageUpgrade: return "ITEM_ITEM_STORAGE_UPGRADE"
      }
    }
    public static func fromString(str:String) throws -> Pogoprotos.Inventory.Item.ItemId {
      switch str {
      case "ITEM_UNKNOWN":  return .ItemUnknown
      case "ITEM_POKE_BALL":  return .ItemPokeBall
      case "ITEM_GREAT_BALL":  return .ItemGreatBall
      case "ITEM_ULTRA_BALL":  return .ItemUltraBall
      case "ITEM_MASTER_BALL":  return .ItemMasterBall
      case "ITEM_POTION":  return .ItemPotion
      case "ITEM_SUPER_POTION":  return .ItemSuperPotion
      case "ITEM_HYPER_POTION":  return .ItemHyperPotion
      case "ITEM_MAX_POTION":  return .ItemMaxPotion
      case "ITEM_REVIVE":  return .ItemRevive
      case "ITEM_MAX_REVIVE":  return .ItemMaxRevive
      case "ITEM_LUCKY_EGG":  return .ItemLuckyEgg
      case "ITEM_INCENSE_ORDINARY":  return .ItemIncenseOrdinary
      case "ITEM_INCENSE_SPICY":  return .ItemIncenseSpicy
      case "ITEM_INCENSE_COOL":  return .ItemIncenseCool
      case "ITEM_INCENSE_FLORAL":  return .ItemIncenseFloral
      case "ITEM_TROY_DISK":  return .ItemTroyDisk
      case "ITEM_X_ATTACK":  return .ItemXAttack
      case "ITEM_X_DEFENSE":  return .ItemXDefense
      case "ITEM_X_MIRACLE":  return .ItemXMiracle
      case "ITEM_RAZZ_BERRY":  return .ItemRazzBerry
      case "ITEM_BLUK_BERRY":  return .ItemBlukBerry
      case "ITEM_NANAB_BERRY":  return .ItemNanabBerry
      case "ITEM_WEPAR_BERRY":  return .ItemWeparBerry
      case "ITEM_PINAP_BERRY":  return .ItemPinapBerry
      case "ITEM_SPECIAL_CAMERA":  return .ItemSpecialCamera
      case "ITEM_INCUBATOR_BASIC_UNLIMITED":  return .ItemIncubatorBasicUnlimited
      case "ITEM_INCUBATOR_BASIC":  return .ItemIncubatorBasic
      case "ITEM_POKEMON_STORAGE_UPGRADE":  return .ItemPokemonStorageUpgrade
      case "ITEM_ITEM_STORAGE_UPGRADE":  return .ItemItemStorageUpgrade
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
            case .ItemUnknown: return ".ItemUnknown"
            case .ItemPokeBall: return ".ItemPokeBall"
            case .ItemGreatBall: return ".ItemGreatBall"
            case .ItemUltraBall: return ".ItemUltraBall"
            case .ItemMasterBall: return ".ItemMasterBall"
            case .ItemPotion: return ".ItemPotion"
            case .ItemSuperPotion: return ".ItemSuperPotion"
            case .ItemHyperPotion: return ".ItemHyperPotion"
            case .ItemMaxPotion: return ".ItemMaxPotion"
            case .ItemRevive: return ".ItemRevive"
            case .ItemMaxRevive: return ".ItemMaxRevive"
            case .ItemLuckyEgg: return ".ItemLuckyEgg"
            case .ItemIncenseOrdinary: return ".ItemIncenseOrdinary"
            case .ItemIncenseSpicy: return ".ItemIncenseSpicy"
            case .ItemIncenseCool: return ".ItemIncenseCool"
            case .ItemIncenseFloral: return ".ItemIncenseFloral"
            case .ItemTroyDisk: return ".ItemTroyDisk"
            case .ItemXAttack: return ".ItemXAttack"
            case .ItemXDefense: return ".ItemXDefense"
            case .ItemXMiracle: return ".ItemXMiracle"
            case .ItemRazzBerry: return ".ItemRazzBerry"
            case .ItemBlukBerry: return ".ItemBlukBerry"
            case .ItemNanabBerry: return ".ItemNanabBerry"
            case .ItemWeparBerry: return ".ItemWeparBerry"
            case .ItemPinapBerry: return ".ItemPinapBerry"
            case .ItemSpecialCamera: return ".ItemSpecialCamera"
            case .ItemIncubatorBasicUnlimited: return ".ItemIncubatorBasicUnlimited"
            case .ItemIncubatorBasic: return ".ItemIncubatorBasic"
            case .ItemPokemonStorageUpgrade: return ".ItemPokemonStorageUpgrade"
            case .ItemItemStorageUpgrade: return ".ItemItemStorageUpgrade"
        }
    }
  }

  //Enum type declaration end 



  //Enum type declaration start 

  public enum ItemType:Int32, CustomDebugStringConvertible, CustomStringConvertible {
    case ItemTypeNone = 0
    case ItemTypePokeball = 1
    case ItemTypePotion = 2
    case ItemTypeRevive = 3
    case ItemTypeMap = 4
    case ItemTypeBattle = 5
    case ItemTypeFood = 6
    case ItemTypeCamera = 7
    case ItemTypeDisk = 8
    case ItemTypeIncubator = 9
    case ItemTypeIncense = 10
    case ItemTypeXpBoost = 11
    case ItemTypeInventoryUpgrade = 12
    public func toString() -> String {
      switch self {
      case .ItemTypeNone: return "ITEM_TYPE_NONE"
      case .ItemTypePokeball: return "ITEM_TYPE_POKEBALL"
      case .ItemTypePotion: return "ITEM_TYPE_POTION"
      case .ItemTypeRevive: return "ITEM_TYPE_REVIVE"
      case .ItemTypeMap: return "ITEM_TYPE_MAP"
      case .ItemTypeBattle: return "ITEM_TYPE_BATTLE"
      case .ItemTypeFood: return "ITEM_TYPE_FOOD"
      case .ItemTypeCamera: return "ITEM_TYPE_CAMERA"
      case .ItemTypeDisk: return "ITEM_TYPE_DISK"
      case .ItemTypeIncubator: return "ITEM_TYPE_INCUBATOR"
      case .ItemTypeIncense: return "ITEM_TYPE_INCENSE"
      case .ItemTypeXpBoost: return "ITEM_TYPE_XP_BOOST"
      case .ItemTypeInventoryUpgrade: return "ITEM_TYPE_INVENTORY_UPGRADE"
      }
    }
    public static func fromString(str:String) throws -> Pogoprotos.Inventory.Item.ItemType {
      switch str {
      case "ITEM_TYPE_NONE":  return .ItemTypeNone
      case "ITEM_TYPE_POKEBALL":  return .ItemTypePokeball
      case "ITEM_TYPE_POTION":  return .ItemTypePotion
      case "ITEM_TYPE_REVIVE":  return .ItemTypeRevive
      case "ITEM_TYPE_MAP":  return .ItemTypeMap
      case "ITEM_TYPE_BATTLE":  return .ItemTypeBattle
      case "ITEM_TYPE_FOOD":  return .ItemTypeFood
      case "ITEM_TYPE_CAMERA":  return .ItemTypeCamera
      case "ITEM_TYPE_DISK":  return .ItemTypeDisk
      case "ITEM_TYPE_INCUBATOR":  return .ItemTypeIncubator
      case "ITEM_TYPE_INCENSE":  return .ItemTypeIncense
      case "ITEM_TYPE_XP_BOOST":  return .ItemTypeXpBoost
      case "ITEM_TYPE_INVENTORY_UPGRADE":  return .ItemTypeInventoryUpgrade
      default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
      }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
            case .ItemTypeNone: return ".ItemTypeNone"
            case .ItemTypePokeball: return ".ItemTypePokeball"
            case .ItemTypePotion: return ".ItemTypePotion"
            case .ItemTypeRevive: return ".ItemTypeRevive"
            case .ItemTypeMap: return ".ItemTypeMap"
            case .ItemTypeBattle: return ".ItemTypeBattle"
            case .ItemTypeFood: return ".ItemTypeFood"
            case .ItemTypeCamera: return ".ItemTypeCamera"
            case .ItemTypeDisk: return ".ItemTypeDisk"
            case .ItemTypeIncubator: return ".ItemTypeIncubator"
            case .ItemTypeIncense: return ".ItemTypeIncense"
            case .ItemTypeXpBoost: return ".ItemTypeXpBoost"
            case .ItemTypeInventoryUpgrade: return ".ItemTypeInventoryUpgrade"
        }
    }
  }

  //Enum type declaration end 

  final public class ItemAward : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var itemId:Pogoprotos.Inventory.Item.ItemId = Pogoprotos.Inventory.Item.ItemId.ItemUnknown
    public private(set) var hasItemId:Bool = false
    public private(set) var hasItemCount:Bool = false
    public private(set) var itemCount:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasItemId {
        try output.writeEnum(1, value:itemId.rawValue)
      }
      if hasItemCount {
        try output.writeInt32(2, value:itemCount)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasItemId) {
        serialize_size += itemId.rawValue.computeEnumSize(1)
      }
      if hasItemCount {
        serialize_size += itemCount.computeInt32Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Inventory.Item.ItemAward> {
      var mergedArray = Array<Pogoprotos.Inventory.Item.ItemAward>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Inventory.Item.ItemAward? {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Inventory.Item.PogoprotosInventoryItemRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Inventory.Item.ItemAward.Builder {
      return Pogoprotos.Inventory.Item.ItemAward.classBuilder() as! Pogoprotos.Inventory.Item.ItemAward.Builder
    }
    public func getBuilder() -> Pogoprotos.Inventory.Item.ItemAward.Builder {
      return classBuilder() as! Pogoprotos.Inventory.Item.ItemAward.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Inventory.Item.ItemAward.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Inventory.Item.ItemAward.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
      return try Pogoprotos.Inventory.Item.ItemAward.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Inventory.Item.ItemAward) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasItemId {
        jsonMap["itemId"] = itemId.toString()
      }
      if hasItemCount {
        jsonMap["itemCount"] = NSNumber(int:itemCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemAward {
      return try Pogoprotos.Inventory.Item.ItemAward.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasItemId) {
        output += "\(indent) itemId: \(itemId.description)\n"
      }
      if hasItemCount {
        output += "\(indent) itemCount: \(itemCount) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasItemId {
               hashCode = (hashCode &* 31) &+ Int(itemId.rawValue)
            }
            if hasItemCount {
               hashCode = (hashCode &* 31) &+ itemCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Inventory.Item.ItemAward"
    }
    override public func className() -> String {
        return "Pogoprotos.Inventory.Item.ItemAward"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Inventory.Item.ItemAward.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Inventory.Item.ItemAward = Pogoprotos.Inventory.Item.ItemAward()
      public func getMessage() -> Pogoprotos.Inventory.Item.ItemAward {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasItemId:Bool{
            get {
                return builderResult.hasItemId
            }
        }
        public var itemId:Pogoprotos.Inventory.Item.ItemId {
            get {
                return builderResult.itemId
            }
            set (value) {
                builderResult.hasItemId = true
                builderResult.itemId = value
            }
        }
        public func setItemId(value:Pogoprotos.Inventory.Item.ItemId) -> Pogoprotos.Inventory.Item.ItemAward.Builder {
          self.itemId = value
          return self
        }
        public func clearItemId() -> Pogoprotos.Inventory.Item.ItemAward.Builder {
           builderResult.hasItemId = false
           builderResult.itemId = .ItemUnknown
           return self
        }
      public var hasItemCount:Bool {
           get {
                return builderResult.hasItemCount
           }
      }
      public var itemCount:Int32 {
           get {
                return builderResult.itemCount
           }
           set (value) {
               builderResult.hasItemCount = true
               builderResult.itemCount = value
           }
      }
      public func setItemCount(value:Int32) -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        self.itemCount = value
        return self
      }
      public func clearItemCount() -> Pogoprotos.Inventory.Item.ItemAward.Builder{
           builderResult.hasItemCount = false
           builderResult.itemCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        builderResult = Pogoprotos.Inventory.Item.ItemAward()
        return self
      }
      override public func clone() throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        return try Pogoprotos.Inventory.Item.ItemAward.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Inventory.Item.ItemAward {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Inventory.Item.ItemAward {
        let returnMe:Pogoprotos.Inventory.Item.ItemAward = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Inventory.Item.ItemAward) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        if other == Pogoprotos.Inventory.Item.ItemAward() {
         return self
        }
        if other.hasItemId {
             itemId = other.itemId
        }
        if other.hasItemCount {
             itemCount = other.itemCount
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntitemId = try input.readEnum()
            if let enumsitemId = Pogoprotos.Inventory.Item.ItemId(rawValue:valueIntitemId){
                 itemId = enumsitemId
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitemId))
            }

          case 16:
            itemCount = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        let resultDecodedBuilder = Pogoprotos.Inventory.Item.ItemAward.Builder()
        if let jsonValueItemId = jsonMap["itemId"] as? String {
          resultDecodedBuilder.itemId = try Pogoprotos.Inventory.Item.ItemId.fromString(jsonValueItemId)
        }
        if let jsonValueItemCount = jsonMap["itemCount"] as? NSNumber {
          resultDecodedBuilder.itemCount = jsonValueItemCount.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemAward.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class ItemData : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var itemId:Pogoprotos.Inventory.Item.ItemId = Pogoprotos.Inventory.Item.ItemId.ItemUnknown
    public private(set) var hasItemId:Bool = false
    public private(set) var hasCount:Bool = false
    public private(set) var count:Int32 = Int32(0)

    public private(set) var hasUnseen:Bool = false
    public private(set) var unseen:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasItemId {
        try output.writeEnum(1, value:itemId.rawValue)
      }
      if hasCount {
        try output.writeInt32(2, value:count)
      }
      if hasUnseen {
        try output.writeBool(3, value:unseen)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasItemId) {
        serialize_size += itemId.rawValue.computeEnumSize(1)
      }
      if hasCount {
        serialize_size += count.computeInt32Size(2)
      }
      if hasUnseen {
        serialize_size += unseen.computeBoolSize(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Inventory.Item.ItemData> {
      var mergedArray = Array<Pogoprotos.Inventory.Item.ItemData>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Inventory.Item.ItemData? {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Inventory.Item.PogoprotosInventoryItemRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Inventory.Item.ItemData.Builder {
      return Pogoprotos.Inventory.Item.ItemData.classBuilder() as! Pogoprotos.Inventory.Item.ItemData.Builder
    }
    public func getBuilder() -> Pogoprotos.Inventory.Item.ItemData.Builder {
      return classBuilder() as! Pogoprotos.Inventory.Item.ItemData.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Inventory.Item.ItemData.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Inventory.Item.ItemData.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
      return try Pogoprotos.Inventory.Item.ItemData.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Inventory.Item.ItemData) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
      return try Pogoprotos.Inventory.Item.ItemData.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasItemId {
        jsonMap["itemId"] = itemId.toString()
      }
      if hasCount {
        jsonMap["count"] = NSNumber(int:count)
      }
      if hasUnseen {
        jsonMap["unseen"] = unseen
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemData {
      return try Pogoprotos.Inventory.Item.ItemData.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasItemId) {
        output += "\(indent) itemId: \(itemId.description)\n"
      }
      if hasCount {
        output += "\(indent) count: \(count) \n"
      }
      if hasUnseen {
        output += "\(indent) unseen: \(unseen) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasItemId {
               hashCode = (hashCode &* 31) &+ Int(itemId.rawValue)
            }
            if hasCount {
               hashCode = (hashCode &* 31) &+ count.hashValue
            }
            if hasUnseen {
               hashCode = (hashCode &* 31) &+ unseen.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Inventory.Item.ItemData"
    }
    override public func className() -> String {
        return "Pogoprotos.Inventory.Item.ItemData"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Inventory.Item.ItemData.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Inventory.Item.ItemData = Pogoprotos.Inventory.Item.ItemData()
      public func getMessage() -> Pogoprotos.Inventory.Item.ItemData {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasItemId:Bool{
            get {
                return builderResult.hasItemId
            }
        }
        public var itemId:Pogoprotos.Inventory.Item.ItemId {
            get {
                return builderResult.itemId
            }
            set (value) {
                builderResult.hasItemId = true
                builderResult.itemId = value
            }
        }
        public func setItemId(value:Pogoprotos.Inventory.Item.ItemId) -> Pogoprotos.Inventory.Item.ItemData.Builder {
          self.itemId = value
          return self
        }
        public func clearItemId() -> Pogoprotos.Inventory.Item.ItemData.Builder {
           builderResult.hasItemId = false
           builderResult.itemId = .ItemUnknown
           return self
        }
      public var hasCount:Bool {
           get {
                return builderResult.hasCount
           }
      }
      public var count:Int32 {
           get {
                return builderResult.count
           }
           set (value) {
               builderResult.hasCount = true
               builderResult.count = value
           }
      }
      public func setCount(value:Int32) -> Pogoprotos.Inventory.Item.ItemData.Builder {
        self.count = value
        return self
      }
      public func clearCount() -> Pogoprotos.Inventory.Item.ItemData.Builder{
           builderResult.hasCount = false
           builderResult.count = Int32(0)
           return self
      }
      public var hasUnseen:Bool {
           get {
                return builderResult.hasUnseen
           }
      }
      public var unseen:Bool {
           get {
                return builderResult.unseen
           }
           set (value) {
               builderResult.hasUnseen = true
               builderResult.unseen = value
           }
      }
      public func setUnseen(value:Bool) -> Pogoprotos.Inventory.Item.ItemData.Builder {
        self.unseen = value
        return self
      }
      public func clearUnseen() -> Pogoprotos.Inventory.Item.ItemData.Builder{
           builderResult.hasUnseen = false
           builderResult.unseen = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Inventory.Item.ItemData.Builder {
        builderResult = Pogoprotos.Inventory.Item.ItemData()
        return self
      }
      override public func clone() throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
        return try Pogoprotos.Inventory.Item.ItemData.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Inventory.Item.ItemData {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Inventory.Item.ItemData {
        let returnMe:Pogoprotos.Inventory.Item.ItemData = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Inventory.Item.ItemData) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
        if other == Pogoprotos.Inventory.Item.ItemData() {
         return self
        }
        if other.hasItemId {
             itemId = other.itemId
        }
        if other.hasCount {
             count = other.count
        }
        if other.hasUnseen {
             unseen = other.unseen
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntitemId = try input.readEnum()
            if let enumsitemId = Pogoprotos.Inventory.Item.ItemId(rawValue:valueIntitemId){
                 itemId = enumsitemId
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntitemId))
            }

          case 16:
            count = try input.readInt32()

          case 24:
            unseen = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
        let resultDecodedBuilder = Pogoprotos.Inventory.Item.ItemData.Builder()
        if let jsonValueItemId = jsonMap["itemId"] as? String {
          resultDecodedBuilder.itemId = try Pogoprotos.Inventory.Item.ItemId.fromString(jsonValueItemId)
        }
        if let jsonValueCount = jsonMap["count"] as? NSNumber {
          resultDecodedBuilder.count = jsonValueCount.intValue
        }
        if let jsonValueUnseen = jsonMap["unseen"] as? Bool {
          resultDecodedBuilder.unseen = jsonValueUnseen
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Inventory.Item.ItemData.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Inventory.Item.ItemData.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
