// Generated by the Protocol Buffers 3.0 compiler.  DO NOT EDIT!
// Source file "POGOProtos.Networking.Responses.proto"
// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public func == (lhs: Pogoprotos.Networking.Responses.AddFortModifierResponse, rhs: Pogoprotos.Networking.Responses.AddFortModifierResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.AttackGymResponse, rhs: Pogoprotos.Networking.Responses.AttackGymResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasBattleLog == rhs.hasBattleLog) && (!lhs.hasBattleLog || lhs.battleLog == rhs.battleLog)
  fieldCheck = fieldCheck && (lhs.hasBattleId == rhs.hasBattleId) && (!lhs.hasBattleId || lhs.battleId == rhs.battleId)
  fieldCheck = fieldCheck && (lhs.hasActiveDefender == rhs.hasActiveDefender) && (!lhs.hasActiveDefender || lhs.activeDefender == rhs.activeDefender)
  fieldCheck = fieldCheck && (lhs.hasActiveAttacker == rhs.hasActiveAttacker) && (!lhs.hasActiveAttacker || lhs.activeAttacker == rhs.activeAttacker)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.CatchPokemonResponse, rhs: Pogoprotos.Networking.Responses.CatchPokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasMissPercent == rhs.hasMissPercent) && (!lhs.hasMissPercent || lhs.missPercent == rhs.missPercent)
  fieldCheck = fieldCheck && (lhs.hasCapturedPokemonId == rhs.hasCapturedPokemonId) && (!lhs.hasCapturedPokemonId || lhs.capturedPokemonId == rhs.capturedPokemonId)
  fieldCheck = fieldCheck && (lhs.hasCaptureAward == rhs.hasCaptureAward) && (!lhs.hasCaptureAward || lhs.captureAward == rhs.captureAward)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse, rhs: Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.awardedBadges == rhs.awardedBadges)
  fieldCheck = fieldCheck && (lhs.awardedBadgeLevels == rhs.awardedBadgeLevels)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse, rhs: Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCodename == rhs.hasCodename) && (!lhs.hasCodename || lhs.codename == rhs.codename)
  fieldCheck = fieldCheck && (lhs.hasUserMessage == rhs.hasUserMessage) && (!lhs.hasUserMessage || lhs.userMessage == rhs.userMessage)
  fieldCheck = fieldCheck && (lhs.hasIsAssignable == rhs.hasIsAssignable) && (!lhs.hasIsAssignable || lhs.isAssignable == rhs.isAssignable)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.ClaimCodenameResponse, rhs: Pogoprotos.Networking.Responses.ClaimCodenameResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCodename == rhs.hasCodename) && (!lhs.hasCodename || lhs.codename == rhs.codename)
  fieldCheck = fieldCheck && (lhs.hasUserMessage == rhs.hasUserMessage) && (!lhs.hasUserMessage || lhs.userMessage == rhs.userMessage)
  fieldCheck = fieldCheck && (lhs.hasIsAssignable == rhs.hasIsAssignable) && (!lhs.hasIsAssignable || lhs.isAssignable == rhs.isAssignable)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.CollectDailyBonusResponse, rhs: Pogoprotos.Networking.Responses.CollectDailyBonusResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse, rhs: Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.currencyType == rhs.currencyType)
  fieldCheck = fieldCheck && (lhs.currencyAwarded == rhs.currencyAwarded)
  fieldCheck = fieldCheck && (lhs.hasDefendersCount == rhs.hasDefendersCount) && (!lhs.hasDefendersCount || lhs.defendersCount == rhs.defendersCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.DiskEncounterResponse, rhs: Pogoprotos.Networking.Responses.DiskEncounterResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse, rhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.itemTemplates == rhs.itemTemplates)
  fieldCheck = fieldCheck && (lhs.hasTimestampMs == rhs.hasTimestampMs) && (!lhs.hasTimestampMs || lhs.timestampMs == rhs.timestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate, rhs: Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasTemplateId == rhs.hasTemplateId) && (!lhs.hasTemplateId || lhs.templateId == rhs.templateId)
  fieldCheck = fieldCheck && (lhs.hasPokemonSettings == rhs.hasPokemonSettings) && (!lhs.hasPokemonSettings || lhs.pokemonSettings == rhs.pokemonSettings)
  fieldCheck = fieldCheck && (lhs.hasItemSettings == rhs.hasItemSettings) && (!lhs.hasItemSettings || lhs.itemSettings == rhs.itemSettings)
  fieldCheck = fieldCheck && (lhs.hasMoveSettings == rhs.hasMoveSettings) && (!lhs.hasMoveSettings || lhs.moveSettings == rhs.moveSettings)
  fieldCheck = fieldCheck && (lhs.hasMoveSequenceSettings == rhs.hasMoveSequenceSettings) && (!lhs.hasMoveSequenceSettings || lhs.moveSequenceSettings == rhs.moveSequenceSettings)
  fieldCheck = fieldCheck && (lhs.hasTypeEffective == rhs.hasTypeEffective) && (!lhs.hasTypeEffective || lhs.typeEffective == rhs.typeEffective)
  fieldCheck = fieldCheck && (lhs.hasBadgeSettings == rhs.hasBadgeSettings) && (!lhs.hasBadgeSettings || lhs.badgeSettings == rhs.badgeSettings)
  fieldCheck = fieldCheck && (lhs.hasCamera == rhs.hasCamera) && (!lhs.hasCamera || lhs.camera == rhs.camera)
  fieldCheck = fieldCheck && (lhs.hasPlayerLevel == rhs.hasPlayerLevel) && (!lhs.hasPlayerLevel || lhs.playerLevel == rhs.playerLevel)
  fieldCheck = fieldCheck && (lhs.hasGymLevel == rhs.hasGymLevel) && (!lhs.hasGymLevel || lhs.gymLevel == rhs.gymLevel)
  fieldCheck = fieldCheck && (lhs.hasBattleSettings == rhs.hasBattleSettings) && (!lhs.hasBattleSettings || lhs.battleSettings == rhs.battleSettings)
  fieldCheck = fieldCheck && (lhs.hasEncounterSettings == rhs.hasEncounterSettings) && (!lhs.hasEncounterSettings || lhs.encounterSettings == rhs.encounterSettings)
  fieldCheck = fieldCheck && (lhs.hasIapItemDisplay == rhs.hasIapItemDisplay) && (!lhs.hasIapItemDisplay || lhs.iapItemDisplay == rhs.iapItemDisplay)
  fieldCheck = fieldCheck && (lhs.hasIapSettings == rhs.hasIapSettings) && (!lhs.hasIapSettings || lhs.iapSettings == rhs.iapSettings)
  fieldCheck = fieldCheck && (lhs.hasPokemonUpgrades == rhs.hasPokemonUpgrades) && (!lhs.hasPokemonUpgrades || lhs.pokemonUpgrades == rhs.pokemonUpgrades)
  fieldCheck = fieldCheck && (lhs.hasEquippedBadges == rhs.hasEquippedBadges) && (!lhs.hasEquippedBadges || lhs.equippedBadges == rhs.equippedBadges)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse, rhs: Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasItemTemplatesTimestampMs == rhs.hasItemTemplatesTimestampMs) && (!lhs.hasItemTemplatesTimestampMs || lhs.itemTemplatesTimestampMs == rhs.itemTemplatesTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasAssetDigestTimestampMs == rhs.hasAssetDigestTimestampMs) && (!lhs.hasAssetDigestTimestampMs || lhs.assetDigestTimestampMs == rhs.assetDigestTimestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.DownloadSettingsResponse, rhs: Pogoprotos.Networking.Responses.DownloadSettingsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = fieldCheck && (lhs.hasHash == rhs.hasHash) && (!lhs.hasHash || lhs.hash == rhs.hash)
  fieldCheck = fieldCheck && (lhs.hasSettings == rhs.hasSettings) && (!lhs.hasSettings || lhs.settings == rhs.settings)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.EchoResponse, rhs: Pogoprotos.Networking.Responses.EchoResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasContext == rhs.hasContext) && (!lhs.hasContext || lhs.context == rhs.context)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.EncounterResponse, rhs: Pogoprotos.Networking.Responses.EncounterResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasWildPokemon == rhs.hasWildPokemon) && (!lhs.hasWildPokemon || lhs.wildPokemon == rhs.wildPokemon)
  fieldCheck = fieldCheck && (lhs.hasBackground == rhs.hasBackground) && (!lhs.hasBackground || lhs.background == rhs.background)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse, rhs: Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasCaptureAward == rhs.hasCaptureAward) && (!lhs.hasCaptureAward || lhs.captureAward == rhs.captureAward)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.EquipBadgeResponse, rhs: Pogoprotos.Networking.Responses.EquipBadgeResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasEquipped == rhs.hasEquipped) && (!lhs.hasEquipped || lhs.equipped == rhs.equipped)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.EvolvePokemonResponse, rhs: Pogoprotos.Networking.Responses.EvolvePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasEvolvedPokemonData == rhs.hasEvolvedPokemonData) && (!lhs.hasEvolvedPokemonData || lhs.evolvedPokemonData == rhs.evolvedPokemonData)
  fieldCheck = fieldCheck && (lhs.hasExperienceAwarded == rhs.hasExperienceAwarded) && (!lhs.hasExperienceAwarded || lhs.experienceAwarded == rhs.experienceAwarded)
  fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.FortDeployPokemonResponse, rhs: Pogoprotos.Networking.Responses.FortDeployPokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasFortDetails == rhs.hasFortDetails) && (!lhs.hasFortDetails || lhs.fortDetails == rhs.fortDetails)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasGymState == rhs.hasGymState) && (!lhs.hasGymState || lhs.gymState == rhs.gymState)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.FortDetailsResponse, rhs: Pogoprotos.Networking.Responses.FortDetailsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasFortId == rhs.hasFortId) && (!lhs.hasFortId || lhs.fortId == rhs.fortId)
  fieldCheck = fieldCheck && (lhs.hasTeamColor == rhs.hasTeamColor) && (!lhs.hasTeamColor || lhs.teamColor == rhs.teamColor)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.imageUrls == rhs.imageUrls)
  fieldCheck = fieldCheck && (lhs.hasFp == rhs.hasFp) && (!lhs.hasFp || lhs.fp == rhs.fp)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = fieldCheck && (lhs.hasMaxStamina == rhs.hasMaxStamina) && (!lhs.hasMaxStamina || lhs.maxStamina == rhs.maxStamina)
  fieldCheck = fieldCheck && (lhs.hasTypes == rhs.hasTypes) && (!lhs.hasTypes || lhs.types == rhs.types)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = fieldCheck && (lhs.modifiers == rhs.modifiers)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.FortRecallPokemonResponse, rhs: Pogoprotos.Networking.Responses.FortRecallPokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasFortDetails == rhs.hasFortDetails) && (!lhs.hasFortDetails || lhs.fortDetails == rhs.fortDetails)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.FortSearchResponse, rhs: Pogoprotos.Networking.Responses.FortSearchResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.itemsAwarded == rhs.itemsAwarded)
  fieldCheck = fieldCheck && (lhs.hasGemsAwarded == rhs.hasGemsAwarded) && (!lhs.hasGemsAwarded || lhs.gemsAwarded == rhs.gemsAwarded)
  fieldCheck = fieldCheck && (lhs.hasPokemonDataEgg == rhs.hasPokemonDataEgg) && (!lhs.hasPokemonDataEgg || lhs.pokemonDataEgg == rhs.pokemonDataEgg)
  fieldCheck = fieldCheck && (lhs.hasExperienceAwarded == rhs.hasExperienceAwarded) && (!lhs.hasExperienceAwarded || lhs.experienceAwarded == rhs.experienceAwarded)
  fieldCheck = fieldCheck && (lhs.hasCooldownCompleteTimestampMs == rhs.hasCooldownCompleteTimestampMs) && (!lhs.hasCooldownCompleteTimestampMs || lhs.cooldownCompleteTimestampMs == rhs.cooldownCompleteTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasChainHackSequenceNumber == rhs.hasChainHackSequenceNumber) && (!lhs.hasChainHackSequenceNumber || lhs.chainHackSequenceNumber == rhs.chainHackSequenceNumber)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetAssetDigestResponse, rhs: Pogoprotos.Networking.Responses.GetAssetDigestResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.digest == rhs.digest)
  fieldCheck = fieldCheck && (lhs.hasTimestampMs == rhs.hasTimestampMs) && (!lhs.hasTimestampMs || lhs.timestampMs == rhs.timestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetDownloadUrlsResponse, rhs: Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.downloadUrls == rhs.downloadUrls)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetGymDetailsResponse, rhs: Pogoprotos.Networking.Responses.GetGymDetailsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasGymState == rhs.hasGymState) && (!lhs.hasGymState || lhs.gymState == rhs.gymState)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.urls == rhs.urls)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetHatchedEggsResponse, rhs: Pogoprotos.Networking.Responses.GetHatchedEggsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.pokemonId == rhs.pokemonId)
  fieldCheck = fieldCheck && (lhs.experienceAwarded == rhs.experienceAwarded)
  fieldCheck = fieldCheck && (lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = fieldCheck && (lhs.stardustAwarded == rhs.stardustAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetIncensePokemonResponse, rhs: Pogoprotos.Networking.Responses.GetIncensePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasPokemonTypeId == rhs.hasPokemonTypeId) && (!lhs.hasPokemonTypeId || lhs.pokemonTypeId == rhs.pokemonTypeId)
  fieldCheck = fieldCheck && (lhs.hasLatitude == rhs.hasLatitude) && (!lhs.hasLatitude || lhs.latitude == rhs.latitude)
  fieldCheck = fieldCheck && (lhs.hasLongitude == rhs.hasLongitude) && (!lhs.hasLongitude || lhs.longitude == rhs.longitude)
  fieldCheck = fieldCheck && (lhs.hasEncounterLocation == rhs.hasEncounterLocation) && (!lhs.hasEncounterLocation || lhs.encounterLocation == rhs.encounterLocation)
  fieldCheck = fieldCheck && (lhs.hasEncounterId == rhs.hasEncounterId) && (!lhs.hasEncounterId || lhs.encounterId == rhs.encounterId)
  fieldCheck = fieldCheck && (lhs.hasDisappearTimestampMs == rhs.hasDisappearTimestampMs) && (!lhs.hasDisappearTimestampMs || lhs.disappearTimestampMs == rhs.disappearTimestampMs)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetInventoryResponse, rhs: Pogoprotos.Networking.Responses.GetInventoryResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasInventoryDelta == rhs.hasInventoryDelta) && (!lhs.hasInventoryDelta || lhs.inventoryDelta == rhs.inventoryDelta)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetMapObjectsResponse, rhs: Pogoprotos.Networking.Responses.GetMapObjectsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.mapCells == rhs.mapCells)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetPlayerProfileResponse, rhs: Pogoprotos.Networking.Responses.GetPlayerProfileResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
  fieldCheck = fieldCheck && (lhs.badges == rhs.badges)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetPlayerResponse, rhs: Pogoprotos.Networking.Responses.GetPlayerResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse, rhs: Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.codenames == rhs.codenames)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.IncenseEncounterResponse, rhs: Pogoprotos.Networking.Responses.IncenseEncounterResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasPokemonData == rhs.hasPokemonData) && (!lhs.hasPokemonData || lhs.pokemonData == rhs.pokemonData)
  fieldCheck = fieldCheck && (lhs.hasCaptureProbability == rhs.hasCaptureProbability) && (!lhs.hasCaptureProbability || lhs.captureProbability == rhs.captureProbability)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.LevelUpRewardsResponse, rhs: Pogoprotos.Networking.Responses.LevelUpRewardsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.itemsAwarded == rhs.itemsAwarded)
  fieldCheck = fieldCheck && (lhs.itemsUnlocked == rhs.itemsUnlocked)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse, rhs: Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.NicknamePokemonResponse, rhs: Pogoprotos.Networking.Responses.NicknamePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.PlayerUpdateResponse, rhs: Pogoprotos.Networking.Responses.PlayerUpdateResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.wildPokemons == rhs.wildPokemons)
  fieldCheck = fieldCheck && (lhs.forts == rhs.forts)
  fieldCheck = fieldCheck && (lhs.hasFortsNearby == rhs.hasFortsNearby) && (!lhs.hasFortsNearby || lhs.fortsNearby == rhs.fortsNearby)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.RecycleInventoryItemResponse, rhs: Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasNewCount == rhs.hasNewCount) && (!lhs.hasNewCount || lhs.newCount == rhs.newCount)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.ReleasePokemonResponse, rhs: Pogoprotos.Networking.Responses.ReleasePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasCandyAwarded == rhs.hasCandyAwarded) && (!lhs.hasCandyAwarded || lhs.candyAwarded == rhs.candyAwarded)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.SetAvatarResponse, rhs: Pogoprotos.Networking.Responses.SetAvatarResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.SetContactSettingsResponse, rhs: Pogoprotos.Networking.Responses.SetContactSettingsResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.SetFavoritePokemonResponse, rhs: Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.SetPlayerTeamResponse, rhs: Pogoprotos.Networking.Responses.SetPlayerTeamResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasPlayerData == rhs.hasPlayerData) && (!lhs.hasPlayerData || lhs.playerData == rhs.playerData)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.SfidaActionLogResponse, rhs: Pogoprotos.Networking.Responses.SfidaActionLogResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.logEntries == rhs.logEntries)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.StartGymBattleResponse, rhs: Pogoprotos.Networking.Responses.StartGymBattleResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasBattleStartTimestampMs == rhs.hasBattleStartTimestampMs) && (!lhs.hasBattleStartTimestampMs || lhs.battleStartTimestampMs == rhs.battleStartTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasBattleEndTimestampMs == rhs.hasBattleEndTimestampMs) && (!lhs.hasBattleEndTimestampMs || lhs.battleEndTimestampMs == rhs.battleEndTimestampMs)
  fieldCheck = fieldCheck && (lhs.hasBattleId == rhs.hasBattleId) && (!lhs.hasBattleId || lhs.battleId == rhs.battleId)
  fieldCheck = fieldCheck && (lhs.hasDefender == rhs.hasDefender) && (!lhs.hasDefender || lhs.defender == rhs.defender)
  fieldCheck = fieldCheck && (lhs.hasBattleLog == rhs.hasBattleLog) && (!lhs.hasBattleLog || lhs.battleLog == rhs.battleLog)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UpgradePokemonResponse, rhs: Pogoprotos.Networking.Responses.UpgradePokemonResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasUpgradedPokemon == rhs.hasUpgradedPokemon) && (!lhs.hasUpgradedPokemon || lhs.upgradedPokemon == rhs.upgradedPokemon)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseIncenseResponse, rhs: Pogoprotos.Networking.Responses.UseIncenseResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasAppliedIncense == rhs.hasAppliedIncense) && (!lhs.hasAppliedIncense || lhs.appliedIncense == rhs.appliedIncense)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse, rhs: Pogoprotos.Networking.Responses.UseItemCaptureResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.hasItemCaptureMult == rhs.hasItemCaptureMult) && (!lhs.hasItemCaptureMult || lhs.itemCaptureMult == rhs.itemCaptureMult)
  fieldCheck = fieldCheck && (lhs.hasItemFleeMult == rhs.hasItemFleeMult) && (!lhs.hasItemFleeMult || lhs.itemFleeMult == rhs.itemFleeMult)
  fieldCheck = fieldCheck && (lhs.hasStopMovement == rhs.hasStopMovement) && (!lhs.hasStopMovement || lhs.stopMovement == rhs.stopMovement)
  fieldCheck = fieldCheck && (lhs.hasStopAttack == rhs.hasStopAttack) && (!lhs.hasStopAttack || lhs.stopAttack == rhs.stopAttack)
  fieldCheck = fieldCheck && (lhs.hasTargetMax == rhs.hasTargetMax) && (!lhs.hasTargetMax || lhs.targetMax == rhs.targetMax)
  fieldCheck = fieldCheck && (lhs.hasTargetSlow == rhs.hasTargetSlow) && (!lhs.hasTargetSlow || lhs.targetSlow == rhs.targetSlow)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse, rhs: Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasEggIncubator == rhs.hasEggIncubator) && (!lhs.hasEggIncubator || lhs.eggIncubator == rhs.eggIncubator)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemGymResponse, rhs: Pogoprotos.Networking.Responses.UseItemGymResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasUpdatedGp == rhs.hasUpdatedGp) && (!lhs.hasUpdatedGp || lhs.updatedGp == rhs.updatedGp)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemPotionResponse, rhs: Pogoprotos.Networking.Responses.UseItemPotionResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemReviveResponse, rhs: Pogoprotos.Networking.Responses.UseItemReviveResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasStamina == rhs.hasStamina) && (!lhs.hasStamina || lhs.stamina == rhs.stamina)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Pogoprotos.Networking.Responses.UseItemXpBoostResponse, rhs: Pogoprotos.Networking.Responses.UseItemXpBoostResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && (lhs.hasAppliedItems == rhs.hasAppliedItems) && (!lhs.hasAppliedItems || lhs.appliedItems == rhs.appliedItems)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Pogoprotos.Networking.Responses {
  public struct PogoprotosNetworkingResponsesRoot {
    public static var sharedInstance : PogoprotosNetworkingResponsesRoot {
     struct Static {
         static let instance : PogoprotosNetworkingResponsesRoot = PogoprotosNetworkingResponsesRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Battle.PogoprotosDataBattleRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Capture.PogoprotosDataCaptureRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Enums.PogoprotosEnumsRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.PogoprotosDataRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Settings.Master.PogoprotosSettingsMasterRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Settings.PogoprotosSettingsRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Map.Pokemon.PogoprotosMapPokemonRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Player.PogoprotosDataPlayerRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Gym.PogoprotosDataGymRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Map.Fort.PogoprotosMapFortRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Inventory.Item.PogoprotosInventoryItemRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Inventory.PogoprotosInventoryRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Map.PogoprotosMapRoot.sharedInstance.registerAllExtensions(extensionRegistry)
      Pogoprotos.Data.Logs.PogoprotosDataLogsRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  // Initialized by assist.py
  final public class AddFortModifierResponse : GeneratedMessage, GeneratedMessageProtocol {
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.AddFortModifierResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.AddFortModifierResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse? {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.classBuilder() as! Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.AddFortModifierResponse) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      let jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
      return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.AddFortModifierResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.AddFortModifierResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.AddFortModifierResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.AddFortModifierResponse = Pogoprotos.Networking.Responses.AddFortModifierResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.AddFortModifierResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        return try Pogoprotos.Networking.Responses.AddFortModifierResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.AddFortModifierResponse {
        let returnMe:Pogoprotos.Networking.Responses.AddFortModifierResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.AddFortModifierResponse) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        if other == Pogoprotos.Networking.Responses.AddFortModifierResponse() {
         return self
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder()
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.AddFortModifierResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class AttackGymResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorInvalidAttackActions = 2
        case ErrorNotInRange = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorInvalidAttackActions: return "ERROR_INVALID_ATTACK_ACTIONS"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_INVALID_ATTACK_ACTIONS":  return .ErrorInvalidAttackActions
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorInvalidAttackActions: return ".ErrorInvalidAttackActions"
                case .ErrorNotInRange: return ".ErrorNotInRange"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.AttackGymResponse.Result = Pogoprotos.Networking.Responses.AttackGymResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasBattleLog:Bool = false
    public private(set) var battleLog:Pogoprotos.Data.Battle.BattleLog!
    public private(set) var hasBattleId:Bool = false
    public private(set) var battleId:String = ""

    public private(set) var hasActiveDefender:Bool = false
    public private(set) var activeDefender:Pogoprotos.Data.Battle.BattlePokemonInfo!
    public private(set) var hasActiveAttacker:Bool = false
    public private(set) var activeAttacker:Pogoprotos.Data.Battle.BattlePokemonInfo!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasBattleLog {
        try output.writeMessage(2, value:battleLog)
      }
      if hasBattleId {
        try output.writeString(3, value:battleId)
      }
      if hasActiveDefender {
        try output.writeMessage(4, value:activeDefender)
      }
      if hasActiveAttacker {
        try output.writeMessage(5, value:activeAttacker)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasBattleLog {
          if let varSizebattleLog = battleLog?.computeMessageSize(2) {
              serialize_size += varSizebattleLog
          }
      }
      if hasBattleId {
        serialize_size += battleId.computeStringSize(3)
      }
      if hasActiveDefender {
          if let varSizeactiveDefender = activeDefender?.computeMessageSize(4) {
              serialize_size += varSizeactiveDefender
          }
      }
      if hasActiveAttacker {
          if let varSizeactiveAttacker = activeAttacker?.computeMessageSize(5) {
              serialize_size += varSizeactiveAttacker
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.AttackGymResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.AttackGymResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse? {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.classBuilder() as! Pogoprotos.Networking.Responses.AttackGymResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.AttackGymResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.AttackGymResponse) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasBattleLog {
        jsonMap["battleLog"] = try battleLog.encode()
      }
      if hasBattleId {
        jsonMap["battleId"] = battleId
      }
      if hasActiveDefender {
        jsonMap["activeDefender"] = try activeDefender.encode()
      }
      if hasActiveAttacker {
        jsonMap["activeAttacker"] = try activeAttacker.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
      return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasBattleLog {
        output += "\(indent) battleLog {\n"
        if let outDescBattleLog = battleLog {
          output += try outDescBattleLog.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasBattleId {
        output += "\(indent) battleId: \(battleId) \n"
      }
      if hasActiveDefender {
        output += "\(indent) activeDefender {\n"
        if let outDescActiveDefender = activeDefender {
          output += try outDescActiveDefender.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasActiveAttacker {
        output += "\(indent) activeAttacker {\n"
        if let outDescActiveAttacker = activeAttacker {
          output += try outDescActiveAttacker.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasBattleLog {
                if let hashValuebattleLog = battleLog?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebattleLog
                }
            }
            if hasBattleId {
               hashCode = (hashCode &* 31) &+ battleId.hashValue
            }
            if hasActiveDefender {
                if let hashValueactiveDefender = activeDefender?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueactiveDefender
                }
            }
            if hasActiveAttacker {
                if let hashValueactiveAttacker = activeAttacker?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueactiveAttacker
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.AttackGymResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.AttackGymResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.AttackGymResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.AttackGymResponse = Pogoprotos.Networking.Responses.AttackGymResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.AttackGymResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.AttackGymResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.AttackGymResponse.Result) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasBattleLog:Bool {
           get {
               return builderResult.hasBattleLog
           }
      }
      public var battleLog:Pogoprotos.Data.Battle.BattleLog! {
           get {
               if battleLogBuilder_ != nil {
                  builderResult.battleLog = battleLogBuilder_.getMessage()
               }
               return builderResult.battleLog
           }
           set (value) {
               builderResult.hasBattleLog = true
               builderResult.battleLog = value
           }
      }
      private var battleLogBuilder_:Pogoprotos.Data.Battle.BattleLog.Builder! {
           didSet {
              builderResult.hasBattleLog = true
           }
      }
      public func getBattleLogBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        if battleLogBuilder_ == nil {
           battleLogBuilder_ = Pogoprotos.Data.Battle.BattleLog.Builder()
           builderResult.battleLog = battleLogBuilder_.getMessage()
           if battleLog != nil {
              try! battleLogBuilder_.mergeFrom(battleLog)
           }
        }
        return battleLogBuilder_
      }
      public func setBattleLog(value:Pogoprotos.Data.Battle.BattleLog!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.battleLog = value
        return self
      }
      public func mergeBattleLog(value:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasBattleLog {
          builderResult.battleLog = try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(builderResult.battleLog).mergeFrom(value).buildPartial()
        } else {
          builderResult.battleLog = value
        }
        builderResult.hasBattleLog = true
        return self
      }
      public func clearBattleLog() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        battleLogBuilder_ = nil
        builderResult.hasBattleLog = false
        builderResult.battleLog = nil
        return self
      }
      public var hasBattleId:Bool {
           get {
                return builderResult.hasBattleId
           }
      }
      public var battleId:String {
           get {
                return builderResult.battleId
           }
           set (value) {
               builderResult.hasBattleId = true
               builderResult.battleId = value
           }
      }
      public func setBattleId(value:String) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.battleId = value
        return self
      }
      public func clearBattleId() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder{
           builderResult.hasBattleId = false
           builderResult.battleId = ""
           return self
      }
      public var hasActiveDefender:Bool {
           get {
               return builderResult.hasActiveDefender
           }
      }
      public var activeDefender:Pogoprotos.Data.Battle.BattlePokemonInfo! {
           get {
               if activeDefenderBuilder_ != nil {
                  builderResult.activeDefender = activeDefenderBuilder_.getMessage()
               }
               return builderResult.activeDefender
           }
           set (value) {
               builderResult.hasActiveDefender = true
               builderResult.activeDefender = value
           }
      }
      private var activeDefenderBuilder_:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder! {
           didSet {
              builderResult.hasActiveDefender = true
           }
      }
      public func getActiveDefenderBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if activeDefenderBuilder_ == nil {
           activeDefenderBuilder_ = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
           builderResult.activeDefender = activeDefenderBuilder_.getMessage()
           if activeDefender != nil {
              try! activeDefenderBuilder_.mergeFrom(activeDefender)
           }
        }
        return activeDefenderBuilder_
      }
      public func setActiveDefender(value:Pogoprotos.Data.Battle.BattlePokemonInfo!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.activeDefender = value
        return self
      }
      public func mergeActiveDefender(value:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasActiveDefender {
          builderResult.activeDefender = try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(builderResult.activeDefender).mergeFrom(value).buildPartial()
        } else {
          builderResult.activeDefender = value
        }
        builderResult.hasActiveDefender = true
        return self
      }
      public func clearActiveDefender() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        activeDefenderBuilder_ = nil
        builderResult.hasActiveDefender = false
        builderResult.activeDefender = nil
        return self
      }
      public var hasActiveAttacker:Bool {
           get {
               return builderResult.hasActiveAttacker
           }
      }
      public var activeAttacker:Pogoprotos.Data.Battle.BattlePokemonInfo! {
           get {
               if activeAttackerBuilder_ != nil {
                  builderResult.activeAttacker = activeAttackerBuilder_.getMessage()
               }
               return builderResult.activeAttacker
           }
           set (value) {
               builderResult.hasActiveAttacker = true
               builderResult.activeAttacker = value
           }
      }
      private var activeAttackerBuilder_:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder! {
           didSet {
              builderResult.hasActiveAttacker = true
           }
      }
      public func getActiveAttackerBuilder() -> Pogoprotos.Data.Battle.BattlePokemonInfo.Builder {
        if activeAttackerBuilder_ == nil {
           activeAttackerBuilder_ = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
           builderResult.activeAttacker = activeAttackerBuilder_.getMessage()
           if activeAttacker != nil {
              try! activeAttackerBuilder_.mergeFrom(activeAttacker)
           }
        }
        return activeAttackerBuilder_
      }
      public func setActiveAttacker(value:Pogoprotos.Data.Battle.BattlePokemonInfo!) -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        self.activeAttacker = value
        return self
      }
      public func mergeActiveAttacker(value:Pogoprotos.Data.Battle.BattlePokemonInfo) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if builderResult.hasActiveAttacker {
          builderResult.activeAttacker = try Pogoprotos.Data.Battle.BattlePokemonInfo.builderWithPrototype(builderResult.activeAttacker).mergeFrom(value).buildPartial()
        } else {
          builderResult.activeAttacker = value
        }
        builderResult.hasActiveAttacker = true
        return self
      }
      public func clearActiveAttacker() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        activeAttackerBuilder_ = nil
        builderResult.hasActiveAttacker = false
        builderResult.activeAttacker = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.AttackGymResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        return try Pogoprotos.Networking.Responses.AttackGymResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.AttackGymResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.AttackGymResponse {
        let returnMe:Pogoprotos.Networking.Responses.AttackGymResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.AttackGymResponse) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        if other == Pogoprotos.Networking.Responses.AttackGymResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasBattleLog) {
            try mergeBattleLog(other.battleLog)
        }
        if other.hasBattleId {
             battleId = other.battleId
        }
        if (other.hasActiveDefender) {
            try mergeActiveDefender(other.activeDefender)
        }
        if (other.hasActiveAttacker) {
            try mergeActiveAttacker(other.activeAttacker)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.AttackGymResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.Battle.BattleLog.Builder = Pogoprotos.Data.Battle.BattleLog.Builder()
            if hasBattleLog {
              try subBuilder.mergeFrom(battleLog)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            battleLog = subBuilder.buildPartial()

          case 26:
            battleId = try input.readString()

          case 34:
            let subBuilder:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            if hasActiveDefender {
              try subBuilder.mergeFrom(activeDefender)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            activeDefender = subBuilder.buildPartial()

          case 42:
            let subBuilder:Pogoprotos.Data.Battle.BattlePokemonInfo.Builder = Pogoprotos.Data.Battle.BattlePokemonInfo.Builder()
            if hasActiveAttacker {
              try subBuilder.mergeFrom(activeAttacker)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            activeAttacker = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.AttackGymResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.AttackGymResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueBattleLog = jsonMap["battleLog"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.battleLog = try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsonValueBattleLog).build()

        }
        if let jsonValueBattleId = jsonMap["battleId"] as? String {
          resultDecodedBuilder.battleId = jsonValueBattleId
        }
        if let jsonValueActiveDefender = jsonMap["activeDefender"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.activeDefender = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonValueActiveDefender).build()

        }
        if let jsonValueActiveAttacker = jsonMap["activeAttacker"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.activeAttacker = try Pogoprotos.Data.Battle.BattlePokemonInfo.Builder.decodeToBuilder(jsonValueActiveAttacker).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.AttackGymResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.AttackGymResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class CatchPokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum CatchStatus:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case CatchError = 0
        case CatchSuccess = 1
        case CatchEscape = 2
        case CatchFlee = 3
        case CatchMissed = 4
        public func toString() -> String {
          switch self {
          case .CatchError: return "CATCH_ERROR"
          case .CatchSuccess: return "CATCH_SUCCESS"
          case .CatchEscape: return "CATCH_ESCAPE"
          case .CatchFlee: return "CATCH_FLEE"
          case .CatchMissed: return "CATCH_MISSED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus {
          switch str {
          case "CATCH_ERROR":  return .CatchError
          case "CATCH_SUCCESS":  return .CatchSuccess
          case "CATCH_ESCAPE":  return .CatchEscape
          case "CATCH_FLEE":  return .CatchFlee
          case "CATCH_MISSED":  return .CatchMissed
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .CatchError: return ".CatchError"
                case .CatchSuccess: return ".CatchSuccess"
                case .CatchEscape: return ".CatchEscape"
                case .CatchFlee: return ".CatchFlee"
                case .CatchMissed: return ".CatchMissed"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var status:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus = Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus.CatchError
    public private(set) var hasStatus:Bool = false
    public private(set) var hasMissPercent:Bool = false
    public private(set) var missPercent:Double = Double(0)

    public private(set) var hasCapturedPokemonId:Bool = false
    public private(set) var capturedPokemonId:UInt64 = UInt64(0)

    public private(set) var hasCaptureAward:Bool = false
    public private(set) var captureAward:Pogoprotos.Data.Capture.CaptureAward!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStatus {
        try output.writeEnum(1, value:status.rawValue)
      }
      if hasMissPercent {
        try output.writeDouble(2, value:missPercent)
      }
      if hasCapturedPokemonId {
        try output.writeFixed64(3, value:capturedPokemonId)
      }
      if hasCaptureAward {
        try output.writeMessage(4, value:captureAward)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(1)
      }
      if hasMissPercent {
        serialize_size += missPercent.computeDoubleSize(2)
      }
      if hasCapturedPokemonId {
        serialize_size += capturedPokemonId.computeFixed64Size(3)
      }
      if hasCaptureAward {
          if let varSizecaptureAward = captureAward?.computeMessageSize(4) {
              serialize_size += varSizecaptureAward
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.CatchPokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.CatchPokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse? {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CatchPokemonResponse) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasMissPercent {
        jsonMap["missPercent"] = NSNumber(double:missPercent)
      }
      if hasCapturedPokemonId {
        jsonMap["capturedPokemonId"] = "\(capturedPokemonId)"
      }
      if hasCaptureAward {
        jsonMap["captureAward"] = try captureAward.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
      return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasMissPercent {
        output += "\(indent) missPercent: \(missPercent) \n"
      }
      if hasCapturedPokemonId {
        output += "\(indent) capturedPokemonId: \(capturedPokemonId) \n"
      }
      if hasCaptureAward {
        output += "\(indent) captureAward {\n"
        if let outDescCaptureAward = captureAward {
          output += try outDescCaptureAward.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasMissPercent {
               hashCode = (hashCode &* 31) &+ missPercent.hashValue
            }
            if hasCapturedPokemonId {
               hashCode = (hashCode &* 31) &+ capturedPokemonId.hashValue
            }
            if hasCaptureAward {
                if let hashValuecaptureAward = captureAward?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureAward
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CatchPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CatchPokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.CatchPokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.CatchPokemonResponse = Pogoprotos.Networking.Responses.CatchPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .CatchError
           return self
        }
      public var hasMissPercent:Bool {
           get {
                return builderResult.hasMissPercent
           }
      }
      public var missPercent:Double {
           get {
                return builderResult.missPercent
           }
           set (value) {
               builderResult.hasMissPercent = true
               builderResult.missPercent = value
           }
      }
      public func setMissPercent(value:Double) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.missPercent = value
        return self
      }
      public func clearMissPercent() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder{
           builderResult.hasMissPercent = false
           builderResult.missPercent = Double(0)
           return self
      }
      public var hasCapturedPokemonId:Bool {
           get {
                return builderResult.hasCapturedPokemonId
           }
      }
      public var capturedPokemonId:UInt64 {
           get {
                return builderResult.capturedPokemonId
           }
           set (value) {
               builderResult.hasCapturedPokemonId = true
               builderResult.capturedPokemonId = value
           }
      }
      public func setCapturedPokemonId(value:UInt64) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.capturedPokemonId = value
        return self
      }
      public func clearCapturedPokemonId() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder{
           builderResult.hasCapturedPokemonId = false
           builderResult.capturedPokemonId = UInt64(0)
           return self
      }
      public var hasCaptureAward:Bool {
           get {
               return builderResult.hasCaptureAward
           }
      }
      public var captureAward:Pogoprotos.Data.Capture.CaptureAward! {
           get {
               if captureAwardBuilder_ != nil {
                  builderResult.captureAward = captureAwardBuilder_.getMessage()
               }
               return builderResult.captureAward
           }
           set (value) {
               builderResult.hasCaptureAward = true
               builderResult.captureAward = value
           }
      }
      private var captureAwardBuilder_:Pogoprotos.Data.Capture.CaptureAward.Builder! {
           didSet {
              builderResult.hasCaptureAward = true
           }
      }
      public func getCaptureAwardBuilder() -> Pogoprotos.Data.Capture.CaptureAward.Builder {
        if captureAwardBuilder_ == nil {
           captureAwardBuilder_ = Pogoprotos.Data.Capture.CaptureAward.Builder()
           builderResult.captureAward = captureAwardBuilder_.getMessage()
           if captureAward != nil {
              try! captureAwardBuilder_.mergeFrom(captureAward)
           }
        }
        return captureAwardBuilder_
      }
      public func setCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward!) -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        self.captureAward = value
        return self
      }
      public func mergeCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        if builderResult.hasCaptureAward {
          builderResult.captureAward = try Pogoprotos.Data.Capture.CaptureAward.builderWithPrototype(builderResult.captureAward).mergeFrom(value).buildPartial()
        } else {
          builderResult.captureAward = value
        }
        builderResult.hasCaptureAward = true
        return self
      }
      public func clearCaptureAward() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        captureAwardBuilder_ = nil
        builderResult.hasCaptureAward = false
        builderResult.captureAward = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CatchPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.CatchPokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CatchPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.CatchPokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CatchPokemonResponse) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CatchPokemonResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if other.hasMissPercent {
             missPercent = other.missPercent
        }
        if other.hasCapturedPokemonId {
             capturedPokemonId = other.capturedPokemonId
        }
        if (other.hasCaptureAward) {
            try mergeCaptureAward(other.captureAward)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
            }

          case 17:
            missPercent = try input.readDouble()

          case 25:
            capturedPokemonId = try input.readFixed64()

          case 34:
            let subBuilder:Pogoprotos.Data.Capture.CaptureAward.Builder = Pogoprotos.Data.Capture.CaptureAward.Builder()
            if hasCaptureAward {
              try subBuilder.mergeFrom(captureAward)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            captureAward = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.CatchPokemonResponse.CatchStatus.fromString(jsonValueStatus)
        }
        if let jsonValueMissPercent = jsonMap["missPercent"] as? NSNumber {
          resultDecodedBuilder.missPercent = jsonValueMissPercent.doubleValue
        }
        if let jsonValueCapturedPokemonId = jsonMap["capturedPokemonId"] as? String {
          resultDecodedBuilder.capturedPokemonId = UInt64(jsonValueCapturedPokemonId)!
        }
        if let jsonValueCaptureAward = jsonMap["captureAward"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.captureAward = try Pogoprotos.Data.Capture.CaptureAward.Builder.decodeToBuilder(jsonValueCaptureAward).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CatchPokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class CheckAwardedBadgesResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    private var awardedBadgesMemoizedSerializedSize:Int32 = 0
    public private(set) var awardedBadges:Array<Pogoprotos.Enums.BadgeType> = Array<Pogoprotos.Enums.BadgeType>()
    public private(set) var awardedBadgeLevels:Array<Int32> = Array<Int32>()
    private var awardedBadgeLevelsMemoizedSerializedSize:Int32 = -1
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      for oneValueOfawardedBadges in awardedBadges {
          try output.writeEnum(2, value:oneValueOfawardedBadges.rawValue)
      }
      if !awardedBadgeLevels.isEmpty {
        try output.writeRawVarint32(26)
        try output.writeRawVarint32(awardedBadgeLevelsMemoizedSerializedSize)
        for oneValueawardedBadgeLevels in awardedBadgeLevels {
          try output.writeInt32NoTag(oneValueawardedBadgeLevels)
        }
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      var dataSizeawardedBadges:Int32 = 0
      for oneValueOfawardedBadges in awardedBadges {
          dataSizeawardedBadges += oneValueOfawardedBadges.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizeawardedBadges
      serialize_size += (1 * Int32(awardedBadges.count))
      var dataSizeAwardedBadgeLevels:Int32 = 0
      for oneValueawardedBadgeLevels in awardedBadgeLevels {
          dataSizeAwardedBadgeLevels += oneValueawardedBadgeLevels.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeAwardedBadgeLevels
      if !awardedBadgeLevels.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeAwardedBadgeLevels.computeInt32SizeNoTag()
      }
      awardedBadgeLevelsMemoizedSerializedSize = dataSizeAwardedBadgeLevels
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse? {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.classBuilder() as! Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !awardedBadges.isEmpty {
        var jsonArrayAwardedBadges:Array<String> = []
          for oneValueAwardedBadges in awardedBadges {
            jsonArrayAwardedBadges += [oneValueAwardedBadges.toString()]
          }
        jsonMap["awardedBadges"] = jsonArrayAwardedBadges
      }
      if !awardedBadgeLevels.isEmpty {
        var jsonArrayAwardedBadgeLevels:Array<NSNumber> = []
          for oneValueAwardedBadgeLevels in awardedBadgeLevels {
            jsonArrayAwardedBadgeLevels += [NSNumber(int:oneValueAwardedBadgeLevels)]
          }
        jsonMap["awardedBadgeLevels"] = jsonArrayAwardedBadgeLevels
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
      return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var awardedBadgesElementIndex:Int = 0
      for oneValueOfawardedBadges in awardedBadges {
          output += "\(indent) awardedBadges[\(awardedBadgesElementIndex)]: \(oneValueOfawardedBadges.description)\n"
          awardedBadgesElementIndex += 1
      }
      var awardedBadgeLevelsElementIndex:Int = 0
      for oneValueAwardedBadgeLevels in awardedBadgeLevels  {
          output += "\(indent) awardedBadgeLevels[\(awardedBadgeLevelsElementIndex)]: \(oneValueAwardedBadgeLevels)\n"
          awardedBadgeLevelsElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValueOfawardedBadges in awardedBadges {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfawardedBadges.rawValue)
            }
            for oneValueAwardedBadgeLevels in awardedBadgeLevels {
                hashCode = (hashCode &* 31) &+ oneValueAwardedBadgeLevels.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var awardedBadges:Array<Pogoprotos.Enums.BadgeType> {
          get {
              return builderResult.awardedBadges
          }
          set (value) {
              builderResult.awardedBadges = value
          }
      }
      public func setAwardedBadges(value:Array<Pogoprotos.Enums.BadgeType>) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.awardedBadges = value
        return self
      }
      public func clearAwardedBadges() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        builderResult.awardedBadges.removeAll(keepCapacity: false)
        return self
      }
      public var awardedBadgeLevels:Array<Int32> {
           get {
               return builderResult.awardedBadgeLevels
           }
           set (array) {
               builderResult.awardedBadgeLevels = array
           }
      }
      public func setAwardedBadgeLevels(value:Array<Int32>) -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        self.awardedBadgeLevels = value
        return self
      }
      public func clearAwardedBadgeLevels() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
         builderResult.awardedBadgeLevels.removeAll(keepCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse {
        let returnMe:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.awardedBadges.isEmpty {
           builderResult.awardedBadges += other.awardedBadges
        }
        if !other.awardedBadgeLevels.isEmpty {
            builderResult.awardedBadgeLevels += other.awardedBadgeLevels
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 16:
            let valueIntawardedBadges = try input.readEnum()
            if let enumsawardedBadges = Pogoprotos.Enums.BadgeType(rawValue:valueIntawardedBadges) {
                 builderResult.awardedBadges += [enumsawardedBadges]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntawardedBadges))
            }

          case 26:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.awardedBadgeLevels += [try input.readInt32()]
            }
            input.popLimit(limit)

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueAwardedBadges = jsonMap["awardedBadges"] as? Array<String> {
          var jsonArrayAwardedBadges:Array<Pogoprotos.Enums.BadgeType> = []
          for oneValueAwardedBadges in jsonValueAwardedBadges {
            let enumFromStringAwardedBadges = try Pogoprotos.Enums.BadgeType.fromString(oneValueAwardedBadges)
            jsonArrayAwardedBadges += [enumFromStringAwardedBadges]
          }
          resultDecodedBuilder.awardedBadges = jsonArrayAwardedBadges
        }
        if let jsonValueAwardedBadgeLevels = jsonMap["awardedBadgeLevels"] as? Array<NSNumber> {
          var jsonArrayAwardedBadgeLevels:Array<Int32> = []
          for oneValueAwardedBadgeLevels in jsonValueAwardedBadgeLevels {
            jsonArrayAwardedBadgeLevels += [oneValueAwardedBadgeLevels.intValue]
          }
          resultDecodedBuilder.awardedBadgeLevels = jsonArrayAwardedBadgeLevels
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CheckAwardedBadgesResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class CheckCodenameAvailableResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case CodenameNotAvailable = 2
        case CodenameNotValid = 3
        case CurrentOwner = 4
        case CodenameChangeNotAllowed = 5
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .CodenameNotAvailable: return "CODENAME_NOT_AVAILABLE"
          case .CodenameNotValid: return "CODENAME_NOT_VALID"
          case .CurrentOwner: return "CURRENT_OWNER"
          case .CodenameChangeNotAllowed: return "CODENAME_CHANGE_NOT_ALLOWED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "CODENAME_NOT_AVAILABLE":  return .CodenameNotAvailable
          case "CODENAME_NOT_VALID":  return .CodenameNotValid
          case "CURRENT_OWNER":  return .CurrentOwner
          case "CODENAME_CHANGE_NOT_ALLOWED":  return .CodenameChangeNotAllowed
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .CodenameNotAvailable: return ".CodenameNotAvailable"
                case .CodenameNotValid: return ".CodenameNotValid"
                case .CurrentOwner: return ".CurrentOwner"
                case .CodenameChangeNotAllowed: return ".CodenameChangeNotAllowed"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasCodename:Bool = false
    public private(set) var codename:String = ""

    public private(set) var hasUserMessage:Bool = false
    public private(set) var userMessage:String = ""

    public private(set) var hasIsAssignable:Bool = false
    public private(set) var isAssignable:Bool = false

    public private(set) var status:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status.Unset
    public private(set) var hasStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasCodename {
        try output.writeString(1, value:codename)
      }
      if hasUserMessage {
        try output.writeString(2, value:userMessage)
      }
      if hasIsAssignable {
        try output.writeBool(3, value:isAssignable)
      }
      if hasStatus {
        try output.writeEnum(4, value:status.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasCodename {
        serialize_size += codename.computeStringSize(1)
      }
      if hasUserMessage {
        serialize_size += userMessage.computeStringSize(2)
      }
      if hasIsAssignable {
        serialize_size += isAssignable.computeBoolSize(3)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse? {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.classBuilder() as! Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasCodename {
        jsonMap["codename"] = codename
      }
      if hasUserMessage {
        jsonMap["userMessage"] = userMessage
      }
      if hasIsAssignable {
        jsonMap["isAssignable"] = isAssignable
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
      return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasCodename {
        output += "\(indent) codename: \(codename) \n"
      }
      if hasUserMessage {
        output += "\(indent) userMessage: \(userMessage) \n"
      }
      if hasIsAssignable {
        output += "\(indent) isAssignable: \(isAssignable) \n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCodename {
               hashCode = (hashCode &* 31) &+ codename.hashValue
            }
            if hasUserMessage {
               hashCode = (hashCode &* 31) &+ userMessage.hashValue
            }
            if hasIsAssignable {
               hashCode = (hashCode &* 31) &+ isAssignable.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasCodename:Bool {
           get {
                return builderResult.hasCodename
           }
      }
      public var codename:String {
           get {
                return builderResult.codename
           }
           set (value) {
               builderResult.hasCodename = true
               builderResult.codename = value
           }
      }
      public func setCodename(value:String) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.codename = value
        return self
      }
      public func clearCodename() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasCodename = false
           builderResult.codename = ""
           return self
      }
      public var hasUserMessage:Bool {
           get {
                return builderResult.hasUserMessage
           }
      }
      public var userMessage:String {
           get {
                return builderResult.userMessage
           }
           set (value) {
               builderResult.hasUserMessage = true
               builderResult.userMessage = value
           }
      }
      public func setUserMessage(value:String) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.userMessage = value
        return self
      }
      public func clearUserMessage() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasUserMessage = false
           builderResult.userMessage = ""
           return self
      }
      public var hasIsAssignable:Bool {
           get {
                return builderResult.hasIsAssignable
           }
      }
      public var isAssignable:Bool {
           get {
                return builderResult.isAssignable
           }
           set (value) {
               builderResult.hasIsAssignable = true
               builderResult.isAssignable = value
           }
      }
      public func setIsAssignable(value:Bool) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        self.isAssignable = value
        return self
      }
      public func clearIsAssignable() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder{
           builderResult.hasIsAssignable = false
           builderResult.isAssignable = false
           return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status) -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .Unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse {
        let returnMe:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse() {
         return self
        }
        if other.hasCodename {
             codename = other.codename
        }
        if other.hasUserMessage {
             userMessage = other.userMessage
        }
        if other.hasIsAssignable {
             isAssignable = other.isAssignable
        }
        if other.hasStatus {
             status = other.status
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codename = try input.readString()

          case 18:
            userMessage = try input.readString()

          case 24:
            isAssignable = try input.readBool()

          case 32:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntstatus))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder()
        if let jsonValueCodename = jsonMap["codename"] as? String {
          resultDecodedBuilder.codename = jsonValueCodename
        }
        if let jsonValueUserMessage = jsonMap["userMessage"] as? String {
          resultDecodedBuilder.userMessage = jsonValueUserMessage
        }
        if let jsonValueIsAssignable = jsonMap["isAssignable"] as? Bool {
          resultDecodedBuilder.isAssignable = jsonValueIsAssignable
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Status.fromString(jsonValueStatus)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CheckCodenameAvailableResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class ClaimCodenameResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case CodenameNotAvailable = 2
        case CodenameNotValid = 3
        case CurrentOwner = 4
        case CodenameChangeNotAllowed = 5
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .CodenameNotAvailable: return "CODENAME_NOT_AVAILABLE"
          case .CodenameNotValid: return "CODENAME_NOT_VALID"
          case .CurrentOwner: return "CURRENT_OWNER"
          case .CodenameChangeNotAllowed: return "CODENAME_CHANGE_NOT_ALLOWED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "CODENAME_NOT_AVAILABLE":  return .CodenameNotAvailable
          case "CODENAME_NOT_VALID":  return .CodenameNotValid
          case "CURRENT_OWNER":  return .CurrentOwner
          case "CODENAME_CHANGE_NOT_ALLOWED":  return .CodenameChangeNotAllowed
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .CodenameNotAvailable: return ".CodenameNotAvailable"
                case .CodenameNotValid: return ".CodenameNotValid"
                case .CurrentOwner: return ".CurrentOwner"
                case .CodenameChangeNotAllowed: return ".CodenameChangeNotAllowed"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasCodename:Bool = false
    public private(set) var codename:String = ""

    public private(set) var hasUserMessage:Bool = false
    public private(set) var userMessage:String = ""

    public private(set) var hasIsAssignable:Bool = false
    public private(set) var isAssignable:Bool = false

    public private(set) var status:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status.Unset
    public private(set) var hasStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasCodename {
        try output.writeString(1, value:codename)
      }
      if hasUserMessage {
        try output.writeString(2, value:userMessage)
      }
      if hasIsAssignable {
        try output.writeBool(3, value:isAssignable)
      }
      if hasStatus {
        try output.writeEnum(4, value:status.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasCodename {
        serialize_size += codename.computeStringSize(1)
      }
      if hasUserMessage {
        serialize_size += userMessage.computeStringSize(2)
      }
      if hasIsAssignable {
        serialize_size += isAssignable.computeBoolSize(3)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.ClaimCodenameResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.ClaimCodenameResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse? {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.classBuilder() as! Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.ClaimCodenameResponse) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasCodename {
        jsonMap["codename"] = codename
      }
      if hasUserMessage {
        jsonMap["userMessage"] = userMessage
      }
      if hasIsAssignable {
        jsonMap["isAssignable"] = isAssignable
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
      return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasCodename {
        output += "\(indent) codename: \(codename) \n"
      }
      if hasUserMessage {
        output += "\(indent) userMessage: \(userMessage) \n"
      }
      if hasIsAssignable {
        output += "\(indent) isAssignable: \(isAssignable) \n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCodename {
               hashCode = (hashCode &* 31) &+ codename.hashValue
            }
            if hasUserMessage {
               hashCode = (hashCode &* 31) &+ userMessage.hashValue
            }
            if hasIsAssignable {
               hashCode = (hashCode &* 31) &+ isAssignable.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.ClaimCodenameResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.ClaimCodenameResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.ClaimCodenameResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.ClaimCodenameResponse = Pogoprotos.Networking.Responses.ClaimCodenameResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasCodename:Bool {
           get {
                return builderResult.hasCodename
           }
      }
      public var codename:String {
           get {
                return builderResult.codename
           }
           set (value) {
               builderResult.hasCodename = true
               builderResult.codename = value
           }
      }
      public func setCodename(value:String) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.codename = value
        return self
      }
      public func clearCodename() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasCodename = false
           builderResult.codename = ""
           return self
      }
      public var hasUserMessage:Bool {
           get {
                return builderResult.hasUserMessage
           }
      }
      public var userMessage:String {
           get {
                return builderResult.userMessage
           }
           set (value) {
               builderResult.hasUserMessage = true
               builderResult.userMessage = value
           }
      }
      public func setUserMessage(value:String) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.userMessage = value
        return self
      }
      public func clearUserMessage() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasUserMessage = false
           builderResult.userMessage = ""
           return self
      }
      public var hasIsAssignable:Bool {
           get {
                return builderResult.hasIsAssignable
           }
      }
      public var isAssignable:Bool {
           get {
                return builderResult.isAssignable
           }
           set (value) {
               builderResult.hasIsAssignable = true
               builderResult.isAssignable = value
           }
      }
      public func setIsAssignable(value:Bool) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        self.isAssignable = value
        return self
      }
      public func clearIsAssignable() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder{
           builderResult.hasIsAssignable = false
           builderResult.isAssignable = false
           return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status) -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .Unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.ClaimCodenameResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.ClaimCodenameResponse {
        let returnMe:Pogoprotos.Networking.Responses.ClaimCodenameResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.ClaimCodenameResponse) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        if other == Pogoprotos.Networking.Responses.ClaimCodenameResponse() {
         return self
        }
        if other.hasCodename {
             codename = other.codename
        }
        if other.hasUserMessage {
             userMessage = other.userMessage
        }
        if other.hasIsAssignable {
             isAssignable = other.isAssignable
        }
        if other.hasStatus {
             status = other.status
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codename = try input.readString()

          case 18:
            userMessage = try input.readString()

          case 24:
            isAssignable = try input.readBool()

          case 32:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntstatus))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder()
        if let jsonValueCodename = jsonMap["codename"] as? String {
          resultDecodedBuilder.codename = jsonValueCodename
        }
        if let jsonValueUserMessage = jsonMap["userMessage"] as? String {
          resultDecodedBuilder.userMessage = jsonValueUserMessage
        }
        if let jsonValueIsAssignable = jsonMap["isAssignable"] as? Bool {
          resultDecodedBuilder.isAssignable = jsonValueIsAssignable
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Status.fromString(jsonValueStatus)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.ClaimCodenameResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class CollectDailyBonusResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case Failure = 2
        case TooSoon = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .Failure: return "FAILURE"
          case .TooSoon: return "TOO_SOON"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "FAILURE":  return .Failure
          case "TOO_SOON":  return .TooSoon
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .Failure: return ".Failure"
                case .TooSoon: return ".TooSoon"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.CollectDailyBonusResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.CollectDailyBonusResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse? {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CollectDailyBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyBonusResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyBonusResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.CollectDailyBonusResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.CollectDailyBonusResponse = Pogoprotos.Networking.Responses.CollectDailyBonusResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result) -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CollectDailyBonusResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse {
        let returnMe:Pogoprotos.Networking.Responses.CollectDailyBonusResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CollectDailyBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CollectDailyBonusResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Result.fromString(jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CollectDailyBonusResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class CollectDailyDefenderBonusResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case Failure = 2
        case TooSoon = 3
        case NoDefenders = 4
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .Failure: return "FAILURE"
          case .TooSoon: return "TOO_SOON"
          case .NoDefenders: return "NO_DEFENDERS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "FAILURE":  return .Failure
          case "TOO_SOON":  return .TooSoon
          case "NO_DEFENDERS":  return .NoDefenders
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .Failure: return ".Failure"
                case .TooSoon: return ".TooSoon"
                case .NoDefenders: return ".NoDefenders"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var currencyType:Array<String> = Array<String>()
    public private(set) var currencyAwarded:Array<Int32> = Array<Int32>()
    private var currencyAwardedMemoizedSerializedSize:Int32 = -1
    public private(set) var hasDefendersCount:Bool = false
    public private(set) var defendersCount:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if !currencyType.isEmpty {
        for oneValuecurrencyType in currencyType {
          try output.writeString(2, value:oneValuecurrencyType)
        }
      }
      if !currencyAwarded.isEmpty {
        try output.writeRawVarint32(26)
        try output.writeRawVarint32(currencyAwardedMemoizedSerializedSize)
        for oneValuecurrencyAwarded in currencyAwarded {
          try output.writeInt32NoTag(oneValuecurrencyAwarded)
        }
      }
      if hasDefendersCount {
        try output.writeInt32(4, value:defendersCount)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      var dataSizeCurrencyType:Int32 = 0
      for oneValuecurrencyType in currencyType {
          dataSizeCurrencyType += oneValuecurrencyType.computeStringSizeNoTag()
      }
      serialize_size += dataSizeCurrencyType
      serialize_size += 1 * Int32(currencyType.count)
      var dataSizeCurrencyAwarded:Int32 = 0
      for oneValuecurrencyAwarded in currencyAwarded {
          dataSizeCurrencyAwarded += oneValuecurrencyAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeCurrencyAwarded
      if !currencyAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeCurrencyAwarded.computeInt32SizeNoTag()
      }
      currencyAwardedMemoizedSerializedSize = dataSizeCurrencyAwarded
      if hasDefendersCount {
        serialize_size += defendersCount.computeInt32Size(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse? {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !currencyType.isEmpty {
        jsonMap["currencyType"] = currencyType
      }
      if !currencyAwarded.isEmpty {
        var jsonArrayCurrencyAwarded:Array<NSNumber> = []
          for oneValueCurrencyAwarded in currencyAwarded {
            jsonArrayCurrencyAwarded += [NSNumber(int:oneValueCurrencyAwarded)]
          }
        jsonMap["currencyAwarded"] = jsonArrayCurrencyAwarded
      }
      if hasDefendersCount {
        jsonMap["defendersCount"] = NSNumber(int:defendersCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
      return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var currencyTypeElementIndex:Int = 0
      for oneValueCurrencyType in currencyType  {
          output += "\(indent) currencyType[\(currencyTypeElementIndex)]: \(oneValueCurrencyType)\n"
          currencyTypeElementIndex += 1
      }
      var currencyAwardedElementIndex:Int = 0
      for oneValueCurrencyAwarded in currencyAwarded  {
          output += "\(indent) currencyAwarded[\(currencyAwardedElementIndex)]: \(oneValueCurrencyAwarded)\n"
          currencyAwardedElementIndex += 1
      }
      if hasDefendersCount {
        output += "\(indent) defendersCount: \(defendersCount) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneValueCurrencyType in currencyType {
                hashCode = (hashCode &* 31) &+ oneValueCurrencyType.hashValue
            }
            for oneValueCurrencyAwarded in currencyAwarded {
                hashCode = (hashCode &* 31) &+ oneValueCurrencyAwarded.hashValue
            }
            if hasDefendersCount {
               hashCode = (hashCode &* 31) &+ defendersCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var currencyType:Array<String> {
           get {
               return builderResult.currencyType
           }
           set (array) {
               builderResult.currencyType = array
           }
      }
      public func setCurrencyType(value:Array<String>) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.currencyType = value
        return self
      }
      public func clearCurrencyType() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
         builderResult.currencyType.removeAll(keepCapacity: false)
         return self
      }
      public var currencyAwarded:Array<Int32> {
           get {
               return builderResult.currencyAwarded
           }
           set (array) {
               builderResult.currencyAwarded = array
           }
      }
      public func setCurrencyAwarded(value:Array<Int32>) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.currencyAwarded = value
        return self
      }
      public func clearCurrencyAwarded() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
         builderResult.currencyAwarded.removeAll(keepCapacity: false)
         return self
      }
      public var hasDefendersCount:Bool {
           get {
                return builderResult.hasDefendersCount
           }
      }
      public var defendersCount:Int32 {
           get {
                return builderResult.defendersCount
           }
           set (value) {
               builderResult.hasDefendersCount = true
               builderResult.defendersCount = value
           }
      }
      public func setDefendersCount(value:Int32) -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        self.defendersCount = value
        return self
      }
      public func clearDefendersCount() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder{
           builderResult.hasDefendersCount = false
           builderResult.defendersCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse {
        let returnMe:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        if other == Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.currencyType.isEmpty {
            builderResult.currencyType += other.currencyType
        }
        if !other.currencyAwarded.isEmpty {
            builderResult.currencyAwarded += other.currencyAwarded
        }
        if other.hasDefendersCount {
             defendersCount = other.defendersCount
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            currencyType += [try input.readString()]

          case 26:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.currencyAwarded += [try input.readInt32()]
            }
            input.popLimit(limit)

          case 32:
            defendersCount = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueCurrencyType = jsonMap["currencyType"] as? Array<String> {
          resultDecodedBuilder.currencyType = jsonValueCurrencyType
        }
        if let jsonValueCurrencyAwarded = jsonMap["currencyAwarded"] as? Array<NSNumber> {
          var jsonArrayCurrencyAwarded:Array<Int32> = []
          for oneValueCurrencyAwarded in jsonValueCurrencyAwarded {
            jsonArrayCurrencyAwarded += [oneValueCurrencyAwarded.intValue]
          }
          resultDecodedBuilder.currencyAwarded = jsonArrayCurrencyAwarded
        }
        if let jsonValueDefendersCount = jsonMap["defendersCount"] as? NSNumber {
          resultDecodedBuilder.defendersCount = jsonValueDefendersCount.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.CollectDailyDefenderBonusResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class DiskEncounterResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unknown = 0
        case Success = 1
        case NotAvailable = 2
        case NotInRange = 3
        case EncounterAlreadyFinished = 4
        case PokemonInventoryFull = 5
        public func toString() -> String {
          switch self {
          case .Unknown: return "UNKNOWN"
          case .Success: return "SUCCESS"
          case .NotAvailable: return "NOT_AVAILABLE"
          case .NotInRange: return "NOT_IN_RANGE"
          case .EncounterAlreadyFinished: return "ENCOUNTER_ALREADY_FINISHED"
          case .PokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Result {
          switch str {
          case "UNKNOWN":  return .Unknown
          case "SUCCESS":  return .Success
          case "NOT_AVAILABLE":  return .NotAvailable
          case "NOT_IN_RANGE":  return .NotInRange
          case "ENCOUNTER_ALREADY_FINISHED":  return .EncounterAlreadyFinished
          case "POKEMON_INVENTORY_FULL":  return .PokemonInventoryFull
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unknown: return ".Unknown"
                case .Success: return ".Success"
                case .NotAvailable: return ".NotAvailable"
                case .NotInRange: return ".NotInRange"
                case .EncounterAlreadyFinished: return ".EncounterAlreadyFinished"
                case .PokemonInventoryFull: return ".PokemonInventoryFull"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result = Pogoprotos.Networking.Responses.DiskEncounterResponse.Result.Unknown
    public private(set) var hasResult:Bool = false
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasCaptureProbability:Bool = false
    public private(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasPokemonData {
        try output.writeMessage(2, value:pokemonData)
      }
      if hasCaptureProbability {
        try output.writeMessage(3, value:captureProbability)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(3) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.DiskEncounterResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.DiskEncounterResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse? {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DiskEncounterResponse) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
      return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DiskEncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DiskEncounterResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.DiskEncounterResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.DiskEncounterResponse = Pogoprotos.Networking.Responses.DiskEncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.DiskEncounterResponse.Result) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unknown
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      private var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      public func setCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(builderResult.captureProbability).mergeFrom(value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DiskEncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.DiskEncounterResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DiskEncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.DiskEncounterResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DiskEncounterResponse) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DiskEncounterResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(other.captureProbability)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.DiskEncounterResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(captureProbability)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.DiskEncounterResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DiskEncounterResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class DownloadItemTemplatesResponse : GeneratedMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class ItemTemplate : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasTemplateId:Bool = false
        public private(set) var templateId:String = ""

        public private(set) var hasPokemonSettings:Bool = false
        public private(set) var pokemonSettings:Pogoprotos.Settings.Master.PokemonSettings!
        public private(set) var hasItemSettings:Bool = false
        public private(set) var itemSettings:Pogoprotos.Settings.Master.ItemSettings!
        public private(set) var hasMoveSettings:Bool = false
        public private(set) var moveSettings:Pogoprotos.Settings.Master.MoveSettings!
        public private(set) var hasMoveSequenceSettings:Bool = false
        public private(set) var moveSequenceSettings:Pogoprotos.Settings.Master.MoveSequenceSettings!
        public private(set) var hasTypeEffective:Bool = false
        public private(set) var typeEffective:Pogoprotos.Settings.Master.TypeEffectiveSettings!
        public private(set) var hasBadgeSettings:Bool = false
        public private(set) var badgeSettings:Pogoprotos.Settings.Master.BadgeSettings!
        public private(set) var hasCamera:Bool = false
        public private(set) var camera:Pogoprotos.Settings.Master.CameraSettings!
        public private(set) var hasPlayerLevel:Bool = false
        public private(set) var playerLevel:Pogoprotos.Settings.Master.PlayerLevelSettings!
        public private(set) var hasGymLevel:Bool = false
        public private(set) var gymLevel:Pogoprotos.Settings.Master.GymLevelSettings!
        public private(set) var hasBattleSettings:Bool = false
        public private(set) var battleSettings:Pogoprotos.Settings.Master.GymBattleSettings!
        public private(set) var hasEncounterSettings:Bool = false
        public private(set) var encounterSettings:Pogoprotos.Settings.Master.EncounterSettings!
        public private(set) var hasIapItemDisplay:Bool = false
        public private(set) var iapItemDisplay:Pogoprotos.Settings.Master.IapItemDisplay!
        public private(set) var hasIapSettings:Bool = false
        public private(set) var iapSettings:Pogoprotos.Settings.Master.IapSettings!
        public private(set) var hasPokemonUpgrades:Bool = false
        public private(set) var pokemonUpgrades:Pogoprotos.Settings.Master.PokemonUpgradeSettings!
        public private(set) var hasEquippedBadges:Bool = false
        public private(set) var equippedBadges:Pogoprotos.Settings.Master.EquippedBadgeSettings!
        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasTemplateId {
            try output.writeString(1, value:templateId)
          }
          if hasPokemonSettings {
            try output.writeMessage(2, value:pokemonSettings)
          }
          if hasItemSettings {
            try output.writeMessage(3, value:itemSettings)
          }
          if hasMoveSettings {
            try output.writeMessage(4, value:moveSettings)
          }
          if hasMoveSequenceSettings {
            try output.writeMessage(5, value:moveSequenceSettings)
          }
          if hasTypeEffective {
            try output.writeMessage(8, value:typeEffective)
          }
          if hasBadgeSettings {
            try output.writeMessage(10, value:badgeSettings)
          }
          if hasCamera {
            try output.writeMessage(11, value:camera)
          }
          if hasPlayerLevel {
            try output.writeMessage(12, value:playerLevel)
          }
          if hasGymLevel {
            try output.writeMessage(13, value:gymLevel)
          }
          if hasBattleSettings {
            try output.writeMessage(14, value:battleSettings)
          }
          if hasEncounterSettings {
            try output.writeMessage(15, value:encounterSettings)
          }
          if hasIapItemDisplay {
            try output.writeMessage(16, value:iapItemDisplay)
          }
          if hasIapSettings {
            try output.writeMessage(17, value:iapSettings)
          }
          if hasPokemonUpgrades {
            try output.writeMessage(18, value:pokemonUpgrades)
          }
          if hasEquippedBadges {
            try output.writeMessage(19, value:equippedBadges)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasTemplateId {
            serialize_size += templateId.computeStringSize(1)
          }
          if hasPokemonSettings {
              if let varSizepokemonSettings = pokemonSettings?.computeMessageSize(2) {
                  serialize_size += varSizepokemonSettings
              }
          }
          if hasItemSettings {
              if let varSizeitemSettings = itemSettings?.computeMessageSize(3) {
                  serialize_size += varSizeitemSettings
              }
          }
          if hasMoveSettings {
              if let varSizemoveSettings = moveSettings?.computeMessageSize(4) {
                  serialize_size += varSizemoveSettings
              }
          }
          if hasMoveSequenceSettings {
              if let varSizemoveSequenceSettings = moveSequenceSettings?.computeMessageSize(5) {
                  serialize_size += varSizemoveSequenceSettings
              }
          }
          if hasTypeEffective {
              if let varSizetypeEffective = typeEffective?.computeMessageSize(8) {
                  serialize_size += varSizetypeEffective
              }
          }
          if hasBadgeSettings {
              if let varSizebadgeSettings = badgeSettings?.computeMessageSize(10) {
                  serialize_size += varSizebadgeSettings
              }
          }
          if hasCamera {
              if let varSizecamera = camera?.computeMessageSize(11) {
                  serialize_size += varSizecamera
              }
          }
          if hasPlayerLevel {
              if let varSizeplayerLevel = playerLevel?.computeMessageSize(12) {
                  serialize_size += varSizeplayerLevel
              }
          }
          if hasGymLevel {
              if let varSizegymLevel = gymLevel?.computeMessageSize(13) {
                  serialize_size += varSizegymLevel
              }
          }
          if hasBattleSettings {
              if let varSizebattleSettings = battleSettings?.computeMessageSize(14) {
                  serialize_size += varSizebattleSettings
              }
          }
          if hasEncounterSettings {
              if let varSizeencounterSettings = encounterSettings?.computeMessageSize(15) {
                  serialize_size += varSizeencounterSettings
              }
          }
          if hasIapItemDisplay {
              if let varSizeiapItemDisplay = iapItemDisplay?.computeMessageSize(16) {
                  serialize_size += varSizeiapItemDisplay
              }
          }
          if hasIapSettings {
              if let varSizeiapSettings = iapSettings?.computeMessageSize(17) {
                  serialize_size += varSizeiapSettings
              }
          }
          if hasPokemonUpgrades {
              if let varSizepokemonUpgrades = pokemonUpgrades?.computeMessageSize(18) {
                  serialize_size += varSizepokemonUpgrades
              }
          }
          if hasEquippedBadges {
              if let varSizeequippedBadges = equippedBadges?.computeMessageSize(19) {
                  serialize_size += varSizeequippedBadges
              }
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> {
          var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate? {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder
        }
        public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder
        }
        override public class func classBuilder() -> MessageBuilder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
        }
        override public func classBuilder() -> MessageBuilder {
          return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
        }
        public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder().mergeFrom(prototype)
        }
        override public func encode() throws -> Dictionary<String,AnyObject> {
          guard isInitialized() else {
            throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
          }

          var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
          if hasTemplateId {
            jsonMap["templateId"] = templateId
          }
          if hasPokemonSettings {
            jsonMap["pokemonSettings"] = try pokemonSettings.encode()
          }
          if hasItemSettings {
            jsonMap["itemSettings"] = try itemSettings.encode()
          }
          if hasMoveSettings {
            jsonMap["moveSettings"] = try moveSettings.encode()
          }
          if hasMoveSequenceSettings {
            jsonMap["moveSequenceSettings"] = try moveSequenceSettings.encode()
          }
          if hasTypeEffective {
            jsonMap["typeEffective"] = try typeEffective.encode()
          }
          if hasBadgeSettings {
            jsonMap["badgeSettings"] = try badgeSettings.encode()
          }
          if hasCamera {
            jsonMap["camera"] = try camera.encode()
          }
          if hasPlayerLevel {
            jsonMap["playerLevel"] = try playerLevel.encode()
          }
          if hasGymLevel {
            jsonMap["gymLevel"] = try gymLevel.encode()
          }
          if hasBattleSettings {
            jsonMap["battleSettings"] = try battleSettings.encode()
          }
          if hasEncounterSettings {
            jsonMap["encounterSettings"] = try encounterSettings.encode()
          }
          if hasIapItemDisplay {
            jsonMap["iapItemDisplay"] = try iapItemDisplay.encode()
          }
          if hasIapSettings {
            jsonMap["iapSettings"] = try iapSettings.encode()
          }
          if hasPokemonUpgrades {
            jsonMap["pokemonUpgrades"] = try pokemonUpgrades.encode()
          }
          if hasEquippedBadges {
            jsonMap["equippedBadges"] = try equippedBadges.encode()
          }
          return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(jsonMap).build()
        }
        override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
          return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.fromJSONToBuilder(data).build()
        }
        override public func getDescription(indent:String) throws -> String {
          var output = ""
          if hasTemplateId {
            output += "\(indent) templateId: \(templateId) \n"
          }
          if hasPokemonSettings {
            output += "\(indent) pokemonSettings {\n"
            if let outDescPokemonSettings = pokemonSettings {
              output += try outDescPokemonSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasItemSettings {
            output += "\(indent) itemSettings {\n"
            if let outDescItemSettings = itemSettings {
              output += try outDescItemSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasMoveSettings {
            output += "\(indent) moveSettings {\n"
            if let outDescMoveSettings = moveSettings {
              output += try outDescMoveSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasMoveSequenceSettings {
            output += "\(indent) moveSequenceSettings {\n"
            if let outDescMoveSequenceSettings = moveSequenceSettings {
              output += try outDescMoveSequenceSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasTypeEffective {
            output += "\(indent) typeEffective {\n"
            if let outDescTypeEffective = typeEffective {
              output += try outDescTypeEffective.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasBadgeSettings {
            output += "\(indent) badgeSettings {\n"
            if let outDescBadgeSettings = badgeSettings {
              output += try outDescBadgeSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasCamera {
            output += "\(indent) camera {\n"
            if let outDescCamera = camera {
              output += try outDescCamera.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasPlayerLevel {
            output += "\(indent) playerLevel {\n"
            if let outDescPlayerLevel = playerLevel {
              output += try outDescPlayerLevel.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasGymLevel {
            output += "\(indent) gymLevel {\n"
            if let outDescGymLevel = gymLevel {
              output += try outDescGymLevel.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasBattleSettings {
            output += "\(indent) battleSettings {\n"
            if let outDescBattleSettings = battleSettings {
              output += try outDescBattleSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasEncounterSettings {
            output += "\(indent) encounterSettings {\n"
            if let outDescEncounterSettings = encounterSettings {
              output += try outDescEncounterSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasIapItemDisplay {
            output += "\(indent) iapItemDisplay {\n"
            if let outDescIapItemDisplay = iapItemDisplay {
              output += try outDescIapItemDisplay.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasIapSettings {
            output += "\(indent) iapSettings {\n"
            if let outDescIapSettings = iapSettings {
              output += try outDescIapSettings.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasPokemonUpgrades {
            output += "\(indent) pokemonUpgrades {\n"
            if let outDescPokemonUpgrades = pokemonUpgrades {
              output += try outDescPokemonUpgrades.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          if hasEquippedBadges {
            output += "\(indent) equippedBadges {\n"
            if let outDescEquippedBadges = equippedBadges {
              output += try outDescEquippedBadges.getDescription("\(indent)  ")
            }
            output += "\(indent) }\n"
          }
          output += unknownFields.getDescription(indent)
          return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasTemplateId {
                   hashCode = (hashCode &* 31) &+ templateId.hashValue
                }
                if hasPokemonSettings {
                    if let hashValuepokemonSettings = pokemonSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepokemonSettings
                    }
                }
                if hasItemSettings {
                    if let hashValueitemSettings = itemSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueitemSettings
                    }
                }
                if hasMoveSettings {
                    if let hashValuemoveSettings = moveSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemoveSettings
                    }
                }
                if hasMoveSequenceSettings {
                    if let hashValuemoveSequenceSettings = moveSequenceSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuemoveSequenceSettings
                    }
                }
                if hasTypeEffective {
                    if let hashValuetypeEffective = typeEffective?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuetypeEffective
                    }
                }
                if hasBadgeSettings {
                    if let hashValuebadgeSettings = badgeSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebadgeSettings
                    }
                }
                if hasCamera {
                    if let hashValuecamera = camera?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuecamera
                    }
                }
                if hasPlayerLevel {
                    if let hashValueplayerLevel = playerLevel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueplayerLevel
                    }
                }
                if hasGymLevel {
                    if let hashValuegymLevel = gymLevel?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuegymLevel
                    }
                }
                if hasBattleSettings {
                    if let hashValuebattleSettings = battleSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuebattleSettings
                    }
                }
                if hasEncounterSettings {
                    if let hashValueencounterSettings = encounterSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueencounterSettings
                    }
                }
                if hasIapItemDisplay {
                    if let hashValueiapItemDisplay = iapItemDisplay?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueiapItemDisplay
                    }
                }
                if hasIapSettings {
                    if let hashValueiapSettings = iapSettings?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueiapSettings
                    }
                }
                if hasPokemonUpgrades {
                    if let hashValuepokemonUpgrades = pokemonUpgrades?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValuepokemonUpgrades
                    }
                }
                if hasEquippedBadges {
                    if let hashValueequippedBadges = equippedBadges?.hashValue {
                        hashCode = (hashCode &* 31) &+ hashValueequippedBadges
                    }
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate"
        }
        override public func className() -> String {
            return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate()
          public func getMessage() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasTemplateId:Bool {
               get {
                    return builderResult.hasTemplateId
               }
          }
          public var templateId:String {
               get {
                    return builderResult.templateId
               }
               set (value) {
                   builderResult.hasTemplateId = true
                   builderResult.templateId = value
               }
          }
          public func setTemplateId(value:String) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.templateId = value
            return self
          }
          public func clearTemplateId() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder{
               builderResult.hasTemplateId = false
               builderResult.templateId = ""
               return self
          }
          public var hasPokemonSettings:Bool {
               get {
                   return builderResult.hasPokemonSettings
               }
          }
          public var pokemonSettings:Pogoprotos.Settings.Master.PokemonSettings! {
               get {
                   if pokemonSettingsBuilder_ != nil {
                      builderResult.pokemonSettings = pokemonSettingsBuilder_.getMessage()
                   }
                   return builderResult.pokemonSettings
               }
               set (value) {
                   builderResult.hasPokemonSettings = true
                   builderResult.pokemonSettings = value
               }
          }
          private var pokemonSettingsBuilder_:Pogoprotos.Settings.Master.PokemonSettings.Builder! {
               didSet {
                  builderResult.hasPokemonSettings = true
               }
          }
          public func getPokemonSettingsBuilder() -> Pogoprotos.Settings.Master.PokemonSettings.Builder {
            if pokemonSettingsBuilder_ == nil {
               pokemonSettingsBuilder_ = Pogoprotos.Settings.Master.PokemonSettings.Builder()
               builderResult.pokemonSettings = pokemonSettingsBuilder_.getMessage()
               if pokemonSettings != nil {
                  try! pokemonSettingsBuilder_.mergeFrom(pokemonSettings)
               }
            }
            return pokemonSettingsBuilder_
          }
          public func setPokemonSettings(value:Pogoprotos.Settings.Master.PokemonSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.pokemonSettings = value
            return self
          }
          public func mergePokemonSettings(value:Pogoprotos.Settings.Master.PokemonSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPokemonSettings {
              builderResult.pokemonSettings = try Pogoprotos.Settings.Master.PokemonSettings.builderWithPrototype(builderResult.pokemonSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.pokemonSettings = value
            }
            builderResult.hasPokemonSettings = true
            return self
          }
          public func clearPokemonSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            pokemonSettingsBuilder_ = nil
            builderResult.hasPokemonSettings = false
            builderResult.pokemonSettings = nil
            return self
          }
          public var hasItemSettings:Bool {
               get {
                   return builderResult.hasItemSettings
               }
          }
          public var itemSettings:Pogoprotos.Settings.Master.ItemSettings! {
               get {
                   if itemSettingsBuilder_ != nil {
                      builderResult.itemSettings = itemSettingsBuilder_.getMessage()
                   }
                   return builderResult.itemSettings
               }
               set (value) {
                   builderResult.hasItemSettings = true
                   builderResult.itemSettings = value
               }
          }
          private var itemSettingsBuilder_:Pogoprotos.Settings.Master.ItemSettings.Builder! {
               didSet {
                  builderResult.hasItemSettings = true
               }
          }
          public func getItemSettingsBuilder() -> Pogoprotos.Settings.Master.ItemSettings.Builder {
            if itemSettingsBuilder_ == nil {
               itemSettingsBuilder_ = Pogoprotos.Settings.Master.ItemSettings.Builder()
               builderResult.itemSettings = itemSettingsBuilder_.getMessage()
               if itemSettings != nil {
                  try! itemSettingsBuilder_.mergeFrom(itemSettings)
               }
            }
            return itemSettingsBuilder_
          }
          public func setItemSettings(value:Pogoprotos.Settings.Master.ItemSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.itemSettings = value
            return self
          }
          public func mergeItemSettings(value:Pogoprotos.Settings.Master.ItemSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasItemSettings {
              builderResult.itemSettings = try Pogoprotos.Settings.Master.ItemSettings.builderWithPrototype(builderResult.itemSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.itemSettings = value
            }
            builderResult.hasItemSettings = true
            return self
          }
          public func clearItemSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            itemSettingsBuilder_ = nil
            builderResult.hasItemSettings = false
            builderResult.itemSettings = nil
            return self
          }
          public var hasMoveSettings:Bool {
               get {
                   return builderResult.hasMoveSettings
               }
          }
          public var moveSettings:Pogoprotos.Settings.Master.MoveSettings! {
               get {
                   if moveSettingsBuilder_ != nil {
                      builderResult.moveSettings = moveSettingsBuilder_.getMessage()
                   }
                   return builderResult.moveSettings
               }
               set (value) {
                   builderResult.hasMoveSettings = true
                   builderResult.moveSettings = value
               }
          }
          private var moveSettingsBuilder_:Pogoprotos.Settings.Master.MoveSettings.Builder! {
               didSet {
                  builderResult.hasMoveSettings = true
               }
          }
          public func getMoveSettingsBuilder() -> Pogoprotos.Settings.Master.MoveSettings.Builder {
            if moveSettingsBuilder_ == nil {
               moveSettingsBuilder_ = Pogoprotos.Settings.Master.MoveSettings.Builder()
               builderResult.moveSettings = moveSettingsBuilder_.getMessage()
               if moveSettings != nil {
                  try! moveSettingsBuilder_.mergeFrom(moveSettings)
               }
            }
            return moveSettingsBuilder_
          }
          public func setMoveSettings(value:Pogoprotos.Settings.Master.MoveSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.moveSettings = value
            return self
          }
          public func mergeMoveSettings(value:Pogoprotos.Settings.Master.MoveSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasMoveSettings {
              builderResult.moveSettings = try Pogoprotos.Settings.Master.MoveSettings.builderWithPrototype(builderResult.moveSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.moveSettings = value
            }
            builderResult.hasMoveSettings = true
            return self
          }
          public func clearMoveSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            moveSettingsBuilder_ = nil
            builderResult.hasMoveSettings = false
            builderResult.moveSettings = nil
            return self
          }
          public var hasMoveSequenceSettings:Bool {
               get {
                   return builderResult.hasMoveSequenceSettings
               }
          }
          public var moveSequenceSettings:Pogoprotos.Settings.Master.MoveSequenceSettings! {
               get {
                   if moveSequenceSettingsBuilder_ != nil {
                      builderResult.moveSequenceSettings = moveSequenceSettingsBuilder_.getMessage()
                   }
                   return builderResult.moveSequenceSettings
               }
               set (value) {
                   builderResult.hasMoveSequenceSettings = true
                   builderResult.moveSequenceSettings = value
               }
          }
          private var moveSequenceSettingsBuilder_:Pogoprotos.Settings.Master.MoveSequenceSettings.Builder! {
               didSet {
                  builderResult.hasMoveSequenceSettings = true
               }
          }
          public func getMoveSequenceSettingsBuilder() -> Pogoprotos.Settings.Master.MoveSequenceSettings.Builder {
            if moveSequenceSettingsBuilder_ == nil {
               moveSequenceSettingsBuilder_ = Pogoprotos.Settings.Master.MoveSequenceSettings.Builder()
               builderResult.moveSequenceSettings = moveSequenceSettingsBuilder_.getMessage()
               if moveSequenceSettings != nil {
                  try! moveSequenceSettingsBuilder_.mergeFrom(moveSequenceSettings)
               }
            }
            return moveSequenceSettingsBuilder_
          }
          public func setMoveSequenceSettings(value:Pogoprotos.Settings.Master.MoveSequenceSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.moveSequenceSettings = value
            return self
          }
          public func mergeMoveSequenceSettings(value:Pogoprotos.Settings.Master.MoveSequenceSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasMoveSequenceSettings {
              builderResult.moveSequenceSettings = try Pogoprotos.Settings.Master.MoveSequenceSettings.builderWithPrototype(builderResult.moveSequenceSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.moveSequenceSettings = value
            }
            builderResult.hasMoveSequenceSettings = true
            return self
          }
          public func clearMoveSequenceSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            moveSequenceSettingsBuilder_ = nil
            builderResult.hasMoveSequenceSettings = false
            builderResult.moveSequenceSettings = nil
            return self
          }
          public var hasTypeEffective:Bool {
               get {
                   return builderResult.hasTypeEffective
               }
          }
          public var typeEffective:Pogoprotos.Settings.Master.TypeEffectiveSettings! {
               get {
                   if typeEffectiveBuilder_ != nil {
                      builderResult.typeEffective = typeEffectiveBuilder_.getMessage()
                   }
                   return builderResult.typeEffective
               }
               set (value) {
                   builderResult.hasTypeEffective = true
                   builderResult.typeEffective = value
               }
          }
          private var typeEffectiveBuilder_:Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder! {
               didSet {
                  builderResult.hasTypeEffective = true
               }
          }
          public func getTypeEffectiveBuilder() -> Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder {
            if typeEffectiveBuilder_ == nil {
               typeEffectiveBuilder_ = Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder()
               builderResult.typeEffective = typeEffectiveBuilder_.getMessage()
               if typeEffective != nil {
                  try! typeEffectiveBuilder_.mergeFrom(typeEffective)
               }
            }
            return typeEffectiveBuilder_
          }
          public func setTypeEffective(value:Pogoprotos.Settings.Master.TypeEffectiveSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.typeEffective = value
            return self
          }
          public func mergeTypeEffective(value:Pogoprotos.Settings.Master.TypeEffectiveSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasTypeEffective {
              builderResult.typeEffective = try Pogoprotos.Settings.Master.TypeEffectiveSettings.builderWithPrototype(builderResult.typeEffective).mergeFrom(value).buildPartial()
            } else {
              builderResult.typeEffective = value
            }
            builderResult.hasTypeEffective = true
            return self
          }
          public func clearTypeEffective() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            typeEffectiveBuilder_ = nil
            builderResult.hasTypeEffective = false
            builderResult.typeEffective = nil
            return self
          }
          public var hasBadgeSettings:Bool {
               get {
                   return builderResult.hasBadgeSettings
               }
          }
          public var badgeSettings:Pogoprotos.Settings.Master.BadgeSettings! {
               get {
                   if badgeSettingsBuilder_ != nil {
                      builderResult.badgeSettings = badgeSettingsBuilder_.getMessage()
                   }
                   return builderResult.badgeSettings
               }
               set (value) {
                   builderResult.hasBadgeSettings = true
                   builderResult.badgeSettings = value
               }
          }
          private var badgeSettingsBuilder_:Pogoprotos.Settings.Master.BadgeSettings.Builder! {
               didSet {
                  builderResult.hasBadgeSettings = true
               }
          }
          public func getBadgeSettingsBuilder() -> Pogoprotos.Settings.Master.BadgeSettings.Builder {
            if badgeSettingsBuilder_ == nil {
               badgeSettingsBuilder_ = Pogoprotos.Settings.Master.BadgeSettings.Builder()
               builderResult.badgeSettings = badgeSettingsBuilder_.getMessage()
               if badgeSettings != nil {
                  try! badgeSettingsBuilder_.mergeFrom(badgeSettings)
               }
            }
            return badgeSettingsBuilder_
          }
          public func setBadgeSettings(value:Pogoprotos.Settings.Master.BadgeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.badgeSettings = value
            return self
          }
          public func mergeBadgeSettings(value:Pogoprotos.Settings.Master.BadgeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasBadgeSettings {
              builderResult.badgeSettings = try Pogoprotos.Settings.Master.BadgeSettings.builderWithPrototype(builderResult.badgeSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.badgeSettings = value
            }
            builderResult.hasBadgeSettings = true
            return self
          }
          public func clearBadgeSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            badgeSettingsBuilder_ = nil
            builderResult.hasBadgeSettings = false
            builderResult.badgeSettings = nil
            return self
          }
          public var hasCamera:Bool {
               get {
                   return builderResult.hasCamera
               }
          }
          public var camera:Pogoprotos.Settings.Master.CameraSettings! {
               get {
                   if cameraBuilder_ != nil {
                      builderResult.camera = cameraBuilder_.getMessage()
                   }
                   return builderResult.camera
               }
               set (value) {
                   builderResult.hasCamera = true
                   builderResult.camera = value
               }
          }
          private var cameraBuilder_:Pogoprotos.Settings.Master.CameraSettings.Builder! {
               didSet {
                  builderResult.hasCamera = true
               }
          }
          public func getCameraBuilder() -> Pogoprotos.Settings.Master.CameraSettings.Builder {
            if cameraBuilder_ == nil {
               cameraBuilder_ = Pogoprotos.Settings.Master.CameraSettings.Builder()
               builderResult.camera = cameraBuilder_.getMessage()
               if camera != nil {
                  try! cameraBuilder_.mergeFrom(camera)
               }
            }
            return cameraBuilder_
          }
          public func setCamera(value:Pogoprotos.Settings.Master.CameraSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.camera = value
            return self
          }
          public func mergeCamera(value:Pogoprotos.Settings.Master.CameraSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasCamera {
              builderResult.camera = try Pogoprotos.Settings.Master.CameraSettings.builderWithPrototype(builderResult.camera).mergeFrom(value).buildPartial()
            } else {
              builderResult.camera = value
            }
            builderResult.hasCamera = true
            return self
          }
          public func clearCamera() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            cameraBuilder_ = nil
            builderResult.hasCamera = false
            builderResult.camera = nil
            return self
          }
          public var hasPlayerLevel:Bool {
               get {
                   return builderResult.hasPlayerLevel
               }
          }
          public var playerLevel:Pogoprotos.Settings.Master.PlayerLevelSettings! {
               get {
                   if playerLevelBuilder_ != nil {
                      builderResult.playerLevel = playerLevelBuilder_.getMessage()
                   }
                   return builderResult.playerLevel
               }
               set (value) {
                   builderResult.hasPlayerLevel = true
                   builderResult.playerLevel = value
               }
          }
          private var playerLevelBuilder_:Pogoprotos.Settings.Master.PlayerLevelSettings.Builder! {
               didSet {
                  builderResult.hasPlayerLevel = true
               }
          }
          public func getPlayerLevelBuilder() -> Pogoprotos.Settings.Master.PlayerLevelSettings.Builder {
            if playerLevelBuilder_ == nil {
               playerLevelBuilder_ = Pogoprotos.Settings.Master.PlayerLevelSettings.Builder()
               builderResult.playerLevel = playerLevelBuilder_.getMessage()
               if playerLevel != nil {
                  try! playerLevelBuilder_.mergeFrom(playerLevel)
               }
            }
            return playerLevelBuilder_
          }
          public func setPlayerLevel(value:Pogoprotos.Settings.Master.PlayerLevelSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.playerLevel = value
            return self
          }
          public func mergePlayerLevel(value:Pogoprotos.Settings.Master.PlayerLevelSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPlayerLevel {
              builderResult.playerLevel = try Pogoprotos.Settings.Master.PlayerLevelSettings.builderWithPrototype(builderResult.playerLevel).mergeFrom(value).buildPartial()
            } else {
              builderResult.playerLevel = value
            }
            builderResult.hasPlayerLevel = true
            return self
          }
          public func clearPlayerLevel() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            playerLevelBuilder_ = nil
            builderResult.hasPlayerLevel = false
            builderResult.playerLevel = nil
            return self
          }
          public var hasGymLevel:Bool {
               get {
                   return builderResult.hasGymLevel
               }
          }
          public var gymLevel:Pogoprotos.Settings.Master.GymLevelSettings! {
               get {
                   if gymLevelBuilder_ != nil {
                      builderResult.gymLevel = gymLevelBuilder_.getMessage()
                   }
                   return builderResult.gymLevel
               }
               set (value) {
                   builderResult.hasGymLevel = true
                   builderResult.gymLevel = value
               }
          }
          private var gymLevelBuilder_:Pogoprotos.Settings.Master.GymLevelSettings.Builder! {
               didSet {
                  builderResult.hasGymLevel = true
               }
          }
          public func getGymLevelBuilder() -> Pogoprotos.Settings.Master.GymLevelSettings.Builder {
            if gymLevelBuilder_ == nil {
               gymLevelBuilder_ = Pogoprotos.Settings.Master.GymLevelSettings.Builder()
               builderResult.gymLevel = gymLevelBuilder_.getMessage()
               if gymLevel != nil {
                  try! gymLevelBuilder_.mergeFrom(gymLevel)
               }
            }
            return gymLevelBuilder_
          }
          public func setGymLevel(value:Pogoprotos.Settings.Master.GymLevelSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.gymLevel = value
            return self
          }
          public func mergeGymLevel(value:Pogoprotos.Settings.Master.GymLevelSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasGymLevel {
              builderResult.gymLevel = try Pogoprotos.Settings.Master.GymLevelSettings.builderWithPrototype(builderResult.gymLevel).mergeFrom(value).buildPartial()
            } else {
              builderResult.gymLevel = value
            }
            builderResult.hasGymLevel = true
            return self
          }
          public func clearGymLevel() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            gymLevelBuilder_ = nil
            builderResult.hasGymLevel = false
            builderResult.gymLevel = nil
            return self
          }
          public var hasBattleSettings:Bool {
               get {
                   return builderResult.hasBattleSettings
               }
          }
          public var battleSettings:Pogoprotos.Settings.Master.GymBattleSettings! {
               get {
                   if battleSettingsBuilder_ != nil {
                      builderResult.battleSettings = battleSettingsBuilder_.getMessage()
                   }
                   return builderResult.battleSettings
               }
               set (value) {
                   builderResult.hasBattleSettings = true
                   builderResult.battleSettings = value
               }
          }
          private var battleSettingsBuilder_:Pogoprotos.Settings.Master.GymBattleSettings.Builder! {
               didSet {
                  builderResult.hasBattleSettings = true
               }
          }
          public func getBattleSettingsBuilder() -> Pogoprotos.Settings.Master.GymBattleSettings.Builder {
            if battleSettingsBuilder_ == nil {
               battleSettingsBuilder_ = Pogoprotos.Settings.Master.GymBattleSettings.Builder()
               builderResult.battleSettings = battleSettingsBuilder_.getMessage()
               if battleSettings != nil {
                  try! battleSettingsBuilder_.mergeFrom(battleSettings)
               }
            }
            return battleSettingsBuilder_
          }
          public func setBattleSettings(value:Pogoprotos.Settings.Master.GymBattleSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.battleSettings = value
            return self
          }
          public func mergeBattleSettings(value:Pogoprotos.Settings.Master.GymBattleSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasBattleSettings {
              builderResult.battleSettings = try Pogoprotos.Settings.Master.GymBattleSettings.builderWithPrototype(builderResult.battleSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.battleSettings = value
            }
            builderResult.hasBattleSettings = true
            return self
          }
          public func clearBattleSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            battleSettingsBuilder_ = nil
            builderResult.hasBattleSettings = false
            builderResult.battleSettings = nil
            return self
          }
          public var hasEncounterSettings:Bool {
               get {
                   return builderResult.hasEncounterSettings
               }
          }
          public var encounterSettings:Pogoprotos.Settings.Master.EncounterSettings! {
               get {
                   if encounterSettingsBuilder_ != nil {
                      builderResult.encounterSettings = encounterSettingsBuilder_.getMessage()
                   }
                   return builderResult.encounterSettings
               }
               set (value) {
                   builderResult.hasEncounterSettings = true
                   builderResult.encounterSettings = value
               }
          }
          private var encounterSettingsBuilder_:Pogoprotos.Settings.Master.EncounterSettings.Builder! {
               didSet {
                  builderResult.hasEncounterSettings = true
               }
          }
          public func getEncounterSettingsBuilder() -> Pogoprotos.Settings.Master.EncounterSettings.Builder {
            if encounterSettingsBuilder_ == nil {
               encounterSettingsBuilder_ = Pogoprotos.Settings.Master.EncounterSettings.Builder()
               builderResult.encounterSettings = encounterSettingsBuilder_.getMessage()
               if encounterSettings != nil {
                  try! encounterSettingsBuilder_.mergeFrom(encounterSettings)
               }
            }
            return encounterSettingsBuilder_
          }
          public func setEncounterSettings(value:Pogoprotos.Settings.Master.EncounterSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.encounterSettings = value
            return self
          }
          public func mergeEncounterSettings(value:Pogoprotos.Settings.Master.EncounterSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasEncounterSettings {
              builderResult.encounterSettings = try Pogoprotos.Settings.Master.EncounterSettings.builderWithPrototype(builderResult.encounterSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.encounterSettings = value
            }
            builderResult.hasEncounterSettings = true
            return self
          }
          public func clearEncounterSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            encounterSettingsBuilder_ = nil
            builderResult.hasEncounterSettings = false
            builderResult.encounterSettings = nil
            return self
          }
          public var hasIapItemDisplay:Bool {
               get {
                   return builderResult.hasIapItemDisplay
               }
          }
          public var iapItemDisplay:Pogoprotos.Settings.Master.IapItemDisplay! {
               get {
                   if iapItemDisplayBuilder_ != nil {
                      builderResult.iapItemDisplay = iapItemDisplayBuilder_.getMessage()
                   }
                   return builderResult.iapItemDisplay
               }
               set (value) {
                   builderResult.hasIapItemDisplay = true
                   builderResult.iapItemDisplay = value
               }
          }
          private var iapItemDisplayBuilder_:Pogoprotos.Settings.Master.IapItemDisplay.Builder! {
               didSet {
                  builderResult.hasIapItemDisplay = true
               }
          }
          public func getIapItemDisplayBuilder() -> Pogoprotos.Settings.Master.IapItemDisplay.Builder {
            if iapItemDisplayBuilder_ == nil {
               iapItemDisplayBuilder_ = Pogoprotos.Settings.Master.IapItemDisplay.Builder()
               builderResult.iapItemDisplay = iapItemDisplayBuilder_.getMessage()
               if iapItemDisplay != nil {
                  try! iapItemDisplayBuilder_.mergeFrom(iapItemDisplay)
               }
            }
            return iapItemDisplayBuilder_
          }
          public func setIapItemDisplay(value:Pogoprotos.Settings.Master.IapItemDisplay!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.iapItemDisplay = value
            return self
          }
          public func mergeIapItemDisplay(value:Pogoprotos.Settings.Master.IapItemDisplay) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasIapItemDisplay {
              builderResult.iapItemDisplay = try Pogoprotos.Settings.Master.IapItemDisplay.builderWithPrototype(builderResult.iapItemDisplay).mergeFrom(value).buildPartial()
            } else {
              builderResult.iapItemDisplay = value
            }
            builderResult.hasIapItemDisplay = true
            return self
          }
          public func clearIapItemDisplay() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            iapItemDisplayBuilder_ = nil
            builderResult.hasIapItemDisplay = false
            builderResult.iapItemDisplay = nil
            return self
          }
          public var hasIapSettings:Bool {
               get {
                   return builderResult.hasIapSettings
               }
          }
          public var iapSettings:Pogoprotos.Settings.Master.IapSettings! {
               get {
                   if iapSettingsBuilder_ != nil {
                      builderResult.iapSettings = iapSettingsBuilder_.getMessage()
                   }
                   return builderResult.iapSettings
               }
               set (value) {
                   builderResult.hasIapSettings = true
                   builderResult.iapSettings = value
               }
          }
          private var iapSettingsBuilder_:Pogoprotos.Settings.Master.IapSettings.Builder! {
               didSet {
                  builderResult.hasIapSettings = true
               }
          }
          public func getIapSettingsBuilder() -> Pogoprotos.Settings.Master.IapSettings.Builder {
            if iapSettingsBuilder_ == nil {
               iapSettingsBuilder_ = Pogoprotos.Settings.Master.IapSettings.Builder()
               builderResult.iapSettings = iapSettingsBuilder_.getMessage()
               if iapSettings != nil {
                  try! iapSettingsBuilder_.mergeFrom(iapSettings)
               }
            }
            return iapSettingsBuilder_
          }
          public func setIapSettings(value:Pogoprotos.Settings.Master.IapSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.iapSettings = value
            return self
          }
          public func mergeIapSettings(value:Pogoprotos.Settings.Master.IapSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasIapSettings {
              builderResult.iapSettings = try Pogoprotos.Settings.Master.IapSettings.builderWithPrototype(builderResult.iapSettings).mergeFrom(value).buildPartial()
            } else {
              builderResult.iapSettings = value
            }
            builderResult.hasIapSettings = true
            return self
          }
          public func clearIapSettings() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            iapSettingsBuilder_ = nil
            builderResult.hasIapSettings = false
            builderResult.iapSettings = nil
            return self
          }
          public var hasPokemonUpgrades:Bool {
               get {
                   return builderResult.hasPokemonUpgrades
               }
          }
          public var pokemonUpgrades:Pogoprotos.Settings.Master.PokemonUpgradeSettings! {
               get {
                   if pokemonUpgradesBuilder_ != nil {
                      builderResult.pokemonUpgrades = pokemonUpgradesBuilder_.getMessage()
                   }
                   return builderResult.pokemonUpgrades
               }
               set (value) {
                   builderResult.hasPokemonUpgrades = true
                   builderResult.pokemonUpgrades = value
               }
          }
          private var pokemonUpgradesBuilder_:Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder! {
               didSet {
                  builderResult.hasPokemonUpgrades = true
               }
          }
          public func getPokemonUpgradesBuilder() -> Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder {
            if pokemonUpgradesBuilder_ == nil {
               pokemonUpgradesBuilder_ = Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder()
               builderResult.pokemonUpgrades = pokemonUpgradesBuilder_.getMessage()
               if pokemonUpgrades != nil {
                  try! pokemonUpgradesBuilder_.mergeFrom(pokemonUpgrades)
               }
            }
            return pokemonUpgradesBuilder_
          }
          public func setPokemonUpgrades(value:Pogoprotos.Settings.Master.PokemonUpgradeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.pokemonUpgrades = value
            return self
          }
          public func mergePokemonUpgrades(value:Pogoprotos.Settings.Master.PokemonUpgradeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasPokemonUpgrades {
              builderResult.pokemonUpgrades = try Pogoprotos.Settings.Master.PokemonUpgradeSettings.builderWithPrototype(builderResult.pokemonUpgrades).mergeFrom(value).buildPartial()
            } else {
              builderResult.pokemonUpgrades = value
            }
            builderResult.hasPokemonUpgrades = true
            return self
          }
          public func clearPokemonUpgrades() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            pokemonUpgradesBuilder_ = nil
            builderResult.hasPokemonUpgrades = false
            builderResult.pokemonUpgrades = nil
            return self
          }
          public var hasEquippedBadges:Bool {
               get {
                   return builderResult.hasEquippedBadges
               }
          }
          public var equippedBadges:Pogoprotos.Settings.Master.EquippedBadgeSettings! {
               get {
                   if equippedBadgesBuilder_ != nil {
                      builderResult.equippedBadges = equippedBadgesBuilder_.getMessage()
                   }
                   return builderResult.equippedBadges
               }
               set (value) {
                   builderResult.hasEquippedBadges = true
                   builderResult.equippedBadges = value
               }
          }
          private var equippedBadgesBuilder_:Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder! {
               didSet {
                  builderResult.hasEquippedBadges = true
               }
          }
          public func getEquippedBadgesBuilder() -> Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder {
            if equippedBadgesBuilder_ == nil {
               equippedBadgesBuilder_ = Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder()
               builderResult.equippedBadges = equippedBadgesBuilder_.getMessage()
               if equippedBadges != nil {
                  try! equippedBadgesBuilder_.mergeFrom(equippedBadges)
               }
            }
            return equippedBadgesBuilder_
          }
          public func setEquippedBadges(value:Pogoprotos.Settings.Master.EquippedBadgeSettings!) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            self.equippedBadges = value
            return self
          }
          public func mergeEquippedBadges(value:Pogoprotos.Settings.Master.EquippedBadgeSettings) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if builderResult.hasEquippedBadges {
              builderResult.equippedBadges = try Pogoprotos.Settings.Master.EquippedBadgeSettings.builderWithPrototype(builderResult.equippedBadges).mergeFrom(value).buildPartial()
            } else {
              builderResult.equippedBadges = value
            }
            builderResult.hasEquippedBadges = true
            return self
          }
          public func clearEquippedBadges() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            equippedBadgesBuilder_ = nil
            builderResult.hasEquippedBadges = false
            builderResult.equippedBadges = nil
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          override public func clear() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            builderResult = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate()
            return self
          }
          override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.builderWithPrototype(builderResult)
          }
          override public func build() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate {
            let returnMe:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate = builderResult
            return returnMe
          }
          public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            if other == Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate() {
             return self
            }
            if other.hasTemplateId {
                 templateId = other.templateId
            }
            if (other.hasPokemonSettings) {
                try mergePokemonSettings(other.pokemonSettings)
            }
            if (other.hasItemSettings) {
                try mergeItemSettings(other.itemSettings)
            }
            if (other.hasMoveSettings) {
                try mergeMoveSettings(other.moveSettings)
            }
            if (other.hasMoveSequenceSettings) {
                try mergeMoveSequenceSettings(other.moveSequenceSettings)
            }
            if (other.hasTypeEffective) {
                try mergeTypeEffective(other.typeEffective)
            }
            if (other.hasBadgeSettings) {
                try mergeBadgeSettings(other.badgeSettings)
            }
            if (other.hasCamera) {
                try mergeCamera(other.camera)
            }
            if (other.hasPlayerLevel) {
                try mergePlayerLevel(other.playerLevel)
            }
            if (other.hasGymLevel) {
                try mergeGymLevel(other.gymLevel)
            }
            if (other.hasBattleSettings) {
                try mergeBattleSettings(other.battleSettings)
            }
            if (other.hasEncounterSettings) {
                try mergeEncounterSettings(other.encounterSettings)
            }
            if (other.hasIapItemDisplay) {
                try mergeIapItemDisplay(other.iapItemDisplay)
            }
            if (other.hasIapSettings) {
                try mergeIapSettings(other.iapSettings)
            }
            if (other.hasPokemonUpgrades) {
                try mergePokemonUpgrades(other.pokemonUpgrades)
            }
            if (other.hasEquippedBadges) {
                try mergeEquippedBadges(other.equippedBadges)
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let protobufTag = try input.readTag()
              switch protobufTag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 10:
                templateId = try input.readString()

              case 18:
                let subBuilder:Pogoprotos.Settings.Master.PokemonSettings.Builder = Pogoprotos.Settings.Master.PokemonSettings.Builder()
                if hasPokemonSettings {
                  try subBuilder.mergeFrom(pokemonSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                pokemonSettings = subBuilder.buildPartial()

              case 26:
                let subBuilder:Pogoprotos.Settings.Master.ItemSettings.Builder = Pogoprotos.Settings.Master.ItemSettings.Builder()
                if hasItemSettings {
                  try subBuilder.mergeFrom(itemSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                itemSettings = subBuilder.buildPartial()

              case 34:
                let subBuilder:Pogoprotos.Settings.Master.MoveSettings.Builder = Pogoprotos.Settings.Master.MoveSettings.Builder()
                if hasMoveSettings {
                  try subBuilder.mergeFrom(moveSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                moveSettings = subBuilder.buildPartial()

              case 42:
                let subBuilder:Pogoprotos.Settings.Master.MoveSequenceSettings.Builder = Pogoprotos.Settings.Master.MoveSequenceSettings.Builder()
                if hasMoveSequenceSettings {
                  try subBuilder.mergeFrom(moveSequenceSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                moveSequenceSettings = subBuilder.buildPartial()

              case 66:
                let subBuilder:Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder = Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder()
                if hasTypeEffective {
                  try subBuilder.mergeFrom(typeEffective)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                typeEffective = subBuilder.buildPartial()

              case 82:
                let subBuilder:Pogoprotos.Settings.Master.BadgeSettings.Builder = Pogoprotos.Settings.Master.BadgeSettings.Builder()
                if hasBadgeSettings {
                  try subBuilder.mergeFrom(badgeSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                badgeSettings = subBuilder.buildPartial()

              case 90:
                let subBuilder:Pogoprotos.Settings.Master.CameraSettings.Builder = Pogoprotos.Settings.Master.CameraSettings.Builder()
                if hasCamera {
                  try subBuilder.mergeFrom(camera)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                camera = subBuilder.buildPartial()

              case 98:
                let subBuilder:Pogoprotos.Settings.Master.PlayerLevelSettings.Builder = Pogoprotos.Settings.Master.PlayerLevelSettings.Builder()
                if hasPlayerLevel {
                  try subBuilder.mergeFrom(playerLevel)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                playerLevel = subBuilder.buildPartial()

              case 106:
                let subBuilder:Pogoprotos.Settings.Master.GymLevelSettings.Builder = Pogoprotos.Settings.Master.GymLevelSettings.Builder()
                if hasGymLevel {
                  try subBuilder.mergeFrom(gymLevel)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                gymLevel = subBuilder.buildPartial()

              case 114:
                let subBuilder:Pogoprotos.Settings.Master.GymBattleSettings.Builder = Pogoprotos.Settings.Master.GymBattleSettings.Builder()
                if hasBattleSettings {
                  try subBuilder.mergeFrom(battleSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                battleSettings = subBuilder.buildPartial()

              case 122:
                let subBuilder:Pogoprotos.Settings.Master.EncounterSettings.Builder = Pogoprotos.Settings.Master.EncounterSettings.Builder()
                if hasEncounterSettings {
                  try subBuilder.mergeFrom(encounterSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                encounterSettings = subBuilder.buildPartial()

              case 130:
                let subBuilder:Pogoprotos.Settings.Master.IapItemDisplay.Builder = Pogoprotos.Settings.Master.IapItemDisplay.Builder()
                if hasIapItemDisplay {
                  try subBuilder.mergeFrom(iapItemDisplay)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                iapItemDisplay = subBuilder.buildPartial()

              case 138:
                let subBuilder:Pogoprotos.Settings.Master.IapSettings.Builder = Pogoprotos.Settings.Master.IapSettings.Builder()
                if hasIapSettings {
                  try subBuilder.mergeFrom(iapSettings)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                iapSettings = subBuilder.buildPartial()

              case 146:
                let subBuilder:Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder = Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder()
                if hasPokemonUpgrades {
                  try subBuilder.mergeFrom(pokemonUpgrades)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                pokemonUpgrades = subBuilder.buildPartial()

              case 154:
                let subBuilder:Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder = Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder()
                if hasEquippedBadges {
                  try subBuilder.mergeFrom(equippedBadges)
                }
                try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                equippedBadges = subBuilder.buildPartial()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
          override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
            if let jsonValueTemplateId = jsonMap["templateId"] as? String {
              resultDecodedBuilder.templateId = jsonValueTemplateId
            }
            if let jsonValuePokemonSettings = jsonMap["pokemonSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.pokemonSettings = try Pogoprotos.Settings.Master.PokemonSettings.Builder.decodeToBuilder(jsonValuePokemonSettings).build()

            }
            if let jsonValueItemSettings = jsonMap["itemSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.itemSettings = try Pogoprotos.Settings.Master.ItemSettings.Builder.decodeToBuilder(jsonValueItemSettings).build()

            }
            if let jsonValueMoveSettings = jsonMap["moveSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.moveSettings = try Pogoprotos.Settings.Master.MoveSettings.Builder.decodeToBuilder(jsonValueMoveSettings).build()

            }
            if let jsonValueMoveSequenceSettings = jsonMap["moveSequenceSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.moveSequenceSettings = try Pogoprotos.Settings.Master.MoveSequenceSettings.Builder.decodeToBuilder(jsonValueMoveSequenceSettings).build()

            }
            if let jsonValueTypeEffective = jsonMap["typeEffective"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.typeEffective = try Pogoprotos.Settings.Master.TypeEffectiveSettings.Builder.decodeToBuilder(jsonValueTypeEffective).build()

            }
            if let jsonValueBadgeSettings = jsonMap["badgeSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.badgeSettings = try Pogoprotos.Settings.Master.BadgeSettings.Builder.decodeToBuilder(jsonValueBadgeSettings).build()

            }
            if let jsonValueCamera = jsonMap["camera"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.camera = try Pogoprotos.Settings.Master.CameraSettings.Builder.decodeToBuilder(jsonValueCamera).build()

            }
            if let jsonValuePlayerLevel = jsonMap["playerLevel"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.playerLevel = try Pogoprotos.Settings.Master.PlayerLevelSettings.Builder.decodeToBuilder(jsonValuePlayerLevel).build()

            }
            if let jsonValueGymLevel = jsonMap["gymLevel"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.gymLevel = try Pogoprotos.Settings.Master.GymLevelSettings.Builder.decodeToBuilder(jsonValueGymLevel).build()

            }
            if let jsonValueBattleSettings = jsonMap["battleSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.battleSettings = try Pogoprotos.Settings.Master.GymBattleSettings.Builder.decodeToBuilder(jsonValueBattleSettings).build()

            }
            if let jsonValueEncounterSettings = jsonMap["encounterSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.encounterSettings = try Pogoprotos.Settings.Master.EncounterSettings.Builder.decodeToBuilder(jsonValueEncounterSettings).build()

            }
            if let jsonValueIapItemDisplay = jsonMap["iapItemDisplay"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.iapItemDisplay = try Pogoprotos.Settings.Master.IapItemDisplay.Builder.decodeToBuilder(jsonValueIapItemDisplay).build()

            }
            if let jsonValueIapSettings = jsonMap["iapSettings"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.iapSettings = try Pogoprotos.Settings.Master.IapSettings.Builder.decodeToBuilder(jsonValueIapSettings).build()

            }
            if let jsonValuePokemonUpgrades = jsonMap["pokemonUpgrades"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.pokemonUpgrades = try Pogoprotos.Settings.Master.PokemonUpgradeSettings.Builder.decodeToBuilder(jsonValuePokemonUpgrades).build()

            }
            if let jsonValueEquippedBadges = jsonMap["equippedBadges"] as? Dictionary<String,AnyObject> {
              resultDecodedBuilder.equippedBadges = try Pogoprotos.Settings.Master.EquippedBadgeSettings.Builder.decodeToBuilder(jsonValueEquippedBadges).build()

            }
            return resultDecodedBuilder
          }
          override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder {
            let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
              throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
            }
            return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(jsDataCast)
          }
        }

      }

    //Nested type declaration end

    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var itemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>  = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>()
    public private(set) var hasTimestampMs:Bool = false
    public private(set) var timestampMs:UInt64 = UInt64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      for oneElementItemTemplates in itemTemplates {
          try output.writeMessage(2, value:oneElementItemTemplates)
      }
      if hasTimestampMs {
        try output.writeUInt64(3, value:timestampMs)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      for oneElementItemTemplates in itemTemplates {
          serialize_size += oneElementItemTemplates.computeMessageSize(2)
      }
      if hasTimestampMs {
        serialize_size += timestampMs.computeUInt64Size(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse? {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !itemTemplates.isEmpty {
        var jsonArrayItemTemplates:Array<Dictionary<String,AnyObject>> = []
          for oneValueItemTemplates in itemTemplates {
            let ecodedMessageItemTemplates = try oneValueItemTemplates.encode()
            jsonArrayItemTemplates += [ecodedMessageItemTemplates]
          }
        jsonMap["itemTemplates"] = jsonArrayItemTemplates
      }
      if hasTimestampMs {
        jsonMap["timestampMs"] = "\(timestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
      return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var itemTemplatesElementIndex:Int = 0
      for oneElementItemTemplates in itemTemplates {
          output += "\(indent) itemTemplates[\(itemTemplatesElementIndex)] {\n"
          output += try oneElementItemTemplates.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          itemTemplatesElementIndex += 1
      }
      if hasTimestampMs {
        output += "\(indent) timestampMs: \(timestampMs) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneElementItemTemplates in itemTemplates {
                hashCode = (hashCode &* 31) &+ oneElementItemTemplates.hashValue
            }
            if hasTimestampMs {
               hashCode = (hashCode &* 31) &+ timestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var itemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> {
           get {
               return builderResult.itemTemplates
           }
           set (value) {
               builderResult.itemTemplates = value
           }
      }
      public func setItemTemplates(value:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate>) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.itemTemplates = value
        return self
      }
      public func clearItemTemplates() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        builderResult.itemTemplates.removeAll(keepCapacity: false)
        return self
      }
      public var hasTimestampMs:Bool {
           get {
                return builderResult.hasTimestampMs
           }
      }
      public var timestampMs:UInt64 {
           get {
                return builderResult.timestampMs
           }
           set (value) {
               builderResult.hasTimestampMs = true
               builderResult.timestampMs = value
           }
      }
      public func setTimestampMs(value:UInt64) -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        self.timestampMs = value
        return self
      }
      public func clearTimestampMs() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder{
           builderResult.hasTimestampMs = false
           builderResult.timestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.itemTemplates.isEmpty  {
           builderResult.itemTemplates += other.itemTemplates
        }
        if other.hasTimestampMs {
             timestampMs = other.timestampMs
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 18:
            let subBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            itemTemplates += [subBuilder.buildPartial()]

          case 24:
            timestampMs = try input.readUInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueItemTemplates = jsonMap["itemTemplates"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayItemTemplates:Array<Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate> = []
          for oneValueItemTemplates in jsonValueItemTemplates {
            let messageFromStringItemTemplates = try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.ItemTemplate.Builder.decodeToBuilder(oneValueItemTemplates).build()

            jsonArrayItemTemplates += [messageFromStringItemTemplates]
          }
          resultDecodedBuilder.itemTemplates = jsonArrayItemTemplates
        }
        if let jsonValueTimestampMs = jsonMap["timestampMs"] as? String {
          resultDecodedBuilder.timestampMs = UInt64(jsonValueTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadItemTemplatesResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class DownloadRemoteConfigVersionResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    // Latest available?
    public private(set) var hasItemTemplatesTimestampMs:Bool = false
    public private(set) var itemTemplatesTimestampMs:UInt64 = UInt64(0)

    public private(set) var hasAssetDigestTimestampMs:Bool = false
    public private(set) var assetDigestTimestampMs:UInt64 = UInt64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasItemTemplatesTimestampMs {
        try output.writeUInt64(2, value:itemTemplatesTimestampMs)
      }
      if hasAssetDigestTimestampMs {
        try output.writeUInt64(3, value:assetDigestTimestampMs)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasItemTemplatesTimestampMs {
        serialize_size += itemTemplatesTimestampMs.computeUInt64Size(2)
      }
      if hasAssetDigestTimestampMs {
        serialize_size += assetDigestTimestampMs.computeUInt64Size(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse? {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasItemTemplatesTimestampMs {
        jsonMap["itemTemplatesTimestampMs"] = "\(itemTemplatesTimestampMs)"
      }
      if hasAssetDigestTimestampMs {
        jsonMap["assetDigestTimestampMs"] = "\(assetDigestTimestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
      return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasItemTemplatesTimestampMs {
        output += "\(indent) itemTemplatesTimestampMs: \(itemTemplatesTimestampMs) \n"
      }
      if hasAssetDigestTimestampMs {
        output += "\(indent) assetDigestTimestampMs: \(assetDigestTimestampMs) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasItemTemplatesTimestampMs {
               hashCode = (hashCode &* 31) &+ itemTemplatesTimestampMs.hashValue
            }
            if hasAssetDigestTimestampMs {
               hashCode = (hashCode &* 31) &+ assetDigestTimestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasItemTemplatesTimestampMs:Bool {
           get {
                return builderResult.hasItemTemplatesTimestampMs
           }
      }
      public var itemTemplatesTimestampMs:UInt64 {
           get {
                return builderResult.itemTemplatesTimestampMs
           }
           set (value) {
               builderResult.hasItemTemplatesTimestampMs = true
               builderResult.itemTemplatesTimestampMs = value
           }
      }
      public func setItemTemplatesTimestampMs(value:UInt64) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        self.itemTemplatesTimestampMs = value
        return self
      }
      public func clearItemTemplatesTimestampMs() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder{
           builderResult.hasItemTemplatesTimestampMs = false
           builderResult.itemTemplatesTimestampMs = UInt64(0)
           return self
      }
      public var hasAssetDigestTimestampMs:Bool {
           get {
                return builderResult.hasAssetDigestTimestampMs
           }
      }
      public var assetDigestTimestampMs:UInt64 {
           get {
                return builderResult.assetDigestTimestampMs
           }
           set (value) {
               builderResult.hasAssetDigestTimestampMs = true
               builderResult.assetDigestTimestampMs = value
           }
      }
      public func setAssetDigestTimestampMs(value:UInt64) -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        self.assetDigestTimestampMs = value
        return self
      }
      public func clearAssetDigestTimestampMs() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder{
           builderResult.hasAssetDigestTimestampMs = false
           builderResult.assetDigestTimestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasItemTemplatesTimestampMs {
             itemTemplatesTimestampMs = other.itemTemplatesTimestampMs
        }
        if other.hasAssetDigestTimestampMs {
             assetDigestTimestampMs = other.assetDigestTimestampMs
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            itemTemplatesTimestampMs = try input.readUInt64()

          case 24:
            assetDigestTimestampMs = try input.readUInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueItemTemplatesTimestampMs = jsonMap["itemTemplatesTimestampMs"] as? String {
          resultDecodedBuilder.itemTemplatesTimestampMs = UInt64(jsonValueItemTemplatesTimestampMs)!
        }
        if let jsonValueAssetDigestTimestampMs = jsonMap["assetDigestTimestampMs"] as? String {
          resultDecodedBuilder.assetDigestTimestampMs = UInt64(jsonValueAssetDigestTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadRemoteConfigVersionResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class DownloadSettingsResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasError:Bool = false
    public private(set) var error:String = ""

    public private(set) var hasHash:Bool = false
    public private(set) var hash:String = ""

    public private(set) var hasSettings:Bool = false
    public private(set) var settings:Pogoprotos.Settings.GlobalSettings!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasError {
        try output.writeString(1, value:error)
      }
      if hasHash {
        try output.writeString(2, value:hash)
      }
      if hasSettings {
        try output.writeMessage(3, value:settings)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasError {
        serialize_size += error.computeStringSize(1)
      }
      if hasHash {
        serialize_size += hash.computeStringSize(2)
      }
      if hasSettings {
          if let varSizesettings = settings?.computeMessageSize(3) {
              serialize_size += varSizesettings
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.DownloadSettingsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.DownloadSettingsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse? {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.classBuilder() as! Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.DownloadSettingsResponse) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasError {
        jsonMap["error"] = error
      }
      if hasHash {
        jsonMap["hash"] = hash
      }
      if hasSettings {
        jsonMap["settings"] = try settings.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
      return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasError {
        output += "\(indent) error: \(error) \n"
      }
      if hasHash {
        output += "\(indent) hash: \(hash) \n"
      }
      if hasSettings {
        output += "\(indent) settings {\n"
        if let outDescSettings = settings {
          output += try outDescSettings.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasError {
               hashCode = (hashCode &* 31) &+ error.hashValue
            }
            if hasHash {
               hashCode = (hashCode &* 31) &+ hash.hashValue
            }
            if hasSettings {
                if let hashValuesettings = settings?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesettings
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadSettingsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.DownloadSettingsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.DownloadSettingsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.DownloadSettingsResponse = Pogoprotos.Networking.Responses.DownloadSettingsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasError:Bool {
           get {
                return builderResult.hasError
           }
      }
      public var error:String {
           get {
                return builderResult.error
           }
           set (value) {
               builderResult.hasError = true
               builderResult.error = value
           }
      }
      public func setError(value:String) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.error = value
        return self
      }
      public func clearError() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder{
           builderResult.hasError = false
           builderResult.error = ""
           return self
      }
      public var hasHash:Bool {
           get {
                return builderResult.hasHash
           }
      }
      public var hash:String {
           get {
                return builderResult.hash
           }
           set (value) {
               builderResult.hasHash = true
               builderResult.hash = value
           }
      }
      public func setHash(value:String) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.hash = value
        return self
      }
      public func clearHash() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder{
           builderResult.hasHash = false
           builderResult.hash = ""
           return self
      }
      public var hasSettings:Bool {
           get {
               return builderResult.hasSettings
           }
      }
      public var settings:Pogoprotos.Settings.GlobalSettings! {
           get {
               if settingsBuilder_ != nil {
                  builderResult.settings = settingsBuilder_.getMessage()
               }
               return builderResult.settings
           }
           set (value) {
               builderResult.hasSettings = true
               builderResult.settings = value
           }
      }
      private var settingsBuilder_:Pogoprotos.Settings.GlobalSettings.Builder! {
           didSet {
              builderResult.hasSettings = true
           }
      }
      public func getSettingsBuilder() -> Pogoprotos.Settings.GlobalSettings.Builder {
        if settingsBuilder_ == nil {
           settingsBuilder_ = Pogoprotos.Settings.GlobalSettings.Builder()
           builderResult.settings = settingsBuilder_.getMessage()
           if settings != nil {
              try! settingsBuilder_.mergeFrom(settings)
           }
        }
        return settingsBuilder_
      }
      public func setSettings(value:Pogoprotos.Settings.GlobalSettings!) -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        self.settings = value
        return self
      }
      public func mergeSettings(value:Pogoprotos.Settings.GlobalSettings) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        if builderResult.hasSettings {
          builderResult.settings = try Pogoprotos.Settings.GlobalSettings.builderWithPrototype(builderResult.settings).mergeFrom(value).buildPartial()
        } else {
          builderResult.settings = value
        }
        builderResult.hasSettings = true
        return self
      }
      public func clearSettings() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        settingsBuilder_ = nil
        builderResult.hasSettings = false
        builderResult.settings = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.DownloadSettingsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.DownloadSettingsResponse {
        let returnMe:Pogoprotos.Networking.Responses.DownloadSettingsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.DownloadSettingsResponse) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.DownloadSettingsResponse() {
         return self
        }
        if other.hasError {
             error = other.error
        }
        if other.hasHash {
             hash = other.hash
        }
        if (other.hasSettings) {
            try mergeSettings(other.settings)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            error = try input.readString()

          case 18:
            hash = try input.readString()

          case 26:
            let subBuilder:Pogoprotos.Settings.GlobalSettings.Builder = Pogoprotos.Settings.GlobalSettings.Builder()
            if hasSettings {
              try subBuilder.mergeFrom(settings)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            settings = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder()
        if let jsonValueError = jsonMap["error"] as? String {
          resultDecodedBuilder.error = jsonValueError
        }
        if let jsonValueHash = jsonMap["hash"] as? String {
          resultDecodedBuilder.hash = jsonValueHash
        }
        if let jsonValueSettings = jsonMap["settings"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.settings = try Pogoprotos.Settings.GlobalSettings.Builder.decodeToBuilder(jsonValueSettings).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.DownloadSettingsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EchoResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasContext:Bool = false
    public private(set) var context:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasContext {
        try output.writeString(1, value:context)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasContext {
        serialize_size += context.computeStringSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.EchoResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.EchoResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse? {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return Pogoprotos.Networking.Responses.EchoResponse.classBuilder() as! Pogoprotos.Networking.Responses.EchoResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EchoResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EchoResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EchoResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return try Pogoprotos.Networking.Responses.EchoResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EchoResponse) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasContext {
        jsonMap["context"] = context
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.EchoResponse {
      return try Pogoprotos.Networking.Responses.EchoResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasContext {
        output += "\(indent) context: \(context) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasContext {
               hashCode = (hashCode &* 31) &+ context.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EchoResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EchoResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.EchoResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.EchoResponse = Pogoprotos.Networking.Responses.EchoResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EchoResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasContext:Bool {
           get {
                return builderResult.hasContext
           }
      }
      public var context:String {
           get {
                return builderResult.context
           }
           set (value) {
               builderResult.hasContext = true
               builderResult.context = value
           }
      }
      public func setContext(value:String) -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        self.context = value
        return self
      }
      public func clearContext() -> Pogoprotos.Networking.Responses.EchoResponse.Builder{
           builderResult.hasContext = false
           builderResult.context = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EchoResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        return try Pogoprotos.Networking.Responses.EchoResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EchoResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EchoResponse {
        let returnMe:Pogoprotos.Networking.Responses.EchoResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EchoResponse) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EchoResponse() {
         return self
        }
        if other.hasContext {
             context = other.context
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            context = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EchoResponse.Builder()
        if let jsonValueContext = jsonMap["context"] as? String {
          resultDecodedBuilder.context = jsonValueContext
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.EchoResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EchoResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EncounterResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Background:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Park = 0
        case Desert = 1
        public func toString() -> String {
          switch self {
          case .Park: return "PARK"
          case .Desert: return "DESERT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Background {
          switch str {
          case "PARK":  return .Park
          case "DESERT":  return .Desert
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Park: return ".Park"
                case .Desert: return ".Desert"
            }
        }
      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case EncounterError = 0
        case EncounterSuccess = 1
        case EncounterNotFound = 2
        case EncounterClosed = 3
        case EncounterPokemonFled = 4
        case EncounterNotInRange = 5
        case EncounterAlreadyHappened = 6
        case PokemonInventoryFull = 7
        public func toString() -> String {
          switch self {
          case .EncounterError: return "ENCOUNTER_ERROR"
          case .EncounterSuccess: return "ENCOUNTER_SUCCESS"
          case .EncounterNotFound: return "ENCOUNTER_NOT_FOUND"
          case .EncounterClosed: return "ENCOUNTER_CLOSED"
          case .EncounterPokemonFled: return "ENCOUNTER_POKEMON_FLED"
          case .EncounterNotInRange: return "ENCOUNTER_NOT_IN_RANGE"
          case .EncounterAlreadyHappened: return "ENCOUNTER_ALREADY_HAPPENED"
          case .PokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Status {
          switch str {
          case "ENCOUNTER_ERROR":  return .EncounterError
          case "ENCOUNTER_SUCCESS":  return .EncounterSuccess
          case "ENCOUNTER_NOT_FOUND":  return .EncounterNotFound
          case "ENCOUNTER_CLOSED":  return .EncounterClosed
          case "ENCOUNTER_POKEMON_FLED":  return .EncounterPokemonFled
          case "ENCOUNTER_NOT_IN_RANGE":  return .EncounterNotInRange
          case "ENCOUNTER_ALREADY_HAPPENED":  return .EncounterAlreadyHappened
          case "POKEMON_INVENTORY_FULL":  return .PokemonInventoryFull
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .EncounterError: return ".EncounterError"
                case .EncounterSuccess: return ".EncounterSuccess"
                case .EncounterNotFound: return ".EncounterNotFound"
                case .EncounterClosed: return ".EncounterClosed"
                case .EncounterPokemonFled: return ".EncounterPokemonFled"
                case .EncounterNotInRange: return ".EncounterNotInRange"
                case .EncounterAlreadyHappened: return ".EncounterAlreadyHappened"
                case .PokemonInventoryFull: return ".PokemonInventoryFull"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasWildPokemon:Bool = false
    public private(set) var wildPokemon:Pogoprotos.Map.Pokemon.WildPokemon!
    public private(set) var background:Pogoprotos.Networking.Responses.EncounterResponse.Background = Pogoprotos.Networking.Responses.EncounterResponse.Background.Park
    public private(set) var hasBackground:Bool = false
    public private(set) var status:Pogoprotos.Networking.Responses.EncounterResponse.Status = Pogoprotos.Networking.Responses.EncounterResponse.Status.EncounterError
    public private(set) var hasStatus:Bool = false
    public private(set) var hasCaptureProbability:Bool = false
    public private(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasWildPokemon {
        try output.writeMessage(1, value:wildPokemon)
      }
      if hasBackground {
        try output.writeEnum(2, value:background.rawValue)
      }
      if hasStatus {
        try output.writeEnum(3, value:status.rawValue)
      }
      if hasCaptureProbability {
        try output.writeMessage(4, value:captureProbability)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasWildPokemon {
          if let varSizewildPokemon = wildPokemon?.computeMessageSize(1) {
              serialize_size += varSizewildPokemon
          }
      }
      if (hasBackground) {
        serialize_size += background.rawValue.computeEnumSize(2)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(3)
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(4) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.EncounterResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.EncounterResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse? {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.EncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.EncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EncounterResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EncounterResponse) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasWildPokemon {
        jsonMap["wildPokemon"] = try wildPokemon.encode()
      }
      if hasBackground {
        jsonMap["background"] = background.toString()
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterResponse {
      return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasWildPokemon {
        output += "\(indent) wildPokemon {\n"
        if let outDescWildPokemon = wildPokemon {
          output += try outDescWildPokemon.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if (hasBackground) {
        output += "\(indent) background: \(background.description)\n"
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWildPokemon {
                if let hashValuewildPokemon = wildPokemon?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuewildPokemon
                }
            }
            if hasBackground {
               hashCode = (hashCode &* 31) &+ Int(background.rawValue)
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.EncounterResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.EncounterResponse = Pogoprotos.Networking.Responses.EncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasWildPokemon:Bool {
           get {
               return builderResult.hasWildPokemon
           }
      }
      public var wildPokemon:Pogoprotos.Map.Pokemon.WildPokemon! {
           get {
               if wildPokemonBuilder_ != nil {
                  builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
               }
               return builderResult.wildPokemon
           }
           set (value) {
               builderResult.hasWildPokemon = true
               builderResult.wildPokemon = value
           }
      }
      private var wildPokemonBuilder_:Pogoprotos.Map.Pokemon.WildPokemon.Builder! {
           didSet {
              builderResult.hasWildPokemon = true
           }
      }
      public func getWildPokemonBuilder() -> Pogoprotos.Map.Pokemon.WildPokemon.Builder {
        if wildPokemonBuilder_ == nil {
           wildPokemonBuilder_ = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
           builderResult.wildPokemon = wildPokemonBuilder_.getMessage()
           if wildPokemon != nil {
              try! wildPokemonBuilder_.mergeFrom(wildPokemon)
           }
        }
        return wildPokemonBuilder_
      }
      public func setWildPokemon(value:Pogoprotos.Map.Pokemon.WildPokemon!) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        self.wildPokemon = value
        return self
      }
      public func mergeWildPokemon(value:Pogoprotos.Map.Pokemon.WildPokemon) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if builderResult.hasWildPokemon {
          builderResult.wildPokemon = try Pogoprotos.Map.Pokemon.WildPokemon.builderWithPrototype(builderResult.wildPokemon).mergeFrom(value).buildPartial()
        } else {
          builderResult.wildPokemon = value
        }
        builderResult.hasWildPokemon = true
        return self
      }
      public func clearWildPokemon() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        wildPokemonBuilder_ = nil
        builderResult.hasWildPokemon = false
        builderResult.wildPokemon = nil
        return self
      }
        public var hasBackground:Bool{
            get {
                return builderResult.hasBackground
            }
        }
        public var background:Pogoprotos.Networking.Responses.EncounterResponse.Background {
            get {
                return builderResult.background
            }
            set (value) {
                builderResult.hasBackground = true
                builderResult.background = value
            }
        }
        public func setBackground(value:Pogoprotos.Networking.Responses.EncounterResponse.Background) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
          self.background = value
          return self
        }
        public func clearBackground() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           builderResult.hasBackground = false
           builderResult.background = .Park
           return self
        }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.EncounterResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.EncounterResponse.Status) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .EncounterError
           return self
        }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      private var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      public func setCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(builderResult.captureProbability).mergeFrom(value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.EncounterResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.EncounterResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EncounterResponse) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EncounterResponse() {
         return self
        }
        if (other.hasWildPokemon) {
            try mergeWildPokemon(other.wildPokemon)
        }
        if other.hasBackground {
             background = other.background
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(other.captureProbability)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Map.Pokemon.WildPokemon.Builder = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
            if hasWildPokemon {
              try subBuilder.mergeFrom(wildPokemon)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            wildPokemon = subBuilder.buildPartial()

          case 16:
            let valueIntbackground = try input.readEnum()
            if let enumsbackground = Pogoprotos.Networking.Responses.EncounterResponse.Background(rawValue:valueIntbackground){
                 background = enumsbackground
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntbackground))
            }

          case 24:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.EncounterResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(3, value:Int64(valueIntstatus))
            }

          case 34:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(captureProbability)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EncounterResponse.Builder()
        if let jsonValueWildPokemon = jsonMap["wildPokemon"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.wildPokemon = try Pogoprotos.Map.Pokemon.WildPokemon.Builder.decodeToBuilder(jsonValueWildPokemon).build()

        }
        if let jsonValueBackground = jsonMap["background"] as? String {
          resultDecodedBuilder.background = try Pogoprotos.Networking.Responses.EncounterResponse.Background.fromString(jsonValueBackground)
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.EncounterResponse.Status.fromString(jsonValueStatus)
        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EncounterResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EncounterTutorialCompleteResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorInvalidPokemon = 2
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorInvalidPokemon: return "ERROR_INVALID_POKEMON"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_INVALID_POKEMON":  return .ErrorInvalidPokemon
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorInvalidPokemon: return ".ErrorInvalidPokemon"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasCaptureAward:Bool = false
    public private(set) var captureAward:Pogoprotos.Data.Capture.CaptureAward!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasPokemonData {
        try output.writeMessage(2, value:pokemonData)
      }
      if hasCaptureAward {
        try output.writeMessage(3, value:captureAward)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureAward {
          if let varSizecaptureAward = captureAward?.computeMessageSize(3) {
              serialize_size += varSizecaptureAward
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse? {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.classBuilder() as! Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureAward {
        jsonMap["captureAward"] = try captureAward.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureAward {
        output += "\(indent) captureAward {\n"
        if let outDescCaptureAward = captureAward {
          output += try outDescCaptureAward.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureAward {
                if let hashValuecaptureAward = captureAward?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureAward
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureAward:Bool {
           get {
               return builderResult.hasCaptureAward
           }
      }
      public var captureAward:Pogoprotos.Data.Capture.CaptureAward! {
           get {
               if captureAwardBuilder_ != nil {
                  builderResult.captureAward = captureAwardBuilder_.getMessage()
               }
               return builderResult.captureAward
           }
           set (value) {
               builderResult.hasCaptureAward = true
               builderResult.captureAward = value
           }
      }
      private var captureAwardBuilder_:Pogoprotos.Data.Capture.CaptureAward.Builder! {
           didSet {
              builderResult.hasCaptureAward = true
           }
      }
      public func getCaptureAwardBuilder() -> Pogoprotos.Data.Capture.CaptureAward.Builder {
        if captureAwardBuilder_ == nil {
           captureAwardBuilder_ = Pogoprotos.Data.Capture.CaptureAward.Builder()
           builderResult.captureAward = captureAwardBuilder_.getMessage()
           if captureAward != nil {
              try! captureAwardBuilder_.mergeFrom(captureAward)
           }
        }
        return captureAwardBuilder_
      }
      public func setCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward!) -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        self.captureAward = value
        return self
      }
      public func mergeCaptureAward(value:Pogoprotos.Data.Capture.CaptureAward) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if builderResult.hasCaptureAward {
          builderResult.captureAward = try Pogoprotos.Data.Capture.CaptureAward.builderWithPrototype(builderResult.captureAward).mergeFrom(value).buildPartial()
        } else {
          builderResult.captureAward = value
        }
        builderResult.hasCaptureAward = true
        return self
      }
      public func clearCaptureAward() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        captureAwardBuilder_ = nil
        builderResult.hasCaptureAward = false
        builderResult.captureAward = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse {
        let returnMe:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if (other.hasCaptureAward) {
            try mergeCaptureAward(other.captureAward)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureAward.Builder = Pogoprotos.Data.Capture.CaptureAward.Builder()
            if hasCaptureAward {
              try subBuilder.mergeFrom(captureAward)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            captureAward = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueCaptureAward = jsonMap["captureAward"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.captureAward = try Pogoprotos.Data.Capture.CaptureAward.Builder.decodeToBuilder(jsonValueCaptureAward).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EncounterTutorialCompleteResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EquipBadgeResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case CooldownActive = 2
        case NotQualified = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .CooldownActive: return "COOLDOWN_ACTIVE"
          case .NotQualified: return "NOT_QUALIFIED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "COOLDOWN_ACTIVE":  return .CooldownActive
          case "NOT_QUALIFIED":  return .NotQualified
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .CooldownActive: return ".CooldownActive"
                case .NotQualified: return ".NotQualified"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result = Pogoprotos.Networking.Responses.EquipBadgeResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasEquipped:Bool = false
    public private(set) var equipped:Pogoprotos.Data.Player.EquippedBadge!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasEquipped {
        try output.writeMessage(2, value:equipped)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasEquipped {
          if let varSizeequipped = equipped?.computeMessageSize(2) {
              serialize_size += varSizeequipped
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.EquipBadgeResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.EquipBadgeResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse? {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.classBuilder() as! Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EquipBadgeResponse) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEquipped {
        jsonMap["equipped"] = try equipped.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
      return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEquipped {
        output += "\(indent) equipped {\n"
        if let outDescEquipped = equipped {
          output += try outDescEquipped.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEquipped {
                if let hashValueequipped = equipped?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueequipped
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EquipBadgeResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EquipBadgeResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.EquipBadgeResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.EquipBadgeResponse = Pogoprotos.Networking.Responses.EquipBadgeResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.EquipBadgeResponse.Result) -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasEquipped:Bool {
           get {
               return builderResult.hasEquipped
           }
      }
      public var equipped:Pogoprotos.Data.Player.EquippedBadge! {
           get {
               if equippedBuilder_ != nil {
                  builderResult.equipped = equippedBuilder_.getMessage()
               }
               return builderResult.equipped
           }
           set (value) {
               builderResult.hasEquipped = true
               builderResult.equipped = value
           }
      }
      private var equippedBuilder_:Pogoprotos.Data.Player.EquippedBadge.Builder! {
           didSet {
              builderResult.hasEquipped = true
           }
      }
      public func getEquippedBuilder() -> Pogoprotos.Data.Player.EquippedBadge.Builder {
        if equippedBuilder_ == nil {
           equippedBuilder_ = Pogoprotos.Data.Player.EquippedBadge.Builder()
           builderResult.equipped = equippedBuilder_.getMessage()
           if equipped != nil {
              try! equippedBuilder_.mergeFrom(equipped)
           }
        }
        return equippedBuilder_
      }
      public func setEquipped(value:Pogoprotos.Data.Player.EquippedBadge!) -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        self.equipped = value
        return self
      }
      public func mergeEquipped(value:Pogoprotos.Data.Player.EquippedBadge) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        if builderResult.hasEquipped {
          builderResult.equipped = try Pogoprotos.Data.Player.EquippedBadge.builderWithPrototype(builderResult.equipped).mergeFrom(value).buildPartial()
        } else {
          builderResult.equipped = value
        }
        builderResult.hasEquipped = true
        return self
      }
      public func clearEquipped() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        equippedBuilder_ = nil
        builderResult.hasEquipped = false
        builderResult.equipped = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EquipBadgeResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        return try Pogoprotos.Networking.Responses.EquipBadgeResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EquipBadgeResponse {
        let returnMe:Pogoprotos.Networking.Responses.EquipBadgeResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EquipBadgeResponse) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EquipBadgeResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEquipped) {
            try mergeEquipped(other.equipped)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EquipBadgeResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.Player.EquippedBadge.Builder = Pogoprotos.Data.Player.EquippedBadge.Builder()
            if hasEquipped {
              try subBuilder.mergeFrom(equipped)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            equipped = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EquipBadgeResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueEquipped = jsonMap["equipped"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.equipped = try Pogoprotos.Data.Player.EquippedBadge.Builder.decodeToBuilder(jsonValueEquipped).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EquipBadgeResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class EvolvePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case FailedPokemonMissing = 2
        case FailedInsufficientResources = 3
        case FailedPokemonCannotEvolve = 4
        case FailedPokemonIsDeployed = 5
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .FailedPokemonMissing: return "FAILED_POKEMON_MISSING"
          case .FailedInsufficientResources: return "FAILED_INSUFFICIENT_RESOURCES"
          case .FailedPokemonCannotEvolve: return "FAILED_POKEMON_CANNOT_EVOLVE"
          case .FailedPokemonIsDeployed: return "FAILED_POKEMON_IS_DEPLOYED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "FAILED_POKEMON_MISSING":  return .FailedPokemonMissing
          case "FAILED_INSUFFICIENT_RESOURCES":  return .FailedInsufficientResources
          case "FAILED_POKEMON_CANNOT_EVOLVE":  return .FailedPokemonCannotEvolve
          case "FAILED_POKEMON_IS_DEPLOYED":  return .FailedPokemonIsDeployed
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .FailedPokemonMissing: return ".FailedPokemonMissing"
                case .FailedInsufficientResources: return ".FailedInsufficientResources"
                case .FailedPokemonCannotEvolve: return ".FailedPokemonCannotEvolve"
                case .FailedPokemonIsDeployed: return ".FailedPokemonIsDeployed"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasEvolvedPokemonData:Bool = false
    public private(set) var evolvedPokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasExperienceAwarded:Bool = false
    public private(set) var experienceAwarded:Int32 = Int32(0)

    public private(set) var hasCandyAwarded:Bool = false
    public private(set) var candyAwarded:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasEvolvedPokemonData {
        try output.writeMessage(2, value:evolvedPokemonData)
      }
      if hasExperienceAwarded {
        try output.writeInt32(3, value:experienceAwarded)
      }
      if hasCandyAwarded {
        try output.writeInt32(4, value:candyAwarded)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasEvolvedPokemonData {
          if let varSizeevolvedPokemonData = evolvedPokemonData?.computeMessageSize(2) {
              serialize_size += varSizeevolvedPokemonData
          }
      }
      if hasExperienceAwarded {
        serialize_size += experienceAwarded.computeInt32Size(3)
      }
      if hasCandyAwarded {
        serialize_size += candyAwarded.computeInt32Size(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.EvolvePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.EvolvePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse? {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.EvolvePokemonResponse) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEvolvedPokemonData {
        jsonMap["evolvedPokemonData"] = try evolvedPokemonData.encode()
      }
      if hasExperienceAwarded {
        jsonMap["experienceAwarded"] = NSNumber(int:experienceAwarded)
      }
      if hasCandyAwarded {
        jsonMap["candyAwarded"] = NSNumber(int:candyAwarded)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
      return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEvolvedPokemonData {
        output += "\(indent) evolvedPokemonData {\n"
        if let outDescEvolvedPokemonData = evolvedPokemonData {
          output += try outDescEvolvedPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasExperienceAwarded {
        output += "\(indent) experienceAwarded: \(experienceAwarded) \n"
      }
      if hasCandyAwarded {
        output += "\(indent) candyAwarded: \(candyAwarded) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEvolvedPokemonData {
                if let hashValueevolvedPokemonData = evolvedPokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueevolvedPokemonData
                }
            }
            if hasExperienceAwarded {
               hashCode = (hashCode &* 31) &+ experienceAwarded.hashValue
            }
            if hasCandyAwarded {
               hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.EvolvePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.EvolvePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.EvolvePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.EvolvePokemonResponse = Pogoprotos.Networking.Responses.EvolvePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasEvolvedPokemonData:Bool {
           get {
               return builderResult.hasEvolvedPokemonData
           }
      }
      public var evolvedPokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if evolvedPokemonDataBuilder_ != nil {
                  builderResult.evolvedPokemonData = evolvedPokemonDataBuilder_.getMessage()
               }
               return builderResult.evolvedPokemonData
           }
           set (value) {
               builderResult.hasEvolvedPokemonData = true
               builderResult.evolvedPokemonData = value
           }
      }
      private var evolvedPokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasEvolvedPokemonData = true
           }
      }
      public func getEvolvedPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if evolvedPokemonDataBuilder_ == nil {
           evolvedPokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.evolvedPokemonData = evolvedPokemonDataBuilder_.getMessage()
           if evolvedPokemonData != nil {
              try! evolvedPokemonDataBuilder_.mergeFrom(evolvedPokemonData)
           }
        }
        return evolvedPokemonDataBuilder_
      }
      public func setEvolvedPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.evolvedPokemonData = value
        return self
      }
      public func mergeEvolvedPokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        if builderResult.hasEvolvedPokemonData {
          builderResult.evolvedPokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.evolvedPokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.evolvedPokemonData = value
        }
        builderResult.hasEvolvedPokemonData = true
        return self
      }
      public func clearEvolvedPokemonData() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        evolvedPokemonDataBuilder_ = nil
        builderResult.hasEvolvedPokemonData = false
        builderResult.evolvedPokemonData = nil
        return self
      }
      public var hasExperienceAwarded:Bool {
           get {
                return builderResult.hasExperienceAwarded
           }
      }
      public var experienceAwarded:Int32 {
           get {
                return builderResult.experienceAwarded
           }
           set (value) {
               builderResult.hasExperienceAwarded = true
               builderResult.experienceAwarded = value
           }
      }
      public func setExperienceAwarded(value:Int32) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder{
           builderResult.hasExperienceAwarded = false
           builderResult.experienceAwarded = Int32(0)
           return self
      }
      public var hasCandyAwarded:Bool {
           get {
                return builderResult.hasCandyAwarded
           }
      }
      public var candyAwarded:Int32 {
           get {
                return builderResult.candyAwarded
           }
           set (value) {
               builderResult.hasCandyAwarded = true
               builderResult.candyAwarded = value
           }
      }
      public func setCandyAwarded(value:Int32) -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        self.candyAwarded = value
        return self
      }
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder{
           builderResult.hasCandyAwarded = false
           builderResult.candyAwarded = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.EvolvePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.EvolvePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.EvolvePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.EvolvePokemonResponse) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.EvolvePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEvolvedPokemonData) {
            try mergeEvolvedPokemonData(other.evolvedPokemonData)
        }
        if other.hasExperienceAwarded {
             experienceAwarded = other.experienceAwarded
        }
        if other.hasCandyAwarded {
             candyAwarded = other.candyAwarded
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasEvolvedPokemonData {
              try subBuilder.mergeFrom(evolvedPokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            evolvedPokemonData = subBuilder.buildPartial()

          case 24:
            experienceAwarded = try input.readInt32()

          case 32:
            candyAwarded = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueEvolvedPokemonData = jsonMap["evolvedPokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.evolvedPokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValueEvolvedPokemonData).build()

        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? NSNumber {
          resultDecodedBuilder.experienceAwarded = jsonValueExperienceAwarded.intValue
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? NSNumber {
          resultDecodedBuilder.candyAwarded = jsonValueCandyAwarded.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.EvolvePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FortDeployPokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case NoResultSet = 0
        case Success = 1
        case ErrorAlreadyHasPokemonOnFort = 2
        case ErrorOpposingTeamOwnsFort = 3
        case ErrorFortIsFull = 4
        case ErrorNotInRange = 5
        case ErrorPlayerHasNoTeam = 6
        case ErrorPokemonNotFullHp = 7
        case ErrorPlayerBelowMinimumLevel = 8
        public func toString() -> String {
          switch self {
          case .NoResultSet: return "NO_RESULT_SET"
          case .Success: return "SUCCESS"
          case .ErrorAlreadyHasPokemonOnFort: return "ERROR_ALREADY_HAS_POKEMON_ON_FORT"
          case .ErrorOpposingTeamOwnsFort: return "ERROR_OPPOSING_TEAM_OWNS_FORT"
          case .ErrorFortIsFull: return "ERROR_FORT_IS_FULL"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          case .ErrorPlayerHasNoTeam: return "ERROR_PLAYER_HAS_NO_TEAM"
          case .ErrorPokemonNotFullHp: return "ERROR_POKEMON_NOT_FULL_HP"
          case .ErrorPlayerBelowMinimumLevel: return "ERROR_PLAYER_BELOW_MINIMUM_LEVEL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .NoResultSet
          case "SUCCESS":  return .Success
          case "ERROR_ALREADY_HAS_POKEMON_ON_FORT":  return .ErrorAlreadyHasPokemonOnFort
          case "ERROR_OPPOSING_TEAM_OWNS_FORT":  return .ErrorOpposingTeamOwnsFort
          case "ERROR_FORT_IS_FULL":  return .ErrorFortIsFull
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          case "ERROR_PLAYER_HAS_NO_TEAM":  return .ErrorPlayerHasNoTeam
          case "ERROR_POKEMON_NOT_FULL_HP":  return .ErrorPokemonNotFullHp
          case "ERROR_PLAYER_BELOW_MINIMUM_LEVEL":  return .ErrorPlayerBelowMinimumLevel
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .NoResultSet: return ".NoResultSet"
                case .Success: return ".Success"
                case .ErrorAlreadyHasPokemonOnFort: return ".ErrorAlreadyHasPokemonOnFort"
                case .ErrorOpposingTeamOwnsFort: return ".ErrorOpposingTeamOwnsFort"
                case .ErrorFortIsFull: return ".ErrorFortIsFull"
                case .ErrorNotInRange: return ".ErrorNotInRange"
                case .ErrorPlayerHasNoTeam: return ".ErrorPlayerHasNoTeam"
                case .ErrorPokemonNotFullHp: return ".ErrorPokemonNotFullHp"
                case .ErrorPlayerBelowMinimumLevel: return ".ErrorPlayerBelowMinimumLevel"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result.NoResultSet
    public private(set) var hasResult:Bool = false
    public private(set) var hasFortDetails:Bool = false
    public private(set) var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse!
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasGymState:Bool = false
    public private(set) var gymState:Pogoprotos.Data.Gym.GymState!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasFortDetails {
        try output.writeMessage(2, value:fortDetails)
      }
      if hasPokemonData {
        try output.writeMessage(3, value:pokemonData)
      }
      if hasGymState {
        try output.writeMessage(4, value:gymState)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasFortDetails {
          if let varSizefortDetails = fortDetails?.computeMessageSize(2) {
              serialize_size += varSizefortDetails
          }
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(3) {
              serialize_size += varSizepokemonData
          }
      }
      if hasGymState {
          if let varSizegymState = gymState?.computeMessageSize(4) {
              serialize_size += varSizegymState
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.FortDeployPokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.FortDeployPokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse? {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortDeployPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasFortDetails {
        jsonMap["fortDetails"] = try fortDetails.encode()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasGymState {
        jsonMap["gymState"] = try gymState.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasFortDetails {
        output += "\(indent) fortDetails {\n"
        if let outDescFortDetails = fortDetails {
          output += try outDescFortDetails.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasGymState {
        output += "\(indent) gymState {\n"
        if let outDescGymState = gymState {
          output += try outDescGymState.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasFortDetails {
                if let hashValuefortDetails = fortDetails?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefortDetails
                }
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasGymState {
                if let hashValuegymState = gymState?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegymState
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDeployPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDeployPokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.FortDeployPokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.FortDeployPokemonResponse = Pogoprotos.Networking.Responses.FortDeployPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .NoResultSet
           return self
        }
      public var hasFortDetails:Bool {
           get {
               return builderResult.hasFortDetails
           }
      }
      public var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse! {
           get {
               if fortDetailsBuilder_ != nil {
                  builderResult.fortDetails = fortDetailsBuilder_.getMessage()
               }
               return builderResult.fortDetails
           }
           set (value) {
               builderResult.hasFortDetails = true
               builderResult.fortDetails = value
           }
      }
      private var fortDetailsBuilder_:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder! {
           didSet {
              builderResult.hasFortDetails = true
           }
      }
      public func getFortDetailsBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if fortDetailsBuilder_ == nil {
           fortDetailsBuilder_ = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
           builderResult.fortDetails = fortDetailsBuilder_.getMessage()
           if fortDetails != nil {
              try! fortDetailsBuilder_.mergeFrom(fortDetails)
           }
        }
        return fortDetailsBuilder_
      }
      public func setFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.fortDetails = value
        return self
      }
      public func mergeFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasFortDetails {
          builderResult.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(builderResult.fortDetails).mergeFrom(value).buildPartial()
        } else {
          builderResult.fortDetails = value
        }
        builderResult.hasFortDetails = true
        return self
      }
      public func clearFortDetails() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        fortDetailsBuilder_ = nil
        builderResult.hasFortDetails = false
        builderResult.fortDetails = nil
        return self
      }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasGymState:Bool {
           get {
               return builderResult.hasGymState
           }
      }
      public var gymState:Pogoprotos.Data.Gym.GymState! {
           get {
               if gymStateBuilder_ != nil {
                  builderResult.gymState = gymStateBuilder_.getMessage()
               }
               return builderResult.gymState
           }
           set (value) {
               builderResult.hasGymState = true
               builderResult.gymState = value
           }
      }
      private var gymStateBuilder_:Pogoprotos.Data.Gym.GymState.Builder! {
           didSet {
              builderResult.hasGymState = true
           }
      }
      public func getGymStateBuilder() -> Pogoprotos.Data.Gym.GymState.Builder {
        if gymStateBuilder_ == nil {
           gymStateBuilder_ = Pogoprotos.Data.Gym.GymState.Builder()
           builderResult.gymState = gymStateBuilder_.getMessage()
           if gymState != nil {
              try! gymStateBuilder_.mergeFrom(gymState)
           }
        }
        return gymStateBuilder_
      }
      public func setGymState(value:Pogoprotos.Data.Gym.GymState!) -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        self.gymState = value
        return self
      }
      public func mergeGymState(value:Pogoprotos.Data.Gym.GymState) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if builderResult.hasGymState {
          builderResult.gymState = try Pogoprotos.Data.Gym.GymState.builderWithPrototype(builderResult.gymState).mergeFrom(value).buildPartial()
        } else {
          builderResult.gymState = value
        }
        builderResult.hasGymState = true
        return self
      }
      public func clearGymState() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        gymStateBuilder_ = nil
        builderResult.hasGymState = false
        builderResult.gymState = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortDeployPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortDeployPokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortDeployPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortDeployPokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasFortDetails) {
            try mergeFortDetails(other.fortDetails)
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if (other.hasGymState) {
            try mergeGymState(other.gymState)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
            if hasFortDetails {
              try subBuilder.mergeFrom(fortDetails)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            fortDetails = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 34:
            let subBuilder:Pogoprotos.Data.Gym.GymState.Builder = Pogoprotos.Data.Gym.GymState.Builder()
            if hasGymState {
              try subBuilder.mergeFrom(gymState)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            gymState = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueFortDetails = jsonMap["fortDetails"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonValueFortDetails).build()

        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueGymState = jsonMap["gymState"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.gymState = try Pogoprotos.Data.Gym.GymState.Builder.decodeToBuilder(jsonValueGymState).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortDeployPokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FortDetailsResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasFortId:Bool = false
    public private(set) var fortId:String = ""

    public private(set) var teamColor:Pogoprotos.Enums.TeamColor = Pogoprotos.Enums.TeamColor.Neutral
    public private(set) var hasTeamColor:Bool = false
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var imageUrls:Array<String> = Array<String>()
    public private(set) var hasFp:Bool = false
    public private(set) var fp:Int32 = Int32(0)

    public private(set) var hasStamina:Bool = false
    public private(set) var stamina:Int32 = Int32(0)

    public private(set) var hasMaxStamina:Bool = false
    public private(set) var maxStamina:Int32 = Int32(0)

    public private(set) var types:Pogoprotos.Map.Fort.FortType = Pogoprotos.Map.Fort.FortType.Gym
    public private(set) var hasTypes:Bool = false
    public private(set) var hasLatitude:Bool = false
    public private(set) var latitude:Double = Double(0)

    public private(set) var hasLongitude:Bool = false
    public private(set) var longitude:Double = Double(0)

    public private(set) var hasDescription:Bool = false
    public private(set) var description_:String = ""

    public private(set) var modifiers:Array<Pogoprotos.Map.Fort.FortModifier>  = Array<Pogoprotos.Map.Fort.FortModifier>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasFortId {
        try output.writeString(1, value:fortId)
      }
      if hasTeamColor {
        try output.writeEnum(2, value:teamColor.rawValue)
      }
      if hasPokemonData {
        try output.writeMessage(3, value:pokemonData)
      }
      if hasName {
        try output.writeString(4, value:name)
      }
      if !imageUrls.isEmpty {
        for oneValueimageUrls in imageUrls {
          try output.writeString(5, value:oneValueimageUrls)
        }
      }
      if hasFp {
        try output.writeInt32(6, value:fp)
      }
      if hasStamina {
        try output.writeInt32(7, value:stamina)
      }
      if hasMaxStamina {
        try output.writeInt32(8, value:maxStamina)
      }
      if hasTypes {
        try output.writeEnum(9, value:types.rawValue)
      }
      if hasLatitude {
        try output.writeDouble(10, value:latitude)
      }
      if hasLongitude {
        try output.writeDouble(11, value:longitude)
      }
      if hasDescription {
        try output.writeString(12, value:description_)
      }
      for oneElementModifiers in modifiers {
          try output.writeMessage(13, value:oneElementModifiers)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasFortId {
        serialize_size += fortId.computeStringSize(1)
      }
      if (hasTeamColor) {
        serialize_size += teamColor.rawValue.computeEnumSize(2)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(3) {
              serialize_size += varSizepokemonData
          }
      }
      if hasName {
        serialize_size += name.computeStringSize(4)
      }
      var dataSizeImageUrls:Int32 = 0
      for oneValueimageUrls in imageUrls {
          dataSizeImageUrls += oneValueimageUrls.computeStringSizeNoTag()
      }
      serialize_size += dataSizeImageUrls
      serialize_size += 1 * Int32(imageUrls.count)
      if hasFp {
        serialize_size += fp.computeInt32Size(6)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(7)
      }
      if hasMaxStamina {
        serialize_size += maxStamina.computeInt32Size(8)
      }
      if (hasTypes) {
        serialize_size += types.rawValue.computeEnumSize(9)
      }
      if hasLatitude {
        serialize_size += latitude.computeDoubleSize(10)
      }
      if hasLongitude {
        serialize_size += longitude.computeDoubleSize(11)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(12)
      }
      for oneElementModifiers in modifiers {
          serialize_size += oneElementModifiers.computeMessageSize(13)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.FortDetailsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.FortDetailsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse? {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortDetailsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortDetailsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasFortId {
        jsonMap["fortId"] = fortId
      }
      if hasTeamColor {
        jsonMap["teamColor"] = teamColor.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasName {
        jsonMap["name"] = name
      }
      if !imageUrls.isEmpty {
        jsonMap["imageUrls"] = imageUrls
      }
      if hasFp {
        jsonMap["fp"] = NSNumber(int:fp)
      }
      if hasStamina {
        jsonMap["stamina"] = NSNumber(int:stamina)
      }
      if hasMaxStamina {
        jsonMap["maxStamina"] = NSNumber(int:maxStamina)
      }
      if hasTypes {
        jsonMap["type"] = types.toString()
      }
      if hasLatitude {
        jsonMap["latitude"] = NSNumber(double:latitude)
      }
      if hasLongitude {
        jsonMap["longitude"] = NSNumber(double:longitude)
      }
      if hasDescription {
        jsonMap["description"] = description_
      }
      if !modifiers.isEmpty {
        var jsonArrayModifiers:Array<Dictionary<String,AnyObject>> = []
          for oneValueModifiers in modifiers {
            let ecodedMessageModifiers = try oneValueModifiers.encode()
            jsonArrayModifiers += [ecodedMessageModifiers]
          }
        jsonMap["modifiers"] = jsonArrayModifiers
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
      return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasFortId {
        output += "\(indent) fortId: \(fortId) \n"
      }
      if (hasTeamColor) {
        output += "\(indent) teamColor: \(teamColor.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var imageUrlsElementIndex:Int = 0
      for oneValueImageUrls in imageUrls  {
          output += "\(indent) imageUrls[\(imageUrlsElementIndex)]: \(oneValueImageUrls)\n"
          imageUrlsElementIndex += 1
      }
      if hasFp {
        output += "\(indent) fp: \(fp) \n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      if hasMaxStamina {
        output += "\(indent) maxStamina: \(maxStamina) \n"
      }
      if (hasTypes) {
        output += "\(indent) types: \(types.description)\n"
      }
      if hasLatitude {
        output += "\(indent) latitude: \(latitude) \n"
      }
      if hasLongitude {
        output += "\(indent) longitude: \(longitude) \n"
      }
      if hasDescription {
        output += "\(indent) description_: \(description_) \n"
      }
      var modifiersElementIndex:Int = 0
      for oneElementModifiers in modifiers {
          output += "\(indent) modifiers[\(modifiersElementIndex)] {\n"
          output += try oneElementModifiers.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          modifiersElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasFortId {
               hashCode = (hashCode &* 31) &+ fortId.hashValue
            }
            if hasTeamColor {
               hashCode = (hashCode &* 31) &+ Int(teamColor.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneValueImageUrls in imageUrls {
                hashCode = (hashCode &* 31) &+ oneValueImageUrls.hashValue
            }
            if hasFp {
               hashCode = (hashCode &* 31) &+ fp.hashValue
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            if hasMaxStamina {
               hashCode = (hashCode &* 31) &+ maxStamina.hashValue
            }
            if hasTypes {
               hashCode = (hashCode &* 31) &+ Int(types.rawValue)
            }
            if hasLatitude {
               hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
               hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            for oneElementModifiers in modifiers {
                hashCode = (hashCode &* 31) &+ oneElementModifiers.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDetailsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortDetailsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.FortDetailsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.FortDetailsResponse = Pogoprotos.Networking.Responses.FortDetailsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortDetailsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasFortId:Bool {
           get {
                return builderResult.hasFortId
           }
      }
      public var fortId:String {
           get {
                return builderResult.fortId
           }
           set (value) {
               builderResult.hasFortId = true
               builderResult.fortId = value
           }
      }
      public func setFortId(value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.fortId = value
        return self
      }
      public func clearFortId() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasFortId = false
           builderResult.fortId = ""
           return self
      }
        public var hasTeamColor:Bool{
            get {
                return builderResult.hasTeamColor
            }
        }
        public var teamColor:Pogoprotos.Enums.TeamColor {
            get {
                return builderResult.teamColor
            }
            set (value) {
                builderResult.hasTeamColor = true
                builderResult.teamColor = value
            }
        }
        public func setTeamColor(value:Pogoprotos.Enums.TeamColor) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
          self.teamColor = value
          return self
        }
        public func clearTeamColor() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           builderResult.hasTeamColor = false
           builderResult.teamColor = .Neutral
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var imageUrls:Array<String> {
           get {
               return builderResult.imageUrls
           }
           set (array) {
               builderResult.imageUrls = array
           }
      }
      public func setImageUrls(value:Array<String>) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.imageUrls = value
        return self
      }
      public func clearImageUrls() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
         builderResult.imageUrls.removeAll(keepCapacity: false)
         return self
      }
      public var hasFp:Bool {
           get {
                return builderResult.hasFp
           }
      }
      public var fp:Int32 {
           get {
                return builderResult.fp
           }
           set (value) {
               builderResult.hasFp = true
               builderResult.fp = value
           }
      }
      public func setFp(value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.fp = value
        return self
      }
      public func clearFp() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasFp = false
           builderResult.fp = Int32(0)
           return self
      }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      public func setStamina(value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.stamina = value
        return self
      }
      public func clearStamina() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      public var hasMaxStamina:Bool {
           get {
                return builderResult.hasMaxStamina
           }
      }
      public var maxStamina:Int32 {
           get {
                return builderResult.maxStamina
           }
           set (value) {
               builderResult.hasMaxStamina = true
               builderResult.maxStamina = value
           }
      }
      public func setMaxStamina(value:Int32) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.maxStamina = value
        return self
      }
      public func clearMaxStamina() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasMaxStamina = false
           builderResult.maxStamina = Int32(0)
           return self
      }
        public var hasTypes:Bool{
            get {
                return builderResult.hasTypes
            }
        }
        public var types:Pogoprotos.Map.Fort.FortType {
            get {
                return builderResult.types
            }
            set (value) {
                builderResult.hasTypes = true
                builderResult.types = value
            }
        }
        public func setTypes(value:Pogoprotos.Map.Fort.FortType) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
          self.types = value
          return self
        }
        public func clearTypes() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           builderResult.hasTypes = false
           builderResult.types = .Gym
           return self
        }
      public var hasLatitude:Bool {
           get {
                return builderResult.hasLatitude
           }
      }
      public var latitude:Double {
           get {
                return builderResult.latitude
           }
           set (value) {
               builderResult.hasLatitude = true
               builderResult.latitude = value
           }
      }
      public func setLatitude(value:Double) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.latitude = value
        return self
      }
      public func clearLatitude() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasLatitude = false
           builderResult.latitude = Double(0)
           return self
      }
      public var hasLongitude:Bool {
           get {
                return builderResult.hasLongitude
           }
      }
      public var longitude:Double {
           get {
                return builderResult.longitude
           }
           set (value) {
               builderResult.hasLongitude = true
               builderResult.longitude = value
           }
      }
      public func setLongitude(value:Double) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.longitude = value
        return self
      }
      public func clearLongitude() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasLongitude = false
           builderResult.longitude = Double(0)
           return self
      }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      public func setDescription(value:String) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.description_ = value
        return self
      }
      public func clearDescription() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      public var modifiers:Array<Pogoprotos.Map.Fort.FortModifier> {
           get {
               return builderResult.modifiers
           }
           set (value) {
               builderResult.modifiers = value
           }
      }
      public func setModifiers(value:Array<Pogoprotos.Map.Fort.FortModifier>) -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        self.modifiers = value
        return self
      }
      public func clearModifiers() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        builderResult.modifiers.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortDetailsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortDetailsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortDetailsResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortDetailsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortDetailsResponse() {
         return self
        }
        if other.hasFortId {
             fortId = other.fortId
        }
        if other.hasTeamColor {
             teamColor = other.teamColor
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if other.hasName {
             name = other.name
        }
        if !other.imageUrls.isEmpty {
            builderResult.imageUrls += other.imageUrls
        }
        if other.hasFp {
             fp = other.fp
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        if other.hasMaxStamina {
             maxStamina = other.maxStamina
        }
        if other.hasTypes {
             types = other.types
        }
        if other.hasLatitude {
             latitude = other.latitude
        }
        if other.hasLongitude {
             longitude = other.longitude
        }
        if other.hasDescription {
             description_ = other.description_
        }
        if !other.modifiers.isEmpty  {
           builderResult.modifiers += other.modifiers
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            fortId = try input.readString()

          case 16:
            let valueIntteamColor = try input.readEnum()
            if let enumsteamColor = Pogoprotos.Enums.TeamColor(rawValue:valueIntteamColor){
                 teamColor = enumsteamColor
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntteamColor))
            }

          case 26:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 34:
            name = try input.readString()

          case 42:
            imageUrls += [try input.readString()]

          case 48:
            fp = try input.readInt32()

          case 56:
            stamina = try input.readInt32()

          case 64:
            maxStamina = try input.readInt32()

          case 72:
            let valueInttypes = try input.readEnum()
            if let enumstypes = Pogoprotos.Map.Fort.FortType(rawValue:valueInttypes){
                 types = enumstypes
            } else {
                 try unknownFieldsBuilder.mergeVarintField(9, value:Int64(valueInttypes))
            }

          case 81:
            latitude = try input.readDouble()

          case 89:
            longitude = try input.readDouble()

          case 98:
            description_ = try input.readString()

          case 106:
            let subBuilder = Pogoprotos.Map.Fort.FortModifier.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            modifiers += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
        if let jsonValueFortId = jsonMap["fortId"] as? String {
          resultDecodedBuilder.fortId = jsonValueFortId
        }
        if let jsonValueTeamColor = jsonMap["teamColor"] as? String {
          resultDecodedBuilder.teamColor = try Pogoprotos.Enums.TeamColor.fromString(jsonValueTeamColor)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueImageUrls = jsonMap["imageUrls"] as? Array<String> {
          resultDecodedBuilder.imageUrls = jsonValueImageUrls
        }
        if let jsonValueFp = jsonMap["fp"] as? NSNumber {
          resultDecodedBuilder.fp = jsonValueFp.intValue
        }
        if let jsonValueStamina = jsonMap["stamina"] as? NSNumber {
          resultDecodedBuilder.stamina = jsonValueStamina.intValue
        }
        if let jsonValueMaxStamina = jsonMap["maxStamina"] as? NSNumber {
          resultDecodedBuilder.maxStamina = jsonValueMaxStamina.intValue
        }
        if let jsonValueTypes = jsonMap["type"] as? String {
          resultDecodedBuilder.types = try Pogoprotos.Map.Fort.FortType.fromString(jsonValueTypes)
        }
        if let jsonValueLatitude = jsonMap["latitude"] as? NSNumber {
          resultDecodedBuilder.latitude = jsonValueLatitude.doubleValue
        }
        if let jsonValueLongitude = jsonMap["longitude"] as? NSNumber {
          resultDecodedBuilder.longitude = jsonValueLongitude.doubleValue
        }
        if let jsonValueDescription = jsonMap["description"] as? String {
          resultDecodedBuilder.description_ = jsonValueDescription
        }
        if let jsonValueModifiers = jsonMap["modifiers"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayModifiers:Array<Pogoprotos.Map.Fort.FortModifier> = []
          for oneValueModifiers in jsonValueModifiers {
            let messageFromStringModifiers = try Pogoprotos.Map.Fort.FortModifier.Builder.decodeToBuilder(oneValueModifiers).build()

            jsonArrayModifiers += [messageFromStringModifiers]
          }
          resultDecodedBuilder.modifiers = jsonArrayModifiers
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FortRecallPokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case NoResultSet = 0
        case Success = 1
        case ErrorNotInRange = 2
        case ErrorPokemonNotOnFort = 3
        case ErrorNoPlayer = 4
        public func toString() -> String {
          switch self {
          case .NoResultSet: return "NO_RESULT_SET"
          case .Success: return "SUCCESS"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          case .ErrorPokemonNotOnFort: return "ERROR_POKEMON_NOT_ON_FORT"
          case .ErrorNoPlayer: return "ERROR_NO_PLAYER"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .NoResultSet
          case "SUCCESS":  return .Success
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          case "ERROR_POKEMON_NOT_ON_FORT":  return .ErrorPokemonNotOnFort
          case "ERROR_NO_PLAYER":  return .ErrorNoPlayer
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .NoResultSet: return ".NoResultSet"
                case .Success: return ".Success"
                case .ErrorNotInRange: return ".ErrorNotInRange"
                case .ErrorPokemonNotOnFort: return ".ErrorPokemonNotOnFort"
                case .ErrorNoPlayer: return ".ErrorNoPlayer"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result.NoResultSet
    public private(set) var hasResult:Bool = false
    public private(set) var hasFortDetails:Bool = false
    public private(set) var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasFortDetails {
        try output.writeMessage(2, value:fortDetails)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasFortDetails {
          if let varSizefortDetails = fortDetails?.computeMessageSize(2) {
              serialize_size += varSizefortDetails
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.FortRecallPokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.FortRecallPokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse? {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortRecallPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasFortDetails {
        jsonMap["fortDetails"] = try fortDetails.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
      return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasFortDetails {
        output += "\(indent) fortDetails {\n"
        if let outDescFortDetails = fortDetails {
          output += try outDescFortDetails.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasFortDetails {
                if let hashValuefortDetails = fortDetails?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefortDetails
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortRecallPokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortRecallPokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.FortRecallPokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.FortRecallPokemonResponse = Pogoprotos.Networking.Responses.FortRecallPokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result) -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .NoResultSet
           return self
        }
      public var hasFortDetails:Bool {
           get {
               return builderResult.hasFortDetails
           }
      }
      public var fortDetails:Pogoprotos.Networking.Responses.FortDetailsResponse! {
           get {
               if fortDetailsBuilder_ != nil {
                  builderResult.fortDetails = fortDetailsBuilder_.getMessage()
               }
               return builderResult.fortDetails
           }
           set (value) {
               builderResult.hasFortDetails = true
               builderResult.fortDetails = value
           }
      }
      private var fortDetailsBuilder_:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder! {
           didSet {
              builderResult.hasFortDetails = true
           }
      }
      public func getFortDetailsBuilder() -> Pogoprotos.Networking.Responses.FortDetailsResponse.Builder {
        if fortDetailsBuilder_ == nil {
           fortDetailsBuilder_ = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
           builderResult.fortDetails = fortDetailsBuilder_.getMessage()
           if fortDetails != nil {
              try! fortDetailsBuilder_.mergeFrom(fortDetails)
           }
        }
        return fortDetailsBuilder_
      }
      public func setFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse!) -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        self.fortDetails = value
        return self
      }
      public func mergeFortDetails(value:Pogoprotos.Networking.Responses.FortDetailsResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        if builderResult.hasFortDetails {
          builderResult.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.builderWithPrototype(builderResult.fortDetails).mergeFrom(value).buildPartial()
        } else {
          builderResult.fortDetails = value
        }
        builderResult.hasFortDetails = true
        return self
      }
      public func clearFortDetails() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        fortDetailsBuilder_ = nil
        builderResult.hasFortDetails = false
        builderResult.fortDetails = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortRecallPokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortRecallPokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortRecallPokemonResponse) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortRecallPokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasFortDetails) {
            try mergeFortDetails(other.fortDetails)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Networking.Responses.FortDetailsResponse.Builder = Pogoprotos.Networking.Responses.FortDetailsResponse.Builder()
            if hasFortDetails {
              try subBuilder.mergeFrom(fortDetails)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            fortDetails = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueFortDetails = jsonMap["fortDetails"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.fortDetails = try Pogoprotos.Networking.Responses.FortDetailsResponse.Builder.decodeToBuilder(jsonValueFortDetails).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortRecallPokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class FortSearchResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case NoResultSet = 0
        case Success = 1
        case OutOfRange = 2
        case InCooldownPeriod = 3
        case InventoryFull = 4
        public func toString() -> String {
          switch self {
          case .NoResultSet: return "NO_RESULT_SET"
          case .Success: return "SUCCESS"
          case .OutOfRange: return "OUT_OF_RANGE"
          case .InCooldownPeriod: return "IN_COOLDOWN_PERIOD"
          case .InventoryFull: return "INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Result {
          switch str {
          case "NO_RESULT_SET":  return .NoResultSet
          case "SUCCESS":  return .Success
          case "OUT_OF_RANGE":  return .OutOfRange
          case "IN_COOLDOWN_PERIOD":  return .InCooldownPeriod
          case "INVENTORY_FULL":  return .InventoryFull
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .NoResultSet: return ".NoResultSet"
                case .Success: return ".Success"
                case .OutOfRange: return ".OutOfRange"
                case .InCooldownPeriod: return ".InCooldownPeriod"
                case .InventoryFull: return ".InventoryFull"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.FortSearchResponse.Result = Pogoprotos.Networking.Responses.FortSearchResponse.Result.NoResultSet
    public private(set) var hasResult:Bool = false
    public private(set) var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward>  = Array<Pogoprotos.Inventory.Item.ItemAward>()
    public private(set) var hasGemsAwarded:Bool = false
    public private(set) var gemsAwarded:Int32 = Int32(0)

    public private(set) var hasPokemonDataEgg:Bool = false
    public private(set) var pokemonDataEgg:Pogoprotos.Data.PokemonData!
    public private(set) var hasExperienceAwarded:Bool = false
    public private(set) var experienceAwarded:Int32 = Int32(0)

    public private(set) var hasCooldownCompleteTimestampMs:Bool = false
    public private(set) var cooldownCompleteTimestampMs:Int64 = Int64(0)

    public private(set) var hasChainHackSequenceNumber:Bool = false
    public private(set) var chainHackSequenceNumber:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      for oneElementItemsAwarded in itemsAwarded {
          try output.writeMessage(2, value:oneElementItemsAwarded)
      }
      if hasGemsAwarded {
        try output.writeInt32(3, value:gemsAwarded)
      }
      if hasPokemonDataEgg {
        try output.writeMessage(4, value:pokemonDataEgg)
      }
      if hasExperienceAwarded {
        try output.writeInt32(5, value:experienceAwarded)
      }
      if hasCooldownCompleteTimestampMs {
        try output.writeInt64(6, value:cooldownCompleteTimestampMs)
      }
      if hasChainHackSequenceNumber {
        try output.writeInt32(7, value:chainHackSequenceNumber)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      for oneElementItemsAwarded in itemsAwarded {
          serialize_size += oneElementItemsAwarded.computeMessageSize(2)
      }
      if hasGemsAwarded {
        serialize_size += gemsAwarded.computeInt32Size(3)
      }
      if hasPokemonDataEgg {
          if let varSizepokemonDataEgg = pokemonDataEgg?.computeMessageSize(4) {
              serialize_size += varSizepokemonDataEgg
          }
      }
      if hasExperienceAwarded {
        serialize_size += experienceAwarded.computeInt32Size(5)
      }
      if hasCooldownCompleteTimestampMs {
        serialize_size += cooldownCompleteTimestampMs.computeInt64Size(6)
      }
      if hasChainHackSequenceNumber {
        serialize_size += chainHackSequenceNumber.computeInt32Size(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.FortSearchResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.FortSearchResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse? {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.classBuilder() as! Pogoprotos.Networking.Responses.FortSearchResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.FortSearchResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.FortSearchResponse) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !itemsAwarded.isEmpty {
        var jsonArrayItemsAwarded:Array<Dictionary<String,AnyObject>> = []
          for oneValueItemsAwarded in itemsAwarded {
            let ecodedMessageItemsAwarded = try oneValueItemsAwarded.encode()
            jsonArrayItemsAwarded += [ecodedMessageItemsAwarded]
          }
        jsonMap["itemsAwarded"] = jsonArrayItemsAwarded
      }
      if hasGemsAwarded {
        jsonMap["gemsAwarded"] = NSNumber(int:gemsAwarded)
      }
      if hasPokemonDataEgg {
        jsonMap["pokemonDataEgg"] = try pokemonDataEgg.encode()
      }
      if hasExperienceAwarded {
        jsonMap["experienceAwarded"] = NSNumber(int:experienceAwarded)
      }
      if hasCooldownCompleteTimestampMs {
        jsonMap["cooldownCompleteTimestampMs"] = "\(cooldownCompleteTimestampMs)"
      }
      if hasChainHackSequenceNumber {
        jsonMap["chainHackSequenceNumber"] = NSNumber(int:chainHackSequenceNumber)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
      return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var itemsAwardedElementIndex:Int = 0
      for oneElementItemsAwarded in itemsAwarded {
          output += "\(indent) itemsAwarded[\(itemsAwardedElementIndex)] {\n"
          output += try oneElementItemsAwarded.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          itemsAwardedElementIndex += 1
      }
      if hasGemsAwarded {
        output += "\(indent) gemsAwarded: \(gemsAwarded) \n"
      }
      if hasPokemonDataEgg {
        output += "\(indent) pokemonDataEgg {\n"
        if let outDescPokemonDataEgg = pokemonDataEgg {
          output += try outDescPokemonDataEgg.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasExperienceAwarded {
        output += "\(indent) experienceAwarded: \(experienceAwarded) \n"
      }
      if hasCooldownCompleteTimestampMs {
        output += "\(indent) cooldownCompleteTimestampMs: \(cooldownCompleteTimestampMs) \n"
      }
      if hasChainHackSequenceNumber {
        output += "\(indent) chainHackSequenceNumber: \(chainHackSequenceNumber) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementItemsAwarded in itemsAwarded {
                hashCode = (hashCode &* 31) &+ oneElementItemsAwarded.hashValue
            }
            if hasGemsAwarded {
               hashCode = (hashCode &* 31) &+ gemsAwarded.hashValue
            }
            if hasPokemonDataEgg {
                if let hashValuepokemonDataEgg = pokemonDataEgg?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonDataEgg
                }
            }
            if hasExperienceAwarded {
               hashCode = (hashCode &* 31) &+ experienceAwarded.hashValue
            }
            if hasCooldownCompleteTimestampMs {
               hashCode = (hashCode &* 31) &+ cooldownCompleteTimestampMs.hashValue
            }
            if hasChainHackSequenceNumber {
               hashCode = (hashCode &* 31) &+ chainHackSequenceNumber.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.FortSearchResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.FortSearchResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.FortSearchResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.FortSearchResponse = Pogoprotos.Networking.Responses.FortSearchResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.FortSearchResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.FortSearchResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.FortSearchResponse.Result) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .NoResultSet
           return self
        }
      public var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> {
           get {
               return builderResult.itemsAwarded
           }
           set (value) {
               builderResult.itemsAwarded = value
           }
      }
      public func setItemsAwarded(value:Array<Pogoprotos.Inventory.Item.ItemAward>) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.itemsAwarded = value
        return self
      }
      public func clearItemsAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        builderResult.itemsAwarded.removeAll(keepCapacity: false)
        return self
      }
      public var hasGemsAwarded:Bool {
           get {
                return builderResult.hasGemsAwarded
           }
      }
      public var gemsAwarded:Int32 {
           get {
                return builderResult.gemsAwarded
           }
           set (value) {
               builderResult.hasGemsAwarded = true
               builderResult.gemsAwarded = value
           }
      }
      public func setGemsAwarded(value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.gemsAwarded = value
        return self
      }
      public func clearGemsAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasGemsAwarded = false
           builderResult.gemsAwarded = Int32(0)
           return self
      }
      public var hasPokemonDataEgg:Bool {
           get {
               return builderResult.hasPokemonDataEgg
           }
      }
      public var pokemonDataEgg:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataEggBuilder_ != nil {
                  builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
               }
               return builderResult.pokemonDataEgg
           }
           set (value) {
               builderResult.hasPokemonDataEgg = true
               builderResult.pokemonDataEgg = value
           }
      }
      private var pokemonDataEggBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonDataEgg = true
           }
      }
      public func getPokemonDataEggBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataEggBuilder_ == nil {
           pokemonDataEggBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonDataEgg = pokemonDataEggBuilder_.getMessage()
           if pokemonDataEgg != nil {
              try! pokemonDataEggBuilder_.mergeFrom(pokemonDataEgg)
           }
        }
        return pokemonDataEggBuilder_
      }
      public func setPokemonDataEgg(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.pokemonDataEgg = value
        return self
      }
      public func mergePokemonDataEgg(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        if builderResult.hasPokemonDataEgg {
          builderResult.pokemonDataEgg = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonDataEgg).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonDataEgg = value
        }
        builderResult.hasPokemonDataEgg = true
        return self
      }
      public func clearPokemonDataEgg() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        pokemonDataEggBuilder_ = nil
        builderResult.hasPokemonDataEgg = false
        builderResult.pokemonDataEgg = nil
        return self
      }
      public var hasExperienceAwarded:Bool {
           get {
                return builderResult.hasExperienceAwarded
           }
      }
      public var experienceAwarded:Int32 {
           get {
                return builderResult.experienceAwarded
           }
           set (value) {
               builderResult.hasExperienceAwarded = true
               builderResult.experienceAwarded = value
           }
      }
      public func setExperienceAwarded(value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasExperienceAwarded = false
           builderResult.experienceAwarded = Int32(0)
           return self
      }
      public var hasCooldownCompleteTimestampMs:Bool {
           get {
                return builderResult.hasCooldownCompleteTimestampMs
           }
      }
      public var cooldownCompleteTimestampMs:Int64 {
           get {
                return builderResult.cooldownCompleteTimestampMs
           }
           set (value) {
               builderResult.hasCooldownCompleteTimestampMs = true
               builderResult.cooldownCompleteTimestampMs = value
           }
      }
      public func setCooldownCompleteTimestampMs(value:Int64) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.cooldownCompleteTimestampMs = value
        return self
      }
      public func clearCooldownCompleteTimestampMs() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasCooldownCompleteTimestampMs = false
           builderResult.cooldownCompleteTimestampMs = Int64(0)
           return self
      }
      public var hasChainHackSequenceNumber:Bool {
           get {
                return builderResult.hasChainHackSequenceNumber
           }
      }
      public var chainHackSequenceNumber:Int32 {
           get {
                return builderResult.chainHackSequenceNumber
           }
           set (value) {
               builderResult.hasChainHackSequenceNumber = true
               builderResult.chainHackSequenceNumber = value
           }
      }
      public func setChainHackSequenceNumber(value:Int32) -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        self.chainHackSequenceNumber = value
        return self
      }
      public func clearChainHackSequenceNumber() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder{
           builderResult.hasChainHackSequenceNumber = false
           builderResult.chainHackSequenceNumber = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.FortSearchResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        return try Pogoprotos.Networking.Responses.FortSearchResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.FortSearchResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.FortSearchResponse {
        let returnMe:Pogoprotos.Networking.Responses.FortSearchResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.FortSearchResponse) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        if other == Pogoprotos.Networking.Responses.FortSearchResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.itemsAwarded.isEmpty  {
           builderResult.itemsAwarded += other.itemsAwarded
        }
        if other.hasGemsAwarded {
             gemsAwarded = other.gemsAwarded
        }
        if (other.hasPokemonDataEgg) {
            try mergePokemonDataEgg(other.pokemonDataEgg)
        }
        if other.hasExperienceAwarded {
             experienceAwarded = other.experienceAwarded
        }
        if other.hasCooldownCompleteTimestampMs {
             cooldownCompleteTimestampMs = other.cooldownCompleteTimestampMs
        }
        if other.hasChainHackSequenceNumber {
             chainHackSequenceNumber = other.chainHackSequenceNumber
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.FortSearchResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Inventory.Item.ItemAward.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            itemsAwarded += [subBuilder.buildPartial()]

          case 24:
            gemsAwarded = try input.readInt32()

          case 34:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonDataEgg {
              try subBuilder.mergeFrom(pokemonDataEgg)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonDataEgg = subBuilder.buildPartial()

          case 40:
            experienceAwarded = try input.readInt32()

          case 48:
            cooldownCompleteTimestampMs = try input.readInt64()

          case 56:
            chainHackSequenceNumber = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.FortSearchResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.FortSearchResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueItemsAwarded = jsonMap["itemsAwarded"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayItemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> = []
          for oneValueItemsAwarded in jsonValueItemsAwarded {
            let messageFromStringItemsAwarded = try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(oneValueItemsAwarded).build()

            jsonArrayItemsAwarded += [messageFromStringItemsAwarded]
          }
          resultDecodedBuilder.itemsAwarded = jsonArrayItemsAwarded
        }
        if let jsonValueGemsAwarded = jsonMap["gemsAwarded"] as? NSNumber {
          resultDecodedBuilder.gemsAwarded = jsonValueGemsAwarded.intValue
        }
        if let jsonValuePokemonDataEgg = jsonMap["pokemonDataEgg"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonDataEgg = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonDataEgg).build()

        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? NSNumber {
          resultDecodedBuilder.experienceAwarded = jsonValueExperienceAwarded.intValue
        }
        if let jsonValueCooldownCompleteTimestampMs = jsonMap["cooldownCompleteTimestampMs"] as? String {
          resultDecodedBuilder.cooldownCompleteTimestampMs = Int64(jsonValueCooldownCompleteTimestampMs)!
        }
        if let jsonValueChainHackSequenceNumber = jsonMap["chainHackSequenceNumber"] as? NSNumber {
          resultDecodedBuilder.chainHackSequenceNumber = jsonValueChainHackSequenceNumber.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.FortSearchResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.FortSearchResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetAssetDigestResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var digest:Array<Pogoprotos.Data.AssetDigestEntry>  = Array<Pogoprotos.Data.AssetDigestEntry>()
    public private(set) var hasTimestampMs:Bool = false
    public private(set) var timestampMs:UInt64 = UInt64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementDigest in digest {
          try output.writeMessage(1, value:oneElementDigest)
      }
      if hasTimestampMs {
        try output.writeUInt64(2, value:timestampMs)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementDigest in digest {
          serialize_size += oneElementDigest.computeMessageSize(1)
      }
      if hasTimestampMs {
        serialize_size += timestampMs.computeUInt64Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetAssetDigestResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetAssetDigestResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse? {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetAssetDigestResponse) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !digest.isEmpty {
        var jsonArrayDigest:Array<Dictionary<String,AnyObject>> = []
          for oneValueDigest in digest {
            let ecodedMessageDigest = try oneValueDigest.encode()
            jsonArrayDigest += [ecodedMessageDigest]
          }
        jsonMap["digest"] = jsonArrayDigest
      }
      if hasTimestampMs {
        jsonMap["timestampMs"] = "\(timestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
      return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var digestElementIndex:Int = 0
      for oneElementDigest in digest {
          output += "\(indent) digest[\(digestElementIndex)] {\n"
          output += try oneElementDigest.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          digestElementIndex += 1
      }
      if hasTimestampMs {
        output += "\(indent) timestampMs: \(timestampMs) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDigest in digest {
                hashCode = (hashCode &* 31) &+ oneElementDigest.hashValue
            }
            if hasTimestampMs {
               hashCode = (hashCode &* 31) &+ timestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetAssetDigestResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetAssetDigestResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetAssetDigestResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetAssetDigestResponse = Pogoprotos.Networking.Responses.GetAssetDigestResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var digest:Array<Pogoprotos.Data.AssetDigestEntry> {
           get {
               return builderResult.digest
           }
           set (value) {
               builderResult.digest = value
           }
      }
      public func setDigest(value:Array<Pogoprotos.Data.AssetDigestEntry>) -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        self.digest = value
        return self
      }
      public func clearDigest() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        builderResult.digest.removeAll(keepCapacity: false)
        return self
      }
      public var hasTimestampMs:Bool {
           get {
                return builderResult.hasTimestampMs
           }
      }
      public var timestampMs:UInt64 {
           get {
                return builderResult.timestampMs
           }
           set (value) {
               builderResult.hasTimestampMs = true
               builderResult.timestampMs = value
           }
      }
      public func setTimestampMs(value:UInt64) -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        self.timestampMs = value
        return self
      }
      public func clearTimestampMs() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder{
           builderResult.hasTimestampMs = false
           builderResult.timestampMs = UInt64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetAssetDigestResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetAssetDigestResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetAssetDigestResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetAssetDigestResponse) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetAssetDigestResponse() {
         return self
        }
        if !other.digest.isEmpty  {
           builderResult.digest += other.digest
        }
        if other.hasTimestampMs {
             timestampMs = other.timestampMs
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Data.AssetDigestEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            digest += [subBuilder.buildPartial()]

          case 16:
            timestampMs = try input.readUInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder()
        if let jsonValueDigest = jsonMap["digest"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayDigest:Array<Pogoprotos.Data.AssetDigestEntry> = []
          for oneValueDigest in jsonValueDigest {
            let messageFromStringDigest = try Pogoprotos.Data.AssetDigestEntry.Builder.decodeToBuilder(oneValueDigest).build()

            jsonArrayDigest += [messageFromStringDigest]
          }
          resultDecodedBuilder.digest = jsonArrayDigest
        }
        if let jsonValueTimestampMs = jsonMap["timestampMs"] as? String {
          resultDecodedBuilder.timestampMs = UInt64(jsonValueTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetAssetDigestResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetDownloadUrlsResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var downloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry>  = Array<Pogoprotos.Data.DownloadUrlEntry>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementDownloadUrls in downloadUrls {
          try output.writeMessage(1, value:oneElementDownloadUrls)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementDownloadUrls in downloadUrls {
          serialize_size += oneElementDownloadUrls.computeMessageSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetDownloadUrlsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetDownloadUrlsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse? {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !downloadUrls.isEmpty {
        var jsonArrayDownloadUrls:Array<Dictionary<String,AnyObject>> = []
          for oneValueDownloadUrls in downloadUrls {
            let ecodedMessageDownloadUrls = try oneValueDownloadUrls.encode()
            jsonArrayDownloadUrls += [ecodedMessageDownloadUrls]
          }
        jsonMap["downloadUrls"] = jsonArrayDownloadUrls
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
      return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var downloadUrlsElementIndex:Int = 0
      for oneElementDownloadUrls in downloadUrls {
          output += "\(indent) downloadUrls[\(downloadUrlsElementIndex)] {\n"
          output += try oneElementDownloadUrls.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          downloadUrlsElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementDownloadUrls in downloadUrls {
                hashCode = (hashCode &* 31) &+ oneElementDownloadUrls.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetDownloadUrlsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetDownloadUrlsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var downloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry> {
           get {
               return builderResult.downloadUrls
           }
           set (value) {
               builderResult.downloadUrls = value
           }
      }
      public func setDownloadUrls(value:Array<Pogoprotos.Data.DownloadUrlEntry>) -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        self.downloadUrls = value
        return self
      }
      public func clearDownloadUrls() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        builderResult.downloadUrls.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetDownloadUrlsResponse) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetDownloadUrlsResponse() {
         return self
        }
        if !other.downloadUrls.isEmpty  {
           builderResult.downloadUrls += other.downloadUrls
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Data.DownloadUrlEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            downloadUrls += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder()
        if let jsonValueDownloadUrls = jsonMap["downloadUrls"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayDownloadUrls:Array<Pogoprotos.Data.DownloadUrlEntry> = []
          for oneValueDownloadUrls in jsonValueDownloadUrls {
            let messageFromStringDownloadUrls = try Pogoprotos.Data.DownloadUrlEntry.Builder.decodeToBuilder(oneValueDownloadUrls).build()

            jsonArrayDownloadUrls += [messageFromStringDownloadUrls]
          }
          resultDecodedBuilder.downloadUrls = jsonArrayDownloadUrls
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetDownloadUrlsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetGymDetailsResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorNotInRange = 2
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorNotInRange: return ".ErrorNotInRange"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var hasGymState:Bool = false
    public private(set) var gymState:Pogoprotos.Data.Gym.GymState!
    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var urls:Array<String> = Array<String>()
    public private(set) var result:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasDescription:Bool = false
    public private(set) var description_:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasGymState {
        try output.writeMessage(1, value:gymState)
      }
      if hasName {
        try output.writeString(2, value:name)
      }
      if !urls.isEmpty {
        for oneValueurls in urls {
          try output.writeString(3, value:oneValueurls)
        }
      }
      if hasResult {
        try output.writeEnum(4, value:result.rawValue)
      }
      if hasDescription {
        try output.writeString(5, value:description_)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasGymState {
          if let varSizegymState = gymState?.computeMessageSize(1) {
              serialize_size += varSizegymState
          }
      }
      if hasName {
        serialize_size += name.computeStringSize(2)
      }
      var dataSizeUrls:Int32 = 0
      for oneValueurls in urls {
          dataSizeUrls += oneValueurls.computeStringSizeNoTag()
      }
      serialize_size += dataSizeUrls
      serialize_size += 1 * Int32(urls.count)
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(4)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetGymDetailsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetGymDetailsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse? {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetGymDetailsResponse) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasGymState {
        jsonMap["gymState"] = try gymState.encode()
      }
      if hasName {
        jsonMap["name"] = name
      }
      if !urls.isEmpty {
        jsonMap["urls"] = urls
      }
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasDescription {
        jsonMap["description"] = description_
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
      return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasGymState {
        output += "\(indent) gymState {\n"
        if let outDescGymState = gymState {
          output += try outDescGymState.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      var urlsElementIndex:Int = 0
      for oneValueUrls in urls  {
          output += "\(indent) urls[\(urlsElementIndex)]: \(oneValueUrls)\n"
          urlsElementIndex += 1
      }
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasDescription {
        output += "\(indent) description_: \(description_) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasGymState {
                if let hashValuegymState = gymState?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegymState
                }
            }
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            for oneValueUrls in urls {
                hashCode = (hashCode &* 31) &+ oneValueUrls.hashValue
            }
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetGymDetailsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetGymDetailsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetGymDetailsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetGymDetailsResponse = Pogoprotos.Networking.Responses.GetGymDetailsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasGymState:Bool {
           get {
               return builderResult.hasGymState
           }
      }
      public var gymState:Pogoprotos.Data.Gym.GymState! {
           get {
               if gymStateBuilder_ != nil {
                  builderResult.gymState = gymStateBuilder_.getMessage()
               }
               return builderResult.gymState
           }
           set (value) {
               builderResult.hasGymState = true
               builderResult.gymState = value
           }
      }
      private var gymStateBuilder_:Pogoprotos.Data.Gym.GymState.Builder! {
           didSet {
              builderResult.hasGymState = true
           }
      }
      public func getGymStateBuilder() -> Pogoprotos.Data.Gym.GymState.Builder {
        if gymStateBuilder_ == nil {
           gymStateBuilder_ = Pogoprotos.Data.Gym.GymState.Builder()
           builderResult.gymState = gymStateBuilder_.getMessage()
           if gymState != nil {
              try! gymStateBuilder_.mergeFrom(gymState)
           }
        }
        return gymStateBuilder_
      }
      public func setGymState(value:Pogoprotos.Data.Gym.GymState!) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.gymState = value
        return self
      }
      public func mergeGymState(value:Pogoprotos.Data.Gym.GymState) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        if builderResult.hasGymState {
          builderResult.gymState = try Pogoprotos.Data.Gym.GymState.builderWithPrototype(builderResult.gymState).mergeFrom(value).buildPartial()
        } else {
          builderResult.gymState = value
        }
        builderResult.hasGymState = true
        return self
      }
      public func clearGymState() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        gymStateBuilder_ = nil
        builderResult.hasGymState = false
        builderResult.gymState = nil
        return self
      }
      public var hasName:Bool {
           get {
                return builderResult.hasName
           }
      }
      public var name:String {
           get {
                return builderResult.name
           }
           set (value) {
               builderResult.hasName = true
               builderResult.name = value
           }
      }
      public func setName(value:String) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.name = value
        return self
      }
      public func clearName() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder{
           builderResult.hasName = false
           builderResult.name = ""
           return self
      }
      public var urls:Array<String> {
           get {
               return builderResult.urls
           }
           set (array) {
               builderResult.urls = array
           }
      }
      public func setUrls(value:Array<String>) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.urls = value
        return self
      }
      public func clearUrls() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
         builderResult.urls.removeAll(keepCapacity: false)
         return self
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      public func setDescription(value:String) -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        self.description_ = value
        return self
      }
      public func clearDescription() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetGymDetailsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetGymDetailsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetGymDetailsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetGymDetailsResponse) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetGymDetailsResponse() {
         return self
        }
        if (other.hasGymState) {
            try mergeGymState(other.gymState)
        }
        if other.hasName {
             name = other.name
        }
        if !other.urls.isEmpty {
            builderResult.urls += other.urls
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasDescription {
             description_ = other.description_
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder:Pogoprotos.Data.Gym.GymState.Builder = Pogoprotos.Data.Gym.GymState.Builder()
            if hasGymState {
              try subBuilder.mergeFrom(gymState)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            gymState = subBuilder.buildPartial()

          case 18:
            name = try input.readString()

          case 26:
            urls += [try input.readString()]

          case 32:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntresult))
            }

          case 42:
            description_ = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder()
        if let jsonValueGymState = jsonMap["gymState"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.gymState = try Pogoprotos.Data.Gym.GymState.Builder.decodeToBuilder(jsonValueGymState).build()

        }
        if let jsonValueName = jsonMap["name"] as? String {
          resultDecodedBuilder.name = jsonValueName
        }
        if let jsonValueUrls = jsonMap["urls"] as? Array<String> {
          resultDecodedBuilder.urls = jsonValueUrls
        }
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueDescription = jsonMap["description"] as? String {
          resultDecodedBuilder.description_ = jsonValueDescription
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetGymDetailsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetHatchedEggsResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var pokemonId:Array<UInt64> = Array<UInt64>()
    private var pokemonIdMemoizedSerializedSize:Int32 = -1
    public private(set) var experienceAwarded:Array<Int32> = Array<Int32>()
    private var experienceAwardedMemoizedSerializedSize:Int32 = -1
    public private(set) var candyAwarded:Array<Int32> = Array<Int32>()
    private var candyAwardedMemoizedSerializedSize:Int32 = -1
    public private(set) var stardustAwarded:Array<Int32> = Array<Int32>()
    private var stardustAwardedMemoizedSerializedSize:Int32 = -1
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if !pokemonId.isEmpty {
        try output.writeRawVarint32(18)
        try output.writeRawVarint32(pokemonIdMemoizedSerializedSize)
        for oneValuepokemonId in pokemonId {
          try output.writeUInt64NoTag(oneValuepokemonId)
        }
      }
      if !experienceAwarded.isEmpty {
        try output.writeRawVarint32(26)
        try output.writeRawVarint32(experienceAwardedMemoizedSerializedSize)
        for oneValueexperienceAwarded in experienceAwarded {
          try output.writeInt32NoTag(oneValueexperienceAwarded)
        }
      }
      if !candyAwarded.isEmpty {
        try output.writeRawVarint32(34)
        try output.writeRawVarint32(candyAwardedMemoizedSerializedSize)
        for oneValuecandyAwarded in candyAwarded {
          try output.writeInt32NoTag(oneValuecandyAwarded)
        }
      }
      if !stardustAwarded.isEmpty {
        try output.writeRawVarint32(42)
        try output.writeRawVarint32(stardustAwardedMemoizedSerializedSize)
        for oneValuestardustAwarded in stardustAwarded {
          try output.writeInt32NoTag(oneValuestardustAwarded)
        }
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      var dataSizePokemonId:Int32 = 0
      for oneValuepokemonId in pokemonId {
          dataSizePokemonId += oneValuepokemonId.computeUInt64SizeNoTag()
      }
      serialize_size += dataSizePokemonId
      if !pokemonId.isEmpty {
        serialize_size += 1
        serialize_size += dataSizePokemonId.computeInt32SizeNoTag()
      }
      pokemonIdMemoizedSerializedSize = dataSizePokemonId
      var dataSizeExperienceAwarded:Int32 = 0
      for oneValueexperienceAwarded in experienceAwarded {
          dataSizeExperienceAwarded += oneValueexperienceAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeExperienceAwarded
      if !experienceAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeExperienceAwarded.computeInt32SizeNoTag()
      }
      experienceAwardedMemoizedSerializedSize = dataSizeExperienceAwarded
      var dataSizeCandyAwarded:Int32 = 0
      for oneValuecandyAwarded in candyAwarded {
          dataSizeCandyAwarded += oneValuecandyAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeCandyAwarded
      if !candyAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeCandyAwarded.computeInt32SizeNoTag()
      }
      candyAwardedMemoizedSerializedSize = dataSizeCandyAwarded
      var dataSizeStardustAwarded:Int32 = 0
      for oneValuestardustAwarded in stardustAwarded {
          dataSizeStardustAwarded += oneValuestardustAwarded.computeInt32SizeNoTag()
      }
      serialize_size += dataSizeStardustAwarded
      if !stardustAwarded.isEmpty {
        serialize_size += 1
        serialize_size += dataSizeStardustAwarded.computeInt32SizeNoTag()
      }
      stardustAwardedMemoizedSerializedSize = dataSizeStardustAwarded
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetHatchedEggsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetHatchedEggsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse? {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetHatchedEggsResponse) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if !pokemonId.isEmpty {
        var jsonArrayPokemonId:Array<String> = []
          for oneValuePokemonId in pokemonId {
            jsonArrayPokemonId += ["\(oneValuePokemonId)"]
          }
        jsonMap["pokemonId"] = jsonArrayPokemonId
      }
      if !experienceAwarded.isEmpty {
        var jsonArrayExperienceAwarded:Array<NSNumber> = []
          for oneValueExperienceAwarded in experienceAwarded {
            jsonArrayExperienceAwarded += [NSNumber(int:oneValueExperienceAwarded)]
          }
        jsonMap["experienceAwarded"] = jsonArrayExperienceAwarded
      }
      if !candyAwarded.isEmpty {
        var jsonArrayCandyAwarded:Array<NSNumber> = []
          for oneValueCandyAwarded in candyAwarded {
            jsonArrayCandyAwarded += [NSNumber(int:oneValueCandyAwarded)]
          }
        jsonMap["candyAwarded"] = jsonArrayCandyAwarded
      }
      if !stardustAwarded.isEmpty {
        var jsonArrayStardustAwarded:Array<NSNumber> = []
          for oneValueStardustAwarded in stardustAwarded {
            jsonArrayStardustAwarded += [NSNumber(int:oneValueStardustAwarded)]
          }
        jsonMap["stardustAwarded"] = jsonArrayStardustAwarded
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
      return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var pokemonIdElementIndex:Int = 0
      for oneValuePokemonId in pokemonId  {
          output += "\(indent) pokemonId[\(pokemonIdElementIndex)]: \(oneValuePokemonId)\n"
          pokemonIdElementIndex += 1
      }
      var experienceAwardedElementIndex:Int = 0
      for oneValueExperienceAwarded in experienceAwarded  {
          output += "\(indent) experienceAwarded[\(experienceAwardedElementIndex)]: \(oneValueExperienceAwarded)\n"
          experienceAwardedElementIndex += 1
      }
      var candyAwardedElementIndex:Int = 0
      for oneValueCandyAwarded in candyAwarded  {
          output += "\(indent) candyAwarded[\(candyAwardedElementIndex)]: \(oneValueCandyAwarded)\n"
          candyAwardedElementIndex += 1
      }
      var stardustAwardedElementIndex:Int = 0
      for oneValueStardustAwarded in stardustAwarded  {
          output += "\(indent) stardustAwarded[\(stardustAwardedElementIndex)]: \(oneValueStardustAwarded)\n"
          stardustAwardedElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValuePokemonId in pokemonId {
                hashCode = (hashCode &* 31) &+ oneValuePokemonId.hashValue
            }
            for oneValueExperienceAwarded in experienceAwarded {
                hashCode = (hashCode &* 31) &+ oneValueExperienceAwarded.hashValue
            }
            for oneValueCandyAwarded in candyAwarded {
                hashCode = (hashCode &* 31) &+ oneValueCandyAwarded.hashValue
            }
            for oneValueStardustAwarded in stardustAwarded {
                hashCode = (hashCode &* 31) &+ oneValueStardustAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetHatchedEggsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetHatchedEggsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetHatchedEggsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetHatchedEggsResponse = Pogoprotos.Networking.Responses.GetHatchedEggsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var pokemonId:Array<UInt64> {
           get {
               return builderResult.pokemonId
           }
           set (array) {
               builderResult.pokemonId = array
           }
      }
      public func setPokemonId(value:Array<UInt64>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.pokemonId = value
        return self
      }
      public func clearPokemonId() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.pokemonId.removeAll(keepCapacity: false)
         return self
      }
      public var experienceAwarded:Array<Int32> {
           get {
               return builderResult.experienceAwarded
           }
           set (array) {
               builderResult.experienceAwarded = array
           }
      }
      public func setExperienceAwarded(value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.experienceAwarded = value
        return self
      }
      public func clearExperienceAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.experienceAwarded.removeAll(keepCapacity: false)
         return self
      }
      public var candyAwarded:Array<Int32> {
           get {
               return builderResult.candyAwarded
           }
           set (array) {
               builderResult.candyAwarded = array
           }
      }
      public func setCandyAwarded(value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.candyAwarded = value
        return self
      }
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.candyAwarded.removeAll(keepCapacity: false)
         return self
      }
      public var stardustAwarded:Array<Int32> {
           get {
               return builderResult.stardustAwarded
           }
           set (array) {
               builderResult.stardustAwarded = array
           }
      }
      public func setStardustAwarded(value:Array<Int32>) -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        self.stardustAwarded = value
        return self
      }
      public func clearStardustAwarded() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
         builderResult.stardustAwarded.removeAll(keepCapacity: false)
         return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetHatchedEggsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetHatchedEggsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetHatchedEggsResponse) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetHatchedEggsResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.pokemonId.isEmpty {
            builderResult.pokemonId += other.pokemonId
        }
        if !other.experienceAwarded.isEmpty {
            builderResult.experienceAwarded += other.experienceAwarded
        }
        if !other.candyAwarded.isEmpty {
            builderResult.candyAwarded += other.candyAwarded
        }
        if !other.stardustAwarded.isEmpty {
            builderResult.stardustAwarded += other.stardustAwarded
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 18:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.pokemonId += [try input.readUInt64()]
            }
            input.popLimit(limit)

          case 26:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.experienceAwarded += [try input.readInt32()]
            }
            input.popLimit(limit)

          case 34:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.candyAwarded += [try input.readInt32()]
            }
            input.popLimit(limit)

          case 42:
            let length:Int32 = try input.readRawVarint32()
            let limit:Int32 = try input.pushLimit(length)
            while (input.bytesUntilLimit() > 0) {
              builderResult.stardustAwarded += [try input.readInt32()]
            }
            input.popLimit(limit)

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePokemonId = jsonMap["pokemonId"] as? Array<String> {
          var jsonArrayPokemonId:Array<UInt64> = []
          for oneValuePokemonId in jsonValuePokemonId {
            jsonArrayPokemonId += [UInt64(oneValuePokemonId)!]
          }
          resultDecodedBuilder.pokemonId = jsonArrayPokemonId
        }
        if let jsonValueExperienceAwarded = jsonMap["experienceAwarded"] as? Array<NSNumber> {
          var jsonArrayExperienceAwarded:Array<Int32> = []
          for oneValueExperienceAwarded in jsonValueExperienceAwarded {
            jsonArrayExperienceAwarded += [oneValueExperienceAwarded.intValue]
          }
          resultDecodedBuilder.experienceAwarded = jsonArrayExperienceAwarded
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? Array<NSNumber> {
          var jsonArrayCandyAwarded:Array<Int32> = []
          for oneValueCandyAwarded in jsonValueCandyAwarded {
            jsonArrayCandyAwarded += [oneValueCandyAwarded.intValue]
          }
          resultDecodedBuilder.candyAwarded = jsonArrayCandyAwarded
        }
        if let jsonValueStardustAwarded = jsonMap["stardustAwarded"] as? Array<NSNumber> {
          var jsonArrayStardustAwarded:Array<Int32> = []
          for oneValueStardustAwarded in jsonValueStardustAwarded {
            jsonArrayStardustAwarded += [oneValueStardustAwarded.intValue]
          }
          resultDecodedBuilder.stardustAwarded = jsonArrayStardustAwarded
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetHatchedEggsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetIncensePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case IncenseEncounterUnknown = 0
        case IncenseEncounterAvailable = 1
        case IncenseEncounterNotAvailable = 2
        public func toString() -> String {
          switch self {
          case .IncenseEncounterUnknown: return "INCENSE_ENCOUNTER_UNKNOWN"
          case .IncenseEncounterAvailable: return "INCENSE_ENCOUNTER_AVAILABLE"
          case .IncenseEncounterNotAvailable: return "INCENSE_ENCOUNTER_NOT_AVAILABLE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result {
          switch str {
          case "INCENSE_ENCOUNTER_UNKNOWN":  return .IncenseEncounterUnknown
          case "INCENSE_ENCOUNTER_AVAILABLE":  return .IncenseEncounterAvailable
          case "INCENSE_ENCOUNTER_NOT_AVAILABLE":  return .IncenseEncounterNotAvailable
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .IncenseEncounterUnknown: return ".IncenseEncounterUnknown"
                case .IncenseEncounterAvailable: return ".IncenseEncounterAvailable"
                case .IncenseEncounterNotAvailable: return ".IncenseEncounterNotAvailable"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result.IncenseEncounterUnknown
    public private(set) var hasResult:Bool = false
    // TODO: PokemonType.proto or PokemonId.proto
    public private(set) var hasPokemonTypeId:Bool = false
    public private(set) var pokemonTypeId:Int32 = Int32(0)

    public private(set) var hasLatitude:Bool = false
    public private(set) var latitude:Double = Double(0)

    public private(set) var hasLongitude:Bool = false
    public private(set) var longitude:Double = Double(0)

    public private(set) var hasEncounterLocation:Bool = false
    public private(set) var encounterLocation:String = ""

    public private(set) var hasEncounterId:Bool = false
    public private(set) var encounterId:UInt64 = UInt64(0)

    public private(set) var hasDisappearTimestampMs:Bool = false
    public private(set) var disappearTimestampMs:Int64 = Int64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasPokemonTypeId {
        try output.writeInt32(2, value:pokemonTypeId)
      }
      if hasLatitude {
        try output.writeDouble(3, value:latitude)
      }
      if hasLongitude {
        try output.writeDouble(4, value:longitude)
      }
      if hasEncounterLocation {
        try output.writeString(5, value:encounterLocation)
      }
      if hasEncounterId {
        try output.writeUInt64(6, value:encounterId)
      }
      if hasDisappearTimestampMs {
        try output.writeInt64(7, value:disappearTimestampMs)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasPokemonTypeId {
        serialize_size += pokemonTypeId.computeInt32Size(2)
      }
      if hasLatitude {
        serialize_size += latitude.computeDoubleSize(3)
      }
      if hasLongitude {
        serialize_size += longitude.computeDoubleSize(4)
      }
      if hasEncounterLocation {
        serialize_size += encounterLocation.computeStringSize(5)
      }
      if hasEncounterId {
        serialize_size += encounterId.computeUInt64Size(6)
      }
      if hasDisappearTimestampMs {
        serialize_size += disappearTimestampMs.computeInt64Size(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetIncensePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetIncensePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse? {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetIncensePokemonResponse) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonTypeId {
        jsonMap["pokemonTypeId"] = NSNumber(int:pokemonTypeId)
      }
      if hasLatitude {
        jsonMap["latitude"] = NSNumber(double:latitude)
      }
      if hasLongitude {
        jsonMap["longitude"] = NSNumber(double:longitude)
      }
      if hasEncounterLocation {
        jsonMap["encounterLocation"] = encounterLocation
      }
      if hasEncounterId {
        jsonMap["encounterId"] = "\(encounterId)"
      }
      if hasDisappearTimestampMs {
        jsonMap["disappearTimestampMs"] = "\(disappearTimestampMs)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
      return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonTypeId {
        output += "\(indent) pokemonTypeId: \(pokemonTypeId) \n"
      }
      if hasLatitude {
        output += "\(indent) latitude: \(latitude) \n"
      }
      if hasLongitude {
        output += "\(indent) longitude: \(longitude) \n"
      }
      if hasEncounterLocation {
        output += "\(indent) encounterLocation: \(encounterLocation) \n"
      }
      if hasEncounterId {
        output += "\(indent) encounterId: \(encounterId) \n"
      }
      if hasDisappearTimestampMs {
        output += "\(indent) disappearTimestampMs: \(disappearTimestampMs) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonTypeId {
               hashCode = (hashCode &* 31) &+ pokemonTypeId.hashValue
            }
            if hasLatitude {
               hashCode = (hashCode &* 31) &+ latitude.hashValue
            }
            if hasLongitude {
               hashCode = (hashCode &* 31) &+ longitude.hashValue
            }
            if hasEncounterLocation {
               hashCode = (hashCode &* 31) &+ encounterLocation.hashValue
            }
            if hasEncounterId {
               hashCode = (hashCode &* 31) &+ encounterId.hashValue
            }
            if hasDisappearTimestampMs {
               hashCode = (hashCode &* 31) &+ disappearTimestampMs.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetIncensePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetIncensePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetIncensePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetIncensePokemonResponse = Pogoprotos.Networking.Responses.GetIncensePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .IncenseEncounterUnknown
           return self
        }
      public var hasPokemonTypeId:Bool {
           get {
                return builderResult.hasPokemonTypeId
           }
      }
      public var pokemonTypeId:Int32 {
           get {
                return builderResult.pokemonTypeId
           }
           set (value) {
               builderResult.hasPokemonTypeId = true
               builderResult.pokemonTypeId = value
           }
      }
      public func setPokemonTypeId(value:Int32) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.pokemonTypeId = value
        return self
      }
      public func clearPokemonTypeId() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasPokemonTypeId = false
           builderResult.pokemonTypeId = Int32(0)
           return self
      }
      public var hasLatitude:Bool {
           get {
                return builderResult.hasLatitude
           }
      }
      public var latitude:Double {
           get {
                return builderResult.latitude
           }
           set (value) {
               builderResult.hasLatitude = true
               builderResult.latitude = value
           }
      }
      public func setLatitude(value:Double) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.latitude = value
        return self
      }
      public func clearLatitude() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasLatitude = false
           builderResult.latitude = Double(0)
           return self
      }
      public var hasLongitude:Bool {
           get {
                return builderResult.hasLongitude
           }
      }
      public var longitude:Double {
           get {
                return builderResult.longitude
           }
           set (value) {
               builderResult.hasLongitude = true
               builderResult.longitude = value
           }
      }
      public func setLongitude(value:Double) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.longitude = value
        return self
      }
      public func clearLongitude() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasLongitude = false
           builderResult.longitude = Double(0)
           return self
      }
      public var hasEncounterLocation:Bool {
           get {
                return builderResult.hasEncounterLocation
           }
      }
      public var encounterLocation:String {
           get {
                return builderResult.encounterLocation
           }
           set (value) {
               builderResult.hasEncounterLocation = true
               builderResult.encounterLocation = value
           }
      }
      public func setEncounterLocation(value:String) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.encounterLocation = value
        return self
      }
      public func clearEncounterLocation() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasEncounterLocation = false
           builderResult.encounterLocation = ""
           return self
      }
      public var hasEncounterId:Bool {
           get {
                return builderResult.hasEncounterId
           }
      }
      public var encounterId:UInt64 {
           get {
                return builderResult.encounterId
           }
           set (value) {
               builderResult.hasEncounterId = true
               builderResult.encounterId = value
           }
      }
      public func setEncounterId(value:UInt64) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.encounterId = value
        return self
      }
      public func clearEncounterId() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasEncounterId = false
           builderResult.encounterId = UInt64(0)
           return self
      }
      public var hasDisappearTimestampMs:Bool {
           get {
                return builderResult.hasDisappearTimestampMs
           }
      }
      public var disappearTimestampMs:Int64 {
           get {
                return builderResult.disappearTimestampMs
           }
           set (value) {
               builderResult.hasDisappearTimestampMs = true
               builderResult.disappearTimestampMs = value
           }
      }
      public func setDisappearTimestampMs(value:Int64) -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        self.disappearTimestampMs = value
        return self
      }
      public func clearDisappearTimestampMs() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder{
           builderResult.hasDisappearTimestampMs = false
           builderResult.disappearTimestampMs = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetIncensePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetIncensePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetIncensePokemonResponse) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetIncensePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasPokemonTypeId {
             pokemonTypeId = other.pokemonTypeId
        }
        if other.hasLatitude {
             latitude = other.latitude
        }
        if other.hasLongitude {
             longitude = other.longitude
        }
        if other.hasEncounterLocation {
             encounterLocation = other.encounterLocation
        }
        if other.hasEncounterId {
             encounterId = other.encounterId
        }
        if other.hasDisappearTimestampMs {
             disappearTimestampMs = other.disappearTimestampMs
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            pokemonTypeId = try input.readInt32()

          case 25:
            latitude = try input.readDouble()

          case 33:
            longitude = try input.readDouble()

          case 42:
            encounterLocation = try input.readString()

          case 48:
            encounterId = try input.readUInt64()

          case 56:
            disappearTimestampMs = try input.readInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValuePokemonTypeId = jsonMap["pokemonTypeId"] as? NSNumber {
          resultDecodedBuilder.pokemonTypeId = jsonValuePokemonTypeId.intValue
        }
        if let jsonValueLatitude = jsonMap["latitude"] as? NSNumber {
          resultDecodedBuilder.latitude = jsonValueLatitude.doubleValue
        }
        if let jsonValueLongitude = jsonMap["longitude"] as? NSNumber {
          resultDecodedBuilder.longitude = jsonValueLongitude.doubleValue
        }
        if let jsonValueEncounterLocation = jsonMap["encounterLocation"] as? String {
          resultDecodedBuilder.encounterLocation = jsonValueEncounterLocation
        }
        if let jsonValueEncounterId = jsonMap["encounterId"] as? String {
          resultDecodedBuilder.encounterId = UInt64(jsonValueEncounterId)!
        }
        if let jsonValueDisappearTimestampMs = jsonMap["disappearTimestampMs"] as? String {
          resultDecodedBuilder.disappearTimestampMs = Int64(jsonValueDisappearTimestampMs)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetIncensePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetInventoryResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var hasInventoryDelta:Bool = false
    public private(set) var inventoryDelta:Pogoprotos.Inventory.InventoryDelta!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if hasInventoryDelta {
        try output.writeMessage(2, value:inventoryDelta)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      if hasInventoryDelta {
          if let varSizeinventoryDelta = inventoryDelta?.computeMessageSize(2) {
              serialize_size += varSizeinventoryDelta
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetInventoryResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetInventoryResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse? {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetInventoryResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetInventoryResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetInventoryResponse) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasInventoryDelta {
        jsonMap["inventoryDelta"] = try inventoryDelta.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
      return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasInventoryDelta {
        output += "\(indent) inventoryDelta {\n"
        if let outDescInventoryDelta = inventoryDelta {
          output += try outDescInventoryDelta.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasInventoryDelta {
                if let hashValueinventoryDelta = inventoryDelta?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueinventoryDelta
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetInventoryResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetInventoryResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetInventoryResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetInventoryResponse = Pogoprotos.Networking.Responses.GetInventoryResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetInventoryResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasInventoryDelta:Bool {
           get {
               return builderResult.hasInventoryDelta
           }
      }
      public var inventoryDelta:Pogoprotos.Inventory.InventoryDelta! {
           get {
               if inventoryDeltaBuilder_ != nil {
                  builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
               }
               return builderResult.inventoryDelta
           }
           set (value) {
               builderResult.hasInventoryDelta = true
               builderResult.inventoryDelta = value
           }
      }
      private var inventoryDeltaBuilder_:Pogoprotos.Inventory.InventoryDelta.Builder! {
           didSet {
              builderResult.hasInventoryDelta = true
           }
      }
      public func getInventoryDeltaBuilder() -> Pogoprotos.Inventory.InventoryDelta.Builder {
        if inventoryDeltaBuilder_ == nil {
           inventoryDeltaBuilder_ = Pogoprotos.Inventory.InventoryDelta.Builder()
           builderResult.inventoryDelta = inventoryDeltaBuilder_.getMessage()
           if inventoryDelta != nil {
              try! inventoryDeltaBuilder_.mergeFrom(inventoryDelta)
           }
        }
        return inventoryDeltaBuilder_
      }
      public func setInventoryDelta(value:Pogoprotos.Inventory.InventoryDelta!) -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        self.inventoryDelta = value
        return self
      }
      public func mergeInventoryDelta(value:Pogoprotos.Inventory.InventoryDelta) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        if builderResult.hasInventoryDelta {
          builderResult.inventoryDelta = try Pogoprotos.Inventory.InventoryDelta.builderWithPrototype(builderResult.inventoryDelta).mergeFrom(value).buildPartial()
        } else {
          builderResult.inventoryDelta = value
        }
        builderResult.hasInventoryDelta = true
        return self
      }
      public func clearInventoryDelta() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        inventoryDeltaBuilder_ = nil
        builderResult.hasInventoryDelta = false
        builderResult.inventoryDelta = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetInventoryResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetInventoryResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetInventoryResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetInventoryResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetInventoryResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetInventoryResponse) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetInventoryResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasInventoryDelta) {
            try mergeInventoryDelta(other.inventoryDelta)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 18:
            let subBuilder:Pogoprotos.Inventory.InventoryDelta.Builder = Pogoprotos.Inventory.InventoryDelta.Builder()
            if hasInventoryDelta {
              try subBuilder.mergeFrom(inventoryDelta)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            inventoryDelta = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetInventoryResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueInventoryDelta = jsonMap["inventoryDelta"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.inventoryDelta = try Pogoprotos.Inventory.InventoryDelta.Builder.decodeToBuilder(jsonValueInventoryDelta).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetInventoryResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetInventoryResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetMapObjectsResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var mapCells:Array<Pogoprotos.Map.MapCell>  = Array<Pogoprotos.Map.MapCell>()
    public private(set) var status:Pogoprotos.Map.MapObjectsStatus = Pogoprotos.Map.MapObjectsStatus.UnsetStatus
    public private(set) var hasStatus:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementMapCells in mapCells {
          try output.writeMessage(1, value:oneElementMapCells)
      }
      if hasStatus {
        try output.writeEnum(2, value:status.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementMapCells in mapCells {
          serialize_size += oneElementMapCells.computeMessageSize(1)
      }
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetMapObjectsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetMapObjectsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse? {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetMapObjectsResponse) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !mapCells.isEmpty {
        var jsonArrayMapCells:Array<Dictionary<String,AnyObject>> = []
          for oneValueMapCells in mapCells {
            let ecodedMessageMapCells = try oneValueMapCells.encode()
            jsonArrayMapCells += [ecodedMessageMapCells]
          }
        jsonMap["mapCells"] = jsonArrayMapCells
      }
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
      return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var mapCellsElementIndex:Int = 0
      for oneElementMapCells in mapCells {
          output += "\(indent) mapCells[\(mapCellsElementIndex)] {\n"
          output += try oneElementMapCells.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          mapCellsElementIndex += 1
      }
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementMapCells in mapCells {
                hashCode = (hashCode &* 31) &+ oneElementMapCells.hashValue
            }
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetMapObjectsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetMapObjectsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetMapObjectsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetMapObjectsResponse = Pogoprotos.Networking.Responses.GetMapObjectsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var mapCells:Array<Pogoprotos.Map.MapCell> {
           get {
               return builderResult.mapCells
           }
           set (value) {
               builderResult.mapCells = value
           }
      }
      public func setMapCells(value:Array<Pogoprotos.Map.MapCell>) -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        self.mapCells = value
        return self
      }
      public func clearMapCells() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        builderResult.mapCells.removeAll(keepCapacity: false)
        return self
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Map.MapObjectsStatus {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Map.MapObjectsStatus) -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .UnsetStatus
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetMapObjectsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetMapObjectsResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetMapObjectsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetMapObjectsResponse) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetMapObjectsResponse() {
         return self
        }
        if !other.mapCells.isEmpty  {
           builderResult.mapCells += other.mapCells
        }
        if other.hasStatus {
             status = other.status
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Map.MapCell.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            mapCells += [subBuilder.buildPartial()]

          case 16:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Map.MapObjectsStatus(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntstatus))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder()
        if let jsonValueMapCells = jsonMap["mapCells"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayMapCells:Array<Pogoprotos.Map.MapCell> = []
          for oneValueMapCells in jsonValueMapCells {
            let messageFromStringMapCells = try Pogoprotos.Map.MapCell.Builder.decodeToBuilder(oneValueMapCells).build()

            jsonArrayMapCells += [messageFromStringMapCells]
          }
          resultDecodedBuilder.mapCells = jsonArrayMapCells
        }
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Map.MapObjectsStatus.fromString(jsonValueStatus)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetMapObjectsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetPlayerProfileResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasStartTime:Bool = false
    public private(set) var startTime:Int64 = Int64(0)

    public private(set) var badges:Array<Pogoprotos.Data.PlayerBadge>  = Array<Pogoprotos.Data.PlayerBadge>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasStartTime {
        try output.writeInt64(2, value:startTime)
      }
      for oneElementBadges in badges {
          try output.writeMessage(3, value:oneElementBadges)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasStartTime {
        serialize_size += startTime.computeInt64Size(2)
      }
      for oneElementBadges in badges {
          serialize_size += oneElementBadges.computeMessageSize(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetPlayerProfileResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetPlayerProfileResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse? {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetPlayerProfileResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStartTime {
        jsonMap["startTime"] = "\(startTime)"
      }
      if !badges.isEmpty {
        var jsonArrayBadges:Array<Dictionary<String,AnyObject>> = []
          for oneValueBadges in badges {
            let ecodedMessageBadges = try oneValueBadges.encode()
            jsonArrayBadges += [ecodedMessageBadges]
          }
        jsonMap["badges"] = jsonArrayBadges
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStartTime {
        output += "\(indent) startTime: \(startTime) \n"
      }
      var badgesElementIndex:Int = 0
      for oneElementBadges in badges {
          output += "\(indent) badges[\(badgesElementIndex)] {\n"
          output += try oneElementBadges.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          badgesElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStartTime {
               hashCode = (hashCode &* 31) &+ startTime.hashValue
            }
            for oneElementBadges in badges {
                hashCode = (hashCode &* 31) &+ oneElementBadges.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerProfileResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerProfileResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetPlayerProfileResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetPlayerProfileResponse = Pogoprotos.Networking.Responses.GetPlayerProfileResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasStartTime:Bool {
           get {
                return builderResult.hasStartTime
           }
      }
      public var startTime:Int64 {
           get {
                return builderResult.startTime
           }
           set (value) {
               builderResult.hasStartTime = true
               builderResult.startTime = value
           }
      }
      public func setStartTime(value:Int64) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        self.startTime = value
        return self
      }
      public func clearStartTime() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder{
           builderResult.hasStartTime = false
           builderResult.startTime = Int64(0)
           return self
      }
      public var badges:Array<Pogoprotos.Data.PlayerBadge> {
           get {
               return builderResult.badges
           }
           set (value) {
               builderResult.badges = value
           }
      }
      public func setBadges(value:Array<Pogoprotos.Data.PlayerBadge>) -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        self.badges = value
        return self
      }
      public func clearBadges() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        builderResult.badges.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetPlayerProfileResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetPlayerProfileResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetPlayerProfileResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetPlayerProfileResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStartTime {
             startTime = other.startTime
        }
        if !other.badges.isEmpty  {
           builderResult.badges += other.badges
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            startTime = try input.readInt64()

          case 26:
            let subBuilder = Pogoprotos.Data.PlayerBadge.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            badges += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueStartTime = jsonMap["startTime"] as? String {
          resultDecodedBuilder.startTime = Int64(jsonValueStartTime)!
        }
        if let jsonValueBadges = jsonMap["badges"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayBadges:Array<Pogoprotos.Data.PlayerBadge> = []
          for oneValueBadges in jsonValueBadges {
            let messageFromStringBadges = try Pogoprotos.Data.PlayerBadge.Builder.decodeToBuilder(oneValueBadges).build()

            jsonArrayBadges += [messageFromStringBadges]
          }
          resultDecodedBuilder.badges = jsonArrayBadges
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetPlayerProfileResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetPlayerResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var hasPlayerData:Bool = false
    public private(set) var playerData:Pogoprotos.Data.PlayerData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if hasPlayerData {
        try output.writeMessage(2, value:playerData)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetPlayerResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetPlayerResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse? {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetPlayerResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetPlayerResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
      return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetPlayerResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetPlayerResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetPlayerResponse = Pogoprotos.Networking.Responses.GetPlayerResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetPlayerResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      private var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(playerData)
           }
        }
        return playerDataBuilder_
      }
      public func setPlayerData(value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        self.playerData = value
        return self
      }
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(builderResult.playerData).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetPlayerResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetPlayerResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetPlayerResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetPlayerResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetPlayerResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetPlayerResponse) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetPlayerResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasPlayerData) {
            try mergePlayerData(other.playerData)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(playerData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetPlayerResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetPlayerResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetPlayerResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class GetSuggestedCodenamesResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var codenames:Array<String> = Array<String>()
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if !codenames.isEmpty {
        for oneValuecodenames in codenames {
          try output.writeString(1, value:oneValuecodenames)
        }
      }
      if hasSuccess {
        try output.writeBool(2, value:success)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      var dataSizeCodenames:Int32 = 0
      for oneValuecodenames in codenames {
          dataSizeCodenames += oneValuecodenames.computeStringSizeNoTag()
      }
      serialize_size += dataSizeCodenames
      serialize_size += 1 * Int32(codenames.count)
      if hasSuccess {
        serialize_size += success.computeBoolSize(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse? {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.classBuilder() as! Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !codenames.isEmpty {
        jsonMap["codenames"] = codenames
      }
      if hasSuccess {
        jsonMap["success"] = success
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
      return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var codenamesElementIndex:Int = 0
      for oneValueCodenames in codenames  {
          output += "\(indent) codenames[\(codenamesElementIndex)]: \(oneValueCodenames)\n"
          codenamesElementIndex += 1
      }
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueCodenames in codenames {
                hashCode = (hashCode &* 31) &+ oneValueCodenames.hashValue
            }
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var codenames:Array<String> {
           get {
               return builderResult.codenames
           }
           set (array) {
               builderResult.codenames = array
           }
      }
      public func setCodenames(value:Array<String>) -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        self.codenames = value
        return self
      }
      public func clearCodenames() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
         builderResult.codenames.removeAll(keepCapacity: false)
         return self
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse {
        let returnMe:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        if other == Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse() {
         return self
        }
        if !other.codenames.isEmpty {
            builderResult.codenames += other.codenames
        }
        if other.hasSuccess {
             success = other.success
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            codenames += [try input.readString()]

          case 16:
            success = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder()
        if let jsonValueCodenames = jsonMap["codenames"] as? Array<String> {
          resultDecodedBuilder.codenames = jsonValueCodenames
        }
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.GetSuggestedCodenamesResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class IncenseEncounterResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case IncenseEncounterUnknown = 0
        case IncenseEncounterSuccess = 1
        case IncenseEncounterNotAvailable = 2
        case PokemonInventoryFull = 3
        public func toString() -> String {
          switch self {
          case .IncenseEncounterUnknown: return "INCENSE_ENCOUNTER_UNKNOWN"
          case .IncenseEncounterSuccess: return "INCENSE_ENCOUNTER_SUCCESS"
          case .IncenseEncounterNotAvailable: return "INCENSE_ENCOUNTER_NOT_AVAILABLE"
          case .PokemonInventoryFull: return "POKEMON_INVENTORY_FULL"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result {
          switch str {
          case "INCENSE_ENCOUNTER_UNKNOWN":  return .IncenseEncounterUnknown
          case "INCENSE_ENCOUNTER_SUCCESS":  return .IncenseEncounterSuccess
          case "INCENSE_ENCOUNTER_NOT_AVAILABLE":  return .IncenseEncounterNotAvailable
          case "POKEMON_INVENTORY_FULL":  return .PokemonInventoryFull
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .IncenseEncounterUnknown: return ".IncenseEncounterUnknown"
                case .IncenseEncounterSuccess: return ".IncenseEncounterSuccess"
                case .IncenseEncounterNotAvailable: return ".IncenseEncounterNotAvailable"
                case .PokemonInventoryFull: return ".PokemonInventoryFull"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result.IncenseEncounterUnknown
    public private(set) var hasResult:Bool = false
    public private(set) var hasPokemonData:Bool = false
    public private(set) var pokemonData:Pogoprotos.Data.PokemonData!
    public private(set) var hasCaptureProbability:Bool = false
    public private(set) var captureProbability:Pogoprotos.Data.Capture.CaptureProbability!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasPokemonData {
        try output.writeMessage(2, value:pokemonData)
      }
      if hasCaptureProbability {
        try output.writeMessage(3, value:captureProbability)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasPokemonData {
          if let varSizepokemonData = pokemonData?.computeMessageSize(2) {
              serialize_size += varSizepokemonData
          }
      }
      if hasCaptureProbability {
          if let varSizecaptureProbability = captureProbability?.computeMessageSize(3) {
              serialize_size += varSizecaptureProbability
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.IncenseEncounterResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.IncenseEncounterResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse? {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.classBuilder() as! Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.IncenseEncounterResponse) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasPokemonData {
        jsonMap["pokemonData"] = try pokemonData.encode()
      }
      if hasCaptureProbability {
        jsonMap["captureProbability"] = try captureProbability.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
      return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasPokemonData {
        output += "\(indent) pokemonData {\n"
        if let outDescPokemonData = pokemonData {
          output += try outDescPokemonData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasCaptureProbability {
        output += "\(indent) captureProbability {\n"
        if let outDescCaptureProbability = captureProbability {
          output += try outDescCaptureProbability.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasPokemonData {
                if let hashValuepokemonData = pokemonData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepokemonData
                }
            }
            if hasCaptureProbability {
                if let hashValuecaptureProbability = captureProbability?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecaptureProbability
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.IncenseEncounterResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.IncenseEncounterResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.IncenseEncounterResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.IncenseEncounterResponse = Pogoprotos.Networking.Responses.IncenseEncounterResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .IncenseEncounterUnknown
           return self
        }
      public var hasPokemonData:Bool {
           get {
               return builderResult.hasPokemonData
           }
      }
      public var pokemonData:Pogoprotos.Data.PokemonData! {
           get {
               if pokemonDataBuilder_ != nil {
                  builderResult.pokemonData = pokemonDataBuilder_.getMessage()
               }
               return builderResult.pokemonData
           }
           set (value) {
               builderResult.hasPokemonData = true
               builderResult.pokemonData = value
           }
      }
      private var pokemonDataBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasPokemonData = true
           }
      }
      public func getPokemonDataBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if pokemonDataBuilder_ == nil {
           pokemonDataBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.pokemonData = pokemonDataBuilder_.getMessage()
           if pokemonData != nil {
              try! pokemonDataBuilder_.mergeFrom(pokemonData)
           }
        }
        return pokemonDataBuilder_
      }
      public func setPokemonData(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        self.pokemonData = value
        return self
      }
      public func mergePokemonData(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if builderResult.hasPokemonData {
          builderResult.pokemonData = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.pokemonData).mergeFrom(value).buildPartial()
        } else {
          builderResult.pokemonData = value
        }
        builderResult.hasPokemonData = true
        return self
      }
      public func clearPokemonData() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        pokemonDataBuilder_ = nil
        builderResult.hasPokemonData = false
        builderResult.pokemonData = nil
        return self
      }
      public var hasCaptureProbability:Bool {
           get {
               return builderResult.hasCaptureProbability
           }
      }
      public var captureProbability:Pogoprotos.Data.Capture.CaptureProbability! {
           get {
               if captureProbabilityBuilder_ != nil {
                  builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
               }
               return builderResult.captureProbability
           }
           set (value) {
               builderResult.hasCaptureProbability = true
               builderResult.captureProbability = value
           }
      }
      private var captureProbabilityBuilder_:Pogoprotos.Data.Capture.CaptureProbability.Builder! {
           didSet {
              builderResult.hasCaptureProbability = true
           }
      }
      public func getCaptureProbabilityBuilder() -> Pogoprotos.Data.Capture.CaptureProbability.Builder {
        if captureProbabilityBuilder_ == nil {
           captureProbabilityBuilder_ = Pogoprotos.Data.Capture.CaptureProbability.Builder()
           builderResult.captureProbability = captureProbabilityBuilder_.getMessage()
           if captureProbability != nil {
              try! captureProbabilityBuilder_.mergeFrom(captureProbability)
           }
        }
        return captureProbabilityBuilder_
      }
      public func setCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability!) -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        self.captureProbability = value
        return self
      }
      public func mergeCaptureProbability(value:Pogoprotos.Data.Capture.CaptureProbability) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if builderResult.hasCaptureProbability {
          builderResult.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.builderWithPrototype(builderResult.captureProbability).mergeFrom(value).buildPartial()
        } else {
          builderResult.captureProbability = value
        }
        builderResult.hasCaptureProbability = true
        return self
      }
      public func clearCaptureProbability() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        captureProbabilityBuilder_ = nil
        builderResult.hasCaptureProbability = false
        builderResult.captureProbability = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.IncenseEncounterResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.IncenseEncounterResponse {
        let returnMe:Pogoprotos.Networking.Responses.IncenseEncounterResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.IncenseEncounterResponse) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        if other == Pogoprotos.Networking.Responses.IncenseEncounterResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasPokemonData) {
            try mergePokemonData(other.pokemonData)
        }
        if (other.hasCaptureProbability) {
            try mergeCaptureProbability(other.captureProbability)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasPokemonData {
              try subBuilder.mergeFrom(pokemonData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            pokemonData = subBuilder.buildPartial()

          case 26:
            let subBuilder:Pogoprotos.Data.Capture.CaptureProbability.Builder = Pogoprotos.Data.Capture.CaptureProbability.Builder()
            if hasCaptureProbability {
              try subBuilder.mergeFrom(captureProbability)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            captureProbability = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValuePokemonData = jsonMap["pokemonData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.pokemonData = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValuePokemonData).build()

        }
        if let jsonValueCaptureProbability = jsonMap["captureProbability"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.captureProbability = try Pogoprotos.Data.Capture.CaptureProbability.Builder.decodeToBuilder(jsonValueCaptureProbability).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.IncenseEncounterResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class LevelUpRewardsResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case AwardedAlready = 2
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .AwardedAlready: return "AWARDED_ALREADY"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "AWARDED_ALREADY":  return .AwardedAlready
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .AwardedAlready: return ".AwardedAlready"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward>  = Array<Pogoprotos.Inventory.Item.ItemAward>()
    private var itemsUnlockedMemoizedSerializedSize:Int32 = 0
    public private(set) var itemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> = Array<Pogoprotos.Inventory.Item.ItemId>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      for oneElementItemsAwarded in itemsAwarded {
          try output.writeMessage(2, value:oneElementItemsAwarded)
      }
      for oneValueOfitemsUnlocked in itemsUnlocked {
          try output.writeEnum(4, value:oneValueOfitemsUnlocked.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      for oneElementItemsAwarded in itemsAwarded {
          serialize_size += oneElementItemsAwarded.computeMessageSize(2)
      }
      var dataSizeitemsUnlocked:Int32 = 0
      for oneValueOfitemsUnlocked in itemsUnlocked {
          dataSizeitemsUnlocked += oneValueOfitemsUnlocked.rawValue.computeEnumSizeNoTag()
      }
      serialize_size += dataSizeitemsUnlocked
      serialize_size += (1 * Int32(itemsUnlocked.count))
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.LevelUpRewardsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.LevelUpRewardsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse? {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.classBuilder() as! Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.LevelUpRewardsResponse) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !itemsAwarded.isEmpty {
        var jsonArrayItemsAwarded:Array<Dictionary<String,AnyObject>> = []
          for oneValueItemsAwarded in itemsAwarded {
            let ecodedMessageItemsAwarded = try oneValueItemsAwarded.encode()
            jsonArrayItemsAwarded += [ecodedMessageItemsAwarded]
          }
        jsonMap["itemsAwarded"] = jsonArrayItemsAwarded
      }
      if !itemsUnlocked.isEmpty {
        var jsonArrayItemsUnlocked:Array<String> = []
          for oneValueItemsUnlocked in itemsUnlocked {
            jsonArrayItemsUnlocked += [oneValueItemsUnlocked.toString()]
          }
        jsonMap["itemsUnlocked"] = jsonArrayItemsUnlocked
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
      return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var itemsAwardedElementIndex:Int = 0
      for oneElementItemsAwarded in itemsAwarded {
          output += "\(indent) itemsAwarded[\(itemsAwardedElementIndex)] {\n"
          output += try oneElementItemsAwarded.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          itemsAwardedElementIndex += 1
      }
      var itemsUnlockedElementIndex:Int = 0
      for oneValueOfitemsUnlocked in itemsUnlocked {
          output += "\(indent) itemsUnlocked[\(itemsUnlockedElementIndex)]: \(oneValueOfitemsUnlocked.description)\n"
          itemsUnlockedElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementItemsAwarded in itemsAwarded {
                hashCode = (hashCode &* 31) &+ oneElementItemsAwarded.hashValue
            }
            for oneValueOfitemsUnlocked in itemsUnlocked {
                hashCode = (hashCode &* 31) &+ Int(oneValueOfitemsUnlocked.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.LevelUpRewardsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.LevelUpRewardsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.LevelUpRewardsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.LevelUpRewardsResponse = Pogoprotos.Networking.Responses.LevelUpRewardsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var itemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> {
           get {
               return builderResult.itemsAwarded
           }
           set (value) {
               builderResult.itemsAwarded = value
           }
      }
      public func setItemsAwarded(value:Array<Pogoprotos.Inventory.Item.ItemAward>) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        self.itemsAwarded = value
        return self
      }
      public func clearItemsAwarded() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult.itemsAwarded.removeAll(keepCapacity: false)
        return self
      }
      public var itemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> {
          get {
              return builderResult.itemsUnlocked
          }
          set (value) {
              builderResult.itemsUnlocked = value
          }
      }
      public func setItemsUnlocked(value:Array<Pogoprotos.Inventory.Item.ItemId>) -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        self.itemsUnlocked = value
        return self
      }
      public func clearItemsUnlocked() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult.itemsUnlocked.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.LevelUpRewardsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse {
        let returnMe:Pogoprotos.Networking.Responses.LevelUpRewardsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.LevelUpRewardsResponse) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.LevelUpRewardsResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.itemsAwarded.isEmpty  {
           builderResult.itemsAwarded += other.itemsAwarded
        }
        if !other.itemsUnlocked.isEmpty {
           builderResult.itemsUnlocked += other.itemsUnlocked
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Inventory.Item.ItemAward.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            itemsAwarded += [subBuilder.buildPartial()]

          case 32:
            let valueIntitemsUnlocked = try input.readEnum()
            if let enumsitemsUnlocked = Pogoprotos.Inventory.Item.ItemId(rawValue:valueIntitemsUnlocked) {
                 builderResult.itemsUnlocked += [enumsitemsUnlocked]
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntitemsUnlocked))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueItemsAwarded = jsonMap["itemsAwarded"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayItemsAwarded:Array<Pogoprotos.Inventory.Item.ItemAward> = []
          for oneValueItemsAwarded in jsonValueItemsAwarded {
            let messageFromStringItemsAwarded = try Pogoprotos.Inventory.Item.ItemAward.Builder.decodeToBuilder(oneValueItemsAwarded).build()

            jsonArrayItemsAwarded += [messageFromStringItemsAwarded]
          }
          resultDecodedBuilder.itemsAwarded = jsonArrayItemsAwarded
        }
        if let jsonValueItemsUnlocked = jsonMap["itemsUnlocked"] as? Array<String> {
          var jsonArrayItemsUnlocked:Array<Pogoprotos.Inventory.Item.ItemId> = []
          for oneValueItemsUnlocked in jsonValueItemsUnlocked {
            let enumFromStringItemsUnlocked = try Pogoprotos.Inventory.Item.ItemId.fromString(oneValueItemsUnlocked)
            jsonArrayItemsUnlocked += [enumFromStringItemsUnlocked]
          }
          resultDecodedBuilder.itemsUnlocked = jsonArrayItemsUnlocked
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.LevelUpRewardsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class MarkTutorialCompleteResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var hasPlayerData:Bool = false
    public private(set) var playerData:Pogoprotos.Data.PlayerData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if hasPlayerData {
        try output.writeMessage(2, value:playerData)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse? {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.classBuilder() as! Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
      return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      private var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(playerData)
           }
        }
        return playerDataBuilder_
      }
      public func setPlayerData(value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        self.playerData = value
        return self
      }
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(builderResult.playerData).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse {
        let returnMe:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        if other == Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if (other.hasPlayerData) {
            try mergePlayerData(other.playerData)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(playerData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.MarkTutorialCompleteResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class NicknamePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorInvalidNickname = 2
        case ErrorPokemonNotFound = 3
        case ErrorPokemonIsEgg = 4
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorInvalidNickname: return "ERROR_INVALID_NICKNAME"
          case .ErrorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .ErrorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_INVALID_NICKNAME":  return .ErrorInvalidNickname
          case "ERROR_POKEMON_NOT_FOUND":  return .ErrorPokemonNotFound
          case "ERROR_POKEMON_IS_EGG":  return .ErrorPokemonIsEgg
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorInvalidNickname: return ".ErrorInvalidNickname"
                case .ErrorPokemonNotFound: return ".ErrorPokemonNotFound"
                case .ErrorPokemonIsEgg: return ".ErrorPokemonIsEgg"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.NicknamePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.NicknamePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse? {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.NicknamePokemonResponse) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
      return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.NicknamePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.NicknamePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.NicknamePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.NicknamePokemonResponse = Pogoprotos.Networking.Responses.NicknamePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result) -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.NicknamePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.NicknamePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.NicknamePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.NicknamePokemonResponse) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.NicknamePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Result.fromString(jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.NicknamePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class PlayerUpdateResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var wildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon>  = Array<Pogoprotos.Map.Pokemon.WildPokemon>()
    public private(set) var forts:Array<Pogoprotos.Map.Fort.FortData>  = Array<Pogoprotos.Map.Fort.FortData>()
    public private(set) var hasFortsNearby:Bool = false
    public private(set) var fortsNearby:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      for oneElementWildPokemons in wildPokemons {
          try output.writeMessage(1, value:oneElementWildPokemons)
      }
      for oneElementForts in forts {
          try output.writeMessage(2, value:oneElementForts)
      }
      if hasFortsNearby {
        try output.writeInt32(3, value:fortsNearby)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      for oneElementWildPokemons in wildPokemons {
          serialize_size += oneElementWildPokemons.computeMessageSize(1)
      }
      for oneElementForts in forts {
          serialize_size += oneElementForts.computeMessageSize(2)
      }
      if hasFortsNearby {
        serialize_size += fortsNearby.computeInt32Size(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.PlayerUpdateResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.PlayerUpdateResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse? {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.classBuilder() as! Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.PlayerUpdateResponse) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if !wildPokemons.isEmpty {
        var jsonArrayWildPokemons:Array<Dictionary<String,AnyObject>> = []
          for oneValueWildPokemons in wildPokemons {
            let ecodedMessageWildPokemons = try oneValueWildPokemons.encode()
            jsonArrayWildPokemons += [ecodedMessageWildPokemons]
          }
        jsonMap["wildPokemons"] = jsonArrayWildPokemons
      }
      if !forts.isEmpty {
        var jsonArrayForts:Array<Dictionary<String,AnyObject>> = []
          for oneValueForts in forts {
            let ecodedMessageForts = try oneValueForts.encode()
            jsonArrayForts += [ecodedMessageForts]
          }
        jsonMap["forts"] = jsonArrayForts
      }
      if hasFortsNearby {
        jsonMap["fortsNearby"] = NSNumber(int:fortsNearby)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
      return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      var wildPokemonsElementIndex:Int = 0
      for oneElementWildPokemons in wildPokemons {
          output += "\(indent) wildPokemons[\(wildPokemonsElementIndex)] {\n"
          output += try oneElementWildPokemons.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          wildPokemonsElementIndex += 1
      }
      var fortsElementIndex:Int = 0
      for oneElementForts in forts {
          output += "\(indent) forts[\(fortsElementIndex)] {\n"
          output += try oneElementForts.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          fortsElementIndex += 1
      }
      if hasFortsNearby {
        output += "\(indent) fortsNearby: \(fortsNearby) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementWildPokemons in wildPokemons {
                hashCode = (hashCode &* 31) &+ oneElementWildPokemons.hashValue
            }
            for oneElementForts in forts {
                hashCode = (hashCode &* 31) &+ oneElementForts.hashValue
            }
            if hasFortsNearby {
               hashCode = (hashCode &* 31) &+ fortsNearby.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.PlayerUpdateResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.PlayerUpdateResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.PlayerUpdateResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.PlayerUpdateResponse = Pogoprotos.Networking.Responses.PlayerUpdateResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var wildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon> {
           get {
               return builderResult.wildPokemons
           }
           set (value) {
               builderResult.wildPokemons = value
           }
      }
      public func setWildPokemons(value:Array<Pogoprotos.Map.Pokemon.WildPokemon>) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.wildPokemons = value
        return self
      }
      public func clearWildPokemons() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult.wildPokemons.removeAll(keepCapacity: false)
        return self
      }
      public var forts:Array<Pogoprotos.Map.Fort.FortData> {
           get {
               return builderResult.forts
           }
           set (value) {
               builderResult.forts = value
           }
      }
      public func setForts(value:Array<Pogoprotos.Map.Fort.FortData>) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.forts = value
        return self
      }
      public func clearForts() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult.forts.removeAll(keepCapacity: false)
        return self
      }
      public var hasFortsNearby:Bool {
           get {
                return builderResult.hasFortsNearby
           }
      }
      public var fortsNearby:Int32 {
           get {
                return builderResult.fortsNearby
           }
           set (value) {
               builderResult.hasFortsNearby = true
               builderResult.fortsNearby = value
           }
      }
      public func setFortsNearby(value:Int32) -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        self.fortsNearby = value
        return self
      }
      public func clearFortsNearby() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder{
           builderResult.hasFortsNearby = false
           builderResult.fortsNearby = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.PlayerUpdateResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.PlayerUpdateResponse {
        let returnMe:Pogoprotos.Networking.Responses.PlayerUpdateResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.PlayerUpdateResponse) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        if other == Pogoprotos.Networking.Responses.PlayerUpdateResponse() {
         return self
        }
        if !other.wildPokemons.isEmpty  {
           builderResult.wildPokemons += other.wildPokemons
        }
        if !other.forts.isEmpty  {
           builderResult.forts += other.forts
        }
        if other.hasFortsNearby {
             fortsNearby = other.fortsNearby
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 10:
            let subBuilder = Pogoprotos.Map.Pokemon.WildPokemon.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            wildPokemons += [subBuilder.buildPartial()]

          case 18:
            let subBuilder = Pogoprotos.Map.Fort.FortData.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            forts += [subBuilder.buildPartial()]

          case 24:
            fortsNearby = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder()
        if let jsonValueWildPokemons = jsonMap["wildPokemons"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayWildPokemons:Array<Pogoprotos.Map.Pokemon.WildPokemon> = []
          for oneValueWildPokemons in jsonValueWildPokemons {
            let messageFromStringWildPokemons = try Pogoprotos.Map.Pokemon.WildPokemon.Builder.decodeToBuilder(oneValueWildPokemons).build()

            jsonArrayWildPokemons += [messageFromStringWildPokemons]
          }
          resultDecodedBuilder.wildPokemons = jsonArrayWildPokemons
        }
        if let jsonValueForts = jsonMap["forts"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayForts:Array<Pogoprotos.Map.Fort.FortData> = []
          for oneValueForts in jsonValueForts {
            let messageFromStringForts = try Pogoprotos.Map.Fort.FortData.Builder.decodeToBuilder(oneValueForts).build()

            jsonArrayForts += [messageFromStringForts]
          }
          resultDecodedBuilder.forts = jsonArrayForts
        }
        if let jsonValueFortsNearby = jsonMap["fortsNearby"] as? NSNumber {
          resultDecodedBuilder.fortsNearby = jsonValueFortsNearby.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.PlayerUpdateResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class RecycleInventoryItemResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorNotEnoughCopies = 2
        case ErrorCannotRecycleIncubators = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorNotEnoughCopies: return "ERROR_NOT_ENOUGH_COPIES"
          case .ErrorCannotRecycleIncubators: return "ERROR_CANNOT_RECYCLE_INCUBATORS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_NOT_ENOUGH_COPIES":  return .ErrorNotEnoughCopies
          case "ERROR_CANNOT_RECYCLE_INCUBATORS":  return .ErrorCannotRecycleIncubators
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorNotEnoughCopies: return ".ErrorNotEnoughCopies"
                case .ErrorCannotRecycleIncubators: return ".ErrorCannotRecycleIncubators"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasNewCount:Bool = false
    public private(set) var newCount:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasNewCount {
        try output.writeInt32(2, value:newCount)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasNewCount {
        serialize_size += newCount.computeInt32Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.RecycleInventoryItemResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.RecycleInventoryItemResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse? {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.classBuilder() as! Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasNewCount {
        jsonMap["newCount"] = NSNumber(int:newCount)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
      return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasNewCount {
        output += "\(indent) newCount: \(newCount) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasNewCount {
               hashCode = (hashCode &* 31) &+ newCount.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.RecycleInventoryItemResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.RecycleInventoryItemResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result) -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasNewCount:Bool {
           get {
                return builderResult.hasNewCount
           }
      }
      public var newCount:Int32 {
           get {
                return builderResult.newCount
           }
           set (value) {
               builderResult.hasNewCount = true
               builderResult.newCount = value
           }
      }
      public func setNewCount(value:Int32) -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        self.newCount = value
        return self
      }
      public func clearNewCount() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder{
           builderResult.hasNewCount = false
           builderResult.newCount = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse {
        let returnMe:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.RecycleInventoryItemResponse) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        if other == Pogoprotos.Networking.Responses.RecycleInventoryItemResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasNewCount {
             newCount = other.newCount
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            newCount = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueNewCount = jsonMap["newCount"] as? NSNumber {
          resultDecodedBuilder.newCount = jsonValueNewCount.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.RecycleInventoryItemResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class ReleasePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case PokemonDeployed = 2
        case Failed = 3
        case ErrorPokemonIsEgg = 4
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .PokemonDeployed: return "POKEMON_DEPLOYED"
          case .Failed: return "FAILED"
          case .ErrorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "POKEMON_DEPLOYED":  return .PokemonDeployed
          case "FAILED":  return .Failed
          case "ERROR_POKEMON_IS_EGG":  return .ErrorPokemonIsEgg
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .PokemonDeployed: return ".PokemonDeployed"
                case .Failed: return ".Failed"
                case .ErrorPokemonIsEgg: return ".ErrorPokemonIsEgg"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasCandyAwarded:Bool = false
    public private(set) var candyAwarded:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasCandyAwarded {
        try output.writeInt32(2, value:candyAwarded)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasCandyAwarded {
        serialize_size += candyAwarded.computeInt32Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.ReleasePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.ReleasePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse? {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.ReleasePokemonResponse) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasCandyAwarded {
        jsonMap["candyAwarded"] = NSNumber(int:candyAwarded)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
      return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasCandyAwarded {
        output += "\(indent) candyAwarded: \(candyAwarded) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasCandyAwarded {
               hashCode = (hashCode &* 31) &+ candyAwarded.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.ReleasePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.ReleasePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.ReleasePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.ReleasePokemonResponse = Pogoprotos.Networking.Responses.ReleasePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result) -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasCandyAwarded:Bool {
           get {
                return builderResult.hasCandyAwarded
           }
      }
      public var candyAwarded:Int32 {
           get {
                return builderResult.candyAwarded
           }
           set (value) {
               builderResult.hasCandyAwarded = true
               builderResult.candyAwarded = value
           }
      }
      public func setCandyAwarded(value:Int32) -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        self.candyAwarded = value
        return self
      }
      public func clearCandyAwarded() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder{
           builderResult.hasCandyAwarded = false
           builderResult.candyAwarded = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.ReleasePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.ReleasePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.ReleasePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.ReleasePokemonResponse) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.ReleasePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasCandyAwarded {
             candyAwarded = other.candyAwarded
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            candyAwarded = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueCandyAwarded = jsonMap["candyAwarded"] as? NSNumber {
          resultDecodedBuilder.candyAwarded = jsonValueCandyAwarded.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.ReleasePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class SetAvatarResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case AvatarAlreadySet = 2
        case Failure = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .AvatarAlreadySet: return "AVATAR_ALREADY_SET"
          case .Failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Status {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "AVATAR_ALREADY_SET":  return .AvatarAlreadySet
          case "FAILURE":  return .Failure
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .AvatarAlreadySet: return ".AvatarAlreadySet"
                case .Failure: return ".Failure"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var status:Pogoprotos.Networking.Responses.SetAvatarResponse.Status = Pogoprotos.Networking.Responses.SetAvatarResponse.Status.Unset
    public private(set) var hasStatus:Bool = false
    public private(set) var hasPlayerData:Bool = false
    public private(set) var playerData:Pogoprotos.Data.PlayerData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStatus {
        try output.writeEnum(1, value:status.rawValue)
      }
      if hasPlayerData {
        try output.writeMessage(2, value:playerData)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.SetAvatarResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.SetAvatarResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse? {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetAvatarResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetAvatarResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetAvatarResponse) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
      return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetAvatarResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetAvatarResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.SetAvatarResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.SetAvatarResponse = Pogoprotos.Networking.Responses.SetAvatarResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetAvatarResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetAvatarResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.SetAvatarResponse.Status) -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .Unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      private var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(playerData)
           }
        }
        return playerDataBuilder_
      }
      public func setPlayerData(value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        self.playerData = value
        return self
      }
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(builderResult.playerData).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetAvatarResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetAvatarResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetAvatarResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetAvatarResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetAvatarResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetAvatarResponse) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetAvatarResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(other.playerData)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetAvatarResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(playerData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetAvatarResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetAvatarResponse.Status.fromString(jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.SetAvatarResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetAvatarResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class SetContactSettingsResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case Failure = 2
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .Failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "FAILURE":  return .Failure
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .Failure: return ".Failure"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var status:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status.Unset
    public private(set) var hasStatus:Bool = false
    public private(set) var hasPlayerData:Bool = false
    public private(set) var playerData:Pogoprotos.Data.PlayerData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStatus {
        try output.writeEnum(1, value:status.rawValue)
      }
      if hasPlayerData {
        try output.writeMessage(2, value:playerData)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.SetContactSettingsResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.SetContactSettingsResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse? {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetContactSettingsResponse) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
      return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetContactSettingsResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetContactSettingsResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.SetContactSettingsResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.SetContactSettingsResponse = Pogoprotos.Networking.Responses.SetContactSettingsResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status) -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .Unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      private var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(playerData)
           }
        }
        return playerDataBuilder_
      }
      public func setPlayerData(value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        self.playerData = value
        return self
      }
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(builderResult.playerData).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetContactSettingsResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetContactSettingsResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetContactSettingsResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetContactSettingsResponse) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetContactSettingsResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(other.playerData)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(playerData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Status.fromString(jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetContactSettingsResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class SetFavoritePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorPokemonNotFound = 2
        case ErrorPokemonIsEgg = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .ErrorPokemonIsEgg: return "ERROR_POKEMON_IS_EGG"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_POKEMON_NOT_FOUND":  return .ErrorPokemonNotFound
          case "ERROR_POKEMON_IS_EGG":  return .ErrorPokemonIsEgg
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorPokemonNotFound: return ".ErrorPokemonNotFound"
                case .ErrorPokemonIsEgg: return ".ErrorPokemonIsEgg"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.SetFavoritePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.SetFavoritePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse? {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
      return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetFavoritePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetFavoritePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result) -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetFavoritePokemonResponse) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetFavoritePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Result.fromString(jsonValueResult)
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetFavoritePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class SetPlayerTeamResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Status:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case TeamAlreadySet = 2
        case Failure = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .TeamAlreadySet: return "TEAM_ALREADY_SET"
          case .Failure: return "FAILURE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "TEAM_ALREADY_SET":  return .TeamAlreadySet
          case "FAILURE":  return .Failure
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .TeamAlreadySet: return ".TeamAlreadySet"
                case .Failure: return ".Failure"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var status:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status.Unset
    public private(set) var hasStatus:Bool = false
    public private(set) var hasPlayerData:Bool = false
    public private(set) var playerData:Pogoprotos.Data.PlayerData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasStatus {
        try output.writeEnum(1, value:status.rawValue)
      }
      if hasPlayerData {
        try output.writeMessage(2, value:playerData)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasStatus) {
        serialize_size += status.rawValue.computeEnumSize(1)
      }
      if hasPlayerData {
          if let varSizeplayerData = playerData?.computeMessageSize(2) {
              serialize_size += varSizeplayerData
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.SetPlayerTeamResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.SetPlayerTeamResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse? {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.classBuilder() as! Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SetPlayerTeamResponse) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasStatus {
        jsonMap["status"] = status.toString()
      }
      if hasPlayerData {
        jsonMap["playerData"] = try playerData.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
      return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasStatus) {
        output += "\(indent) status: \(status.description)\n"
      }
      if hasPlayerData {
        output += "\(indent) playerData {\n"
        if let outDescPlayerData = playerData {
          output += try outDescPlayerData.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStatus {
               hashCode = (hashCode &* 31) &+ Int(status.rawValue)
            }
            if hasPlayerData {
                if let hashValueplayerData = playerData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueplayerData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SetPlayerTeamResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SetPlayerTeamResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.SetPlayerTeamResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.SetPlayerTeamResponse = Pogoprotos.Networking.Responses.SetPlayerTeamResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasStatus:Bool{
            get {
                return builderResult.hasStatus
            }
        }
        public var status:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public func setStatus(value:Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status) -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
          self.status = value
          return self
        }
        public func clearStatus() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
           builderResult.hasStatus = false
           builderResult.status = .Unset
           return self
        }
      public var hasPlayerData:Bool {
           get {
               return builderResult.hasPlayerData
           }
      }
      public var playerData:Pogoprotos.Data.PlayerData! {
           get {
               if playerDataBuilder_ != nil {
                  builderResult.playerData = playerDataBuilder_.getMessage()
               }
               return builderResult.playerData
           }
           set (value) {
               builderResult.hasPlayerData = true
               builderResult.playerData = value
           }
      }
      private var playerDataBuilder_:Pogoprotos.Data.PlayerData.Builder! {
           didSet {
              builderResult.hasPlayerData = true
           }
      }
      public func getPlayerDataBuilder() -> Pogoprotos.Data.PlayerData.Builder {
        if playerDataBuilder_ == nil {
           playerDataBuilder_ = Pogoprotos.Data.PlayerData.Builder()
           builderResult.playerData = playerDataBuilder_.getMessage()
           if playerData != nil {
              try! playerDataBuilder_.mergeFrom(playerData)
           }
        }
        return playerDataBuilder_
      }
      public func setPlayerData(value:Pogoprotos.Data.PlayerData!) -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        self.playerData = value
        return self
      }
      public func mergePlayerData(value:Pogoprotos.Data.PlayerData) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        if builderResult.hasPlayerData {
          builderResult.playerData = try Pogoprotos.Data.PlayerData.builderWithPrototype(builderResult.playerData).mergeFrom(value).buildPartial()
        } else {
          builderResult.playerData = value
        }
        builderResult.hasPlayerData = true
        return self
      }
      public func clearPlayerData() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        playerDataBuilder_ = nil
        builderResult.hasPlayerData = false
        builderResult.playerData = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SetPlayerTeamResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse {
        let returnMe:Pogoprotos.Networking.Responses.SetPlayerTeamResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SetPlayerTeamResponse) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SetPlayerTeamResponse() {
         return self
        }
        if other.hasStatus {
             status = other.status
        }
        if (other.hasPlayerData) {
            try mergePlayerData(other.playerData)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntstatus = try input.readEnum()
            if let enumsstatus = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status(rawValue:valueIntstatus){
                 status = enumsstatus
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntstatus))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PlayerData.Builder = Pogoprotos.Data.PlayerData.Builder()
            if hasPlayerData {
              try subBuilder.mergeFrom(playerData)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            playerData = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder()
        if let jsonValueStatus = jsonMap["status"] as? String {
          resultDecodedBuilder.status = try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Status.fromString(jsonValueStatus)
        }
        if let jsonValuePlayerData = jsonMap["playerData"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.playerData = try Pogoprotos.Data.PlayerData.Builder.decodeToBuilder(jsonValuePlayerData).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SetPlayerTeamResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class SfidaActionLogResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var logEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry>  = Array<Pogoprotos.Data.Logs.ActionLogEntry>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      for oneElementLogEntries in logEntries {
          try output.writeMessage(2, value:oneElementLogEntries)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      for oneElementLogEntries in logEntries {
          serialize_size += oneElementLogEntries.computeMessageSize(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.SfidaActionLogResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.SfidaActionLogResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse? {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.classBuilder() as! Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.SfidaActionLogResponse) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if !logEntries.isEmpty {
        var jsonArrayLogEntries:Array<Dictionary<String,AnyObject>> = []
          for oneValueLogEntries in logEntries {
            let ecodedMessageLogEntries = try oneValueLogEntries.encode()
            jsonArrayLogEntries += [ecodedMessageLogEntries]
          }
        jsonMap["logEntries"] = jsonArrayLogEntries
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
      return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      var logEntriesElementIndex:Int = 0
      for oneElementLogEntries in logEntries {
          output += "\(indent) logEntries[\(logEntriesElementIndex)] {\n"
          output += try oneElementLogEntries.getDescription("\(indent)  ")
          output += "\(indent)}\n"
          logEntriesElementIndex += 1
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            for oneElementLogEntries in logEntries {
                hashCode = (hashCode &* 31) &+ oneElementLogEntries.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.SfidaActionLogResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.SfidaActionLogResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.SfidaActionLogResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.SfidaActionLogResponse = Pogoprotos.Networking.Responses.SfidaActionLogResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result) -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var logEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry> {
           get {
               return builderResult.logEntries
           }
           set (value) {
               builderResult.logEntries = value
           }
      }
      public func setLogEntries(value:Array<Pogoprotos.Data.Logs.ActionLogEntry>) -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        self.logEntries = value
        return self
      }
      public func clearLogEntries() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        builderResult.logEntries.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.SfidaActionLogResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.SfidaActionLogResponse {
        let returnMe:Pogoprotos.Networking.Responses.SfidaActionLogResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.SfidaActionLogResponse) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        if other == Pogoprotos.Networking.Responses.SfidaActionLogResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if !other.logEntries.isEmpty  {
           builderResult.logEntries += other.logEntries
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder = Pogoprotos.Data.Logs.ActionLogEntry.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            logEntries += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueLogEntries = jsonMap["logEntries"] as? Array<Dictionary<String,AnyObject>> {
          var jsonArrayLogEntries:Array<Pogoprotos.Data.Logs.ActionLogEntry> = []
          for oneValueLogEntries in jsonValueLogEntries {
            let messageFromStringLogEntries = try Pogoprotos.Data.Logs.ActionLogEntry.Builder.decodeToBuilder(oneValueLogEntries).build()

            jsonArrayLogEntries += [messageFromStringLogEntries]
          }
          resultDecodedBuilder.logEntries = jsonArrayLogEntries
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.SfidaActionLogResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class StartGymBattleResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorGymNotFound = 2
        case ErrorGymNeutral = 3
        case ErrorGymWrongTeam = 4
        case ErrorGymEmpty = 5
        case ErrorInvalidDefender = 6
        case ErrorTrainingInvalidAttackerCount = 7
        case ErrorAllPokemonFainted = 8
        case ErrorTooManyBattles = 9
        case ErrorTooManyPlayers = 10
        case ErrorGymBattleLockout = 11
        case ErrorPlayerBelowMinimumLevel = 12
        case ErrorNotInRange = 13
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorGymNotFound: return "ERROR_GYM_NOT_FOUND"
          case .ErrorGymNeutral: return "ERROR_GYM_NEUTRAL"
          case .ErrorGymWrongTeam: return "ERROR_GYM_WRONG_TEAM"
          case .ErrorGymEmpty: return "ERROR_GYM_EMPTY"
          case .ErrorInvalidDefender: return "ERROR_INVALID_DEFENDER"
          case .ErrorTrainingInvalidAttackerCount: return "ERROR_TRAINING_INVALID_ATTACKER_COUNT"
          case .ErrorAllPokemonFainted: return "ERROR_ALL_POKEMON_FAINTED"
          case .ErrorTooManyBattles: return "ERROR_TOO_MANY_BATTLES"
          case .ErrorTooManyPlayers: return "ERROR_TOO_MANY_PLAYERS"
          case .ErrorGymBattleLockout: return "ERROR_GYM_BATTLE_LOCKOUT"
          case .ErrorPlayerBelowMinimumLevel: return "ERROR_PLAYER_BELOW_MINIMUM_LEVEL"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_GYM_NOT_FOUND":  return .ErrorGymNotFound
          case "ERROR_GYM_NEUTRAL":  return .ErrorGymNeutral
          case "ERROR_GYM_WRONG_TEAM":  return .ErrorGymWrongTeam
          case "ERROR_GYM_EMPTY":  return .ErrorGymEmpty
          case "ERROR_INVALID_DEFENDER":  return .ErrorInvalidDefender
          case "ERROR_TRAINING_INVALID_ATTACKER_COUNT":  return .ErrorTrainingInvalidAttackerCount
          case "ERROR_ALL_POKEMON_FAINTED":  return .ErrorAllPokemonFainted
          case "ERROR_TOO_MANY_BATTLES":  return .ErrorTooManyBattles
          case "ERROR_TOO_MANY_PLAYERS":  return .ErrorTooManyPlayers
          case "ERROR_GYM_BATTLE_LOCKOUT":  return .ErrorGymBattleLockout
          case "ERROR_PLAYER_BELOW_MINIMUM_LEVEL":  return .ErrorPlayerBelowMinimumLevel
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorGymNotFound: return ".ErrorGymNotFound"
                case .ErrorGymNeutral: return ".ErrorGymNeutral"
                case .ErrorGymWrongTeam: return ".ErrorGymWrongTeam"
                case .ErrorGymEmpty: return ".ErrorGymEmpty"
                case .ErrorInvalidDefender: return ".ErrorInvalidDefender"
                case .ErrorTrainingInvalidAttackerCount: return ".ErrorTrainingInvalidAttackerCount"
                case .ErrorAllPokemonFainted: return ".ErrorAllPokemonFainted"
                case .ErrorTooManyBattles: return ".ErrorTooManyBattles"
                case .ErrorTooManyPlayers: return ".ErrorTooManyPlayers"
                case .ErrorGymBattleLockout: return ".ErrorGymBattleLockout"
                case .ErrorPlayerBelowMinimumLevel: return ".ErrorPlayerBelowMinimumLevel"
                case .ErrorNotInRange: return ".ErrorNotInRange"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result = Pogoprotos.Networking.Responses.StartGymBattleResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasBattleStartTimestampMs:Bool = false
    public private(set) var battleStartTimestampMs:Int64 = Int64(0)

    public private(set) var hasBattleEndTimestampMs:Bool = false
    public private(set) var battleEndTimestampMs:Int64 = Int64(0)

    public private(set) var hasBattleId:Bool = false
    public private(set) var battleId:String = ""

    public private(set) var hasDefender:Bool = false
    public private(set) var defender:Pogoprotos.Data.Battle.BattleParticipant!
    public private(set) var hasBattleLog:Bool = false
    public private(set) var battleLog:Pogoprotos.Data.Battle.BattleLog!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasBattleStartTimestampMs {
        try output.writeInt64(2, value:battleStartTimestampMs)
      }
      if hasBattleEndTimestampMs {
        try output.writeInt64(3, value:battleEndTimestampMs)
      }
      if hasBattleId {
        try output.writeString(4, value:battleId)
      }
      if hasDefender {
        try output.writeMessage(5, value:defender)
      }
      if hasBattleLog {
        try output.writeMessage(6, value:battleLog)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasBattleStartTimestampMs {
        serialize_size += battleStartTimestampMs.computeInt64Size(2)
      }
      if hasBattleEndTimestampMs {
        serialize_size += battleEndTimestampMs.computeInt64Size(3)
      }
      if hasBattleId {
        serialize_size += battleId.computeStringSize(4)
      }
      if hasDefender {
          if let varSizedefender = defender?.computeMessageSize(5) {
              serialize_size += varSizedefender
          }
      }
      if hasBattleLog {
          if let varSizebattleLog = battleLog?.computeMessageSize(6) {
              serialize_size += varSizebattleLog
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.StartGymBattleResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.StartGymBattleResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse? {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.classBuilder() as! Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.StartGymBattleResponse) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasBattleStartTimestampMs {
        jsonMap["battleStartTimestampMs"] = "\(battleStartTimestampMs)"
      }
      if hasBattleEndTimestampMs {
        jsonMap["battleEndTimestampMs"] = "\(battleEndTimestampMs)"
      }
      if hasBattleId {
        jsonMap["battleId"] = battleId
      }
      if hasDefender {
        jsonMap["defender"] = try defender.encode()
      }
      if hasBattleLog {
        jsonMap["battleLog"] = try battleLog.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
      return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasBattleStartTimestampMs {
        output += "\(indent) battleStartTimestampMs: \(battleStartTimestampMs) \n"
      }
      if hasBattleEndTimestampMs {
        output += "\(indent) battleEndTimestampMs: \(battleEndTimestampMs) \n"
      }
      if hasBattleId {
        output += "\(indent) battleId: \(battleId) \n"
      }
      if hasDefender {
        output += "\(indent) defender {\n"
        if let outDescDefender = defender {
          output += try outDescDefender.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      if hasBattleLog {
        output += "\(indent) battleLog {\n"
        if let outDescBattleLog = battleLog {
          output += try outDescBattleLog.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasBattleStartTimestampMs {
               hashCode = (hashCode &* 31) &+ battleStartTimestampMs.hashValue
            }
            if hasBattleEndTimestampMs {
               hashCode = (hashCode &* 31) &+ battleEndTimestampMs.hashValue
            }
            if hasBattleId {
               hashCode = (hashCode &* 31) &+ battleId.hashValue
            }
            if hasDefender {
                if let hashValuedefender = defender?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuedefender
                }
            }
            if hasBattleLog {
                if let hashValuebattleLog = battleLog?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuebattleLog
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.StartGymBattleResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.StartGymBattleResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.StartGymBattleResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.StartGymBattleResponse = Pogoprotos.Networking.Responses.StartGymBattleResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.StartGymBattleResponse.Result) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasBattleStartTimestampMs:Bool {
           get {
                return builderResult.hasBattleStartTimestampMs
           }
      }
      public var battleStartTimestampMs:Int64 {
           get {
                return builderResult.battleStartTimestampMs
           }
           set (value) {
               builderResult.hasBattleStartTimestampMs = true
               builderResult.battleStartTimestampMs = value
           }
      }
      public func setBattleStartTimestampMs(value:Int64) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleStartTimestampMs = value
        return self
      }
      public func clearBattleStartTimestampMs() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleStartTimestampMs = false
           builderResult.battleStartTimestampMs = Int64(0)
           return self
      }
      public var hasBattleEndTimestampMs:Bool {
           get {
                return builderResult.hasBattleEndTimestampMs
           }
      }
      public var battleEndTimestampMs:Int64 {
           get {
                return builderResult.battleEndTimestampMs
           }
           set (value) {
               builderResult.hasBattleEndTimestampMs = true
               builderResult.battleEndTimestampMs = value
           }
      }
      public func setBattleEndTimestampMs(value:Int64) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleEndTimestampMs = value
        return self
      }
      public func clearBattleEndTimestampMs() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleEndTimestampMs = false
           builderResult.battleEndTimestampMs = Int64(0)
           return self
      }
      public var hasBattleId:Bool {
           get {
                return builderResult.hasBattleId
           }
      }
      public var battleId:String {
           get {
                return builderResult.battleId
           }
           set (value) {
               builderResult.hasBattleId = true
               builderResult.battleId = value
           }
      }
      public func setBattleId(value:String) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleId = value
        return self
      }
      public func clearBattleId() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder{
           builderResult.hasBattleId = false
           builderResult.battleId = ""
           return self
      }
      public var hasDefender:Bool {
           get {
               return builderResult.hasDefender
           }
      }
      public var defender:Pogoprotos.Data.Battle.BattleParticipant! {
           get {
               if defenderBuilder_ != nil {
                  builderResult.defender = defenderBuilder_.getMessage()
               }
               return builderResult.defender
           }
           set (value) {
               builderResult.hasDefender = true
               builderResult.defender = value
           }
      }
      private var defenderBuilder_:Pogoprotos.Data.Battle.BattleParticipant.Builder! {
           didSet {
              builderResult.hasDefender = true
           }
      }
      public func getDefenderBuilder() -> Pogoprotos.Data.Battle.BattleParticipant.Builder {
        if defenderBuilder_ == nil {
           defenderBuilder_ = Pogoprotos.Data.Battle.BattleParticipant.Builder()
           builderResult.defender = defenderBuilder_.getMessage()
           if defender != nil {
              try! defenderBuilder_.mergeFrom(defender)
           }
        }
        return defenderBuilder_
      }
      public func setDefender(value:Pogoprotos.Data.Battle.BattleParticipant!) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.defender = value
        return self
      }
      public func mergeDefender(value:Pogoprotos.Data.Battle.BattleParticipant) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if builderResult.hasDefender {
          builderResult.defender = try Pogoprotos.Data.Battle.BattleParticipant.builderWithPrototype(builderResult.defender).mergeFrom(value).buildPartial()
        } else {
          builderResult.defender = value
        }
        builderResult.hasDefender = true
        return self
      }
      public func clearDefender() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        defenderBuilder_ = nil
        builderResult.hasDefender = false
        builderResult.defender = nil
        return self
      }
      public var hasBattleLog:Bool {
           get {
               return builderResult.hasBattleLog
           }
      }
      public var battleLog:Pogoprotos.Data.Battle.BattleLog! {
           get {
               if battleLogBuilder_ != nil {
                  builderResult.battleLog = battleLogBuilder_.getMessage()
               }
               return builderResult.battleLog
           }
           set (value) {
               builderResult.hasBattleLog = true
               builderResult.battleLog = value
           }
      }
      private var battleLogBuilder_:Pogoprotos.Data.Battle.BattleLog.Builder! {
           didSet {
              builderResult.hasBattleLog = true
           }
      }
      public func getBattleLogBuilder() -> Pogoprotos.Data.Battle.BattleLog.Builder {
        if battleLogBuilder_ == nil {
           battleLogBuilder_ = Pogoprotos.Data.Battle.BattleLog.Builder()
           builderResult.battleLog = battleLogBuilder_.getMessage()
           if battleLog != nil {
              try! battleLogBuilder_.mergeFrom(battleLog)
           }
        }
        return battleLogBuilder_
      }
      public func setBattleLog(value:Pogoprotos.Data.Battle.BattleLog!) -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        self.battleLog = value
        return self
      }
      public func mergeBattleLog(value:Pogoprotos.Data.Battle.BattleLog) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if builderResult.hasBattleLog {
          builderResult.battleLog = try Pogoprotos.Data.Battle.BattleLog.builderWithPrototype(builderResult.battleLog).mergeFrom(value).buildPartial()
        } else {
          builderResult.battleLog = value
        }
        builderResult.hasBattleLog = true
        return self
      }
      public func clearBattleLog() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        battleLogBuilder_ = nil
        builderResult.hasBattleLog = false
        builderResult.battleLog = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.StartGymBattleResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        return try Pogoprotos.Networking.Responses.StartGymBattleResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.StartGymBattleResponse {
        let returnMe:Pogoprotos.Networking.Responses.StartGymBattleResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.StartGymBattleResponse) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        if other == Pogoprotos.Networking.Responses.StartGymBattleResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasBattleStartTimestampMs {
             battleStartTimestampMs = other.battleStartTimestampMs
        }
        if other.hasBattleEndTimestampMs {
             battleEndTimestampMs = other.battleEndTimestampMs
        }
        if other.hasBattleId {
             battleId = other.battleId
        }
        if (other.hasDefender) {
            try mergeDefender(other.defender)
        }
        if (other.hasBattleLog) {
            try mergeBattleLog(other.battleLog)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.StartGymBattleResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            battleStartTimestampMs = try input.readInt64()

          case 24:
            battleEndTimestampMs = try input.readInt64()

          case 34:
            battleId = try input.readString()

          case 42:
            let subBuilder:Pogoprotos.Data.Battle.BattleParticipant.Builder = Pogoprotos.Data.Battle.BattleParticipant.Builder()
            if hasDefender {
              try subBuilder.mergeFrom(defender)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            defender = subBuilder.buildPartial()

          case 50:
            let subBuilder:Pogoprotos.Data.Battle.BattleLog.Builder = Pogoprotos.Data.Battle.BattleLog.Builder()
            if hasBattleLog {
              try subBuilder.mergeFrom(battleLog)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            battleLog = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.StartGymBattleResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueBattleStartTimestampMs = jsonMap["battleStartTimestampMs"] as? String {
          resultDecodedBuilder.battleStartTimestampMs = Int64(jsonValueBattleStartTimestampMs)!
        }
        if let jsonValueBattleEndTimestampMs = jsonMap["battleEndTimestampMs"] as? String {
          resultDecodedBuilder.battleEndTimestampMs = Int64(jsonValueBattleEndTimestampMs)!
        }
        if let jsonValueBattleId = jsonMap["battleId"] as? String {
          resultDecodedBuilder.battleId = jsonValueBattleId
        }
        if let jsonValueDefender = jsonMap["defender"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.defender = try Pogoprotos.Data.Battle.BattleParticipant.Builder.decodeToBuilder(jsonValueDefender).build()

        }
        if let jsonValueBattleLog = jsonMap["battleLog"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.battleLog = try Pogoprotos.Data.Battle.BattleLog.Builder.decodeToBuilder(jsonValueBattleLog).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.StartGymBattleResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UpgradePokemonResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorPokemonNotFound = 2
        case ErrorInsufficientResources = 3
        case ErrorUpgradeNotAvailable = 4
        case ErrorPokemonIsDeployed = 5
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorPokemonNotFound: return "ERROR_POKEMON_NOT_FOUND"
          case .ErrorInsufficientResources: return "ERROR_INSUFFICIENT_RESOURCES"
          case .ErrorUpgradeNotAvailable: return "ERROR_UPGRADE_NOT_AVAILABLE"
          case .ErrorPokemonIsDeployed: return "ERROR_POKEMON_IS_DEPLOYED"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_POKEMON_NOT_FOUND":  return .ErrorPokemonNotFound
          case "ERROR_INSUFFICIENT_RESOURCES":  return .ErrorInsufficientResources
          case "ERROR_UPGRADE_NOT_AVAILABLE":  return .ErrorUpgradeNotAvailable
          case "ERROR_POKEMON_IS_DEPLOYED":  return .ErrorPokemonIsDeployed
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorPokemonNotFound: return ".ErrorPokemonNotFound"
                case .ErrorInsufficientResources: return ".ErrorInsufficientResources"
                case .ErrorUpgradeNotAvailable: return ".ErrorUpgradeNotAvailable"
                case .ErrorPokemonIsDeployed: return ".ErrorPokemonIsDeployed"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasUpgradedPokemon:Bool = false
    public private(set) var upgradedPokemon:Pogoprotos.Data.PokemonData!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasUpgradedPokemon {
        try output.writeMessage(2, value:upgradedPokemon)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasUpgradedPokemon {
          if let varSizeupgradedPokemon = upgradedPokemon?.computeMessageSize(2) {
              serialize_size += varSizeupgradedPokemon
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UpgradePokemonResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UpgradePokemonResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse? {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.classBuilder() as! Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UpgradePokemonResponse) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasUpgradedPokemon {
        jsonMap["upgradedPokemon"] = try upgradedPokemon.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
      return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasUpgradedPokemon {
        output += "\(indent) upgradedPokemon {\n"
        if let outDescUpgradedPokemon = upgradedPokemon {
          output += try outDescUpgradedPokemon.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasUpgradedPokemon {
                if let hashValueupgradedPokemon = upgradedPokemon?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueupgradedPokemon
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UpgradePokemonResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UpgradePokemonResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UpgradePokemonResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UpgradePokemonResponse = Pogoprotos.Networking.Responses.UpgradePokemonResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result) -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasUpgradedPokemon:Bool {
           get {
               return builderResult.hasUpgradedPokemon
           }
      }
      public var upgradedPokemon:Pogoprotos.Data.PokemonData! {
           get {
               if upgradedPokemonBuilder_ != nil {
                  builderResult.upgradedPokemon = upgradedPokemonBuilder_.getMessage()
               }
               return builderResult.upgradedPokemon
           }
           set (value) {
               builderResult.hasUpgradedPokemon = true
               builderResult.upgradedPokemon = value
           }
      }
      private var upgradedPokemonBuilder_:Pogoprotos.Data.PokemonData.Builder! {
           didSet {
              builderResult.hasUpgradedPokemon = true
           }
      }
      public func getUpgradedPokemonBuilder() -> Pogoprotos.Data.PokemonData.Builder {
        if upgradedPokemonBuilder_ == nil {
           upgradedPokemonBuilder_ = Pogoprotos.Data.PokemonData.Builder()
           builderResult.upgradedPokemon = upgradedPokemonBuilder_.getMessage()
           if upgradedPokemon != nil {
              try! upgradedPokemonBuilder_.mergeFrom(upgradedPokemon)
           }
        }
        return upgradedPokemonBuilder_
      }
      public func setUpgradedPokemon(value:Pogoprotos.Data.PokemonData!) -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        self.upgradedPokemon = value
        return self
      }
      public func mergeUpgradedPokemon(value:Pogoprotos.Data.PokemonData) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        if builderResult.hasUpgradedPokemon {
          builderResult.upgradedPokemon = try Pogoprotos.Data.PokemonData.builderWithPrototype(builderResult.upgradedPokemon).mergeFrom(value).buildPartial()
        } else {
          builderResult.upgradedPokemon = value
        }
        builderResult.hasUpgradedPokemon = true
        return self
      }
      public func clearUpgradedPokemon() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        upgradedPokemonBuilder_ = nil
        builderResult.hasUpgradedPokemon = false
        builderResult.upgradedPokemon = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UpgradePokemonResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UpgradePokemonResponse {
        let returnMe:Pogoprotos.Networking.Responses.UpgradePokemonResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UpgradePokemonResponse) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UpgradePokemonResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasUpgradedPokemon) {
            try mergeUpgradedPokemon(other.upgradedPokemon)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Data.PokemonData.Builder = Pogoprotos.Data.PokemonData.Builder()
            if hasUpgradedPokemon {
              try subBuilder.mergeFrom(upgradedPokemon)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            upgradedPokemon = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueUpgradedPokemon = jsonMap["upgradedPokemon"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.upgradedPokemon = try Pogoprotos.Data.PokemonData.Builder.decodeToBuilder(jsonValueUpgradedPokemon).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UpgradePokemonResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseIncenseResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unknown = 0
        case Success = 1
        case IncenseAlreadyActive = 2
        case NoneInInventory = 3
        case LocationUnset = 4
        public func toString() -> String {
          switch self {
          case .Unknown: return "UNKNOWN"
          case .Success: return "SUCCESS"
          case .IncenseAlreadyActive: return "INCENSE_ALREADY_ACTIVE"
          case .NoneInInventory: return "NONE_IN_INVENTORY"
          case .LocationUnset: return "LOCATION_UNSET"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Result {
          switch str {
          case "UNKNOWN":  return .Unknown
          case "SUCCESS":  return .Success
          case "INCENSE_ALREADY_ACTIVE":  return .IncenseAlreadyActive
          case "NONE_IN_INVENTORY":  return .NoneInInventory
          case "LOCATION_UNSET":  return .LocationUnset
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unknown: return ".Unknown"
                case .Success: return ".Success"
                case .IncenseAlreadyActive: return ".IncenseAlreadyActive"
                case .NoneInInventory: return ".NoneInInventory"
                case .LocationUnset: return ".LocationUnset"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseIncenseResponse.Result = Pogoprotos.Networking.Responses.UseIncenseResponse.Result.Unknown
    public private(set) var hasResult:Bool = false
    public private(set) var hasAppliedIncense:Bool = false
    public private(set) var appliedIncense:Pogoprotos.Inventory.AppliedItem!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasAppliedIncense {
        try output.writeMessage(2, value:appliedIncense)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasAppliedIncense {
          if let varSizeappliedIncense = appliedIncense?.computeMessageSize(2) {
              serialize_size += varSizeappliedIncense
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseIncenseResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseIncenseResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse? {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseIncenseResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseIncenseResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseIncenseResponse) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasAppliedIncense {
        jsonMap["appliedIncense"] = try appliedIncense.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
      return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasAppliedIncense {
        output += "\(indent) appliedIncense {\n"
        if let outDescAppliedIncense = appliedIncense {
          output += try outDescAppliedIncense.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasAppliedIncense {
                if let hashValueappliedIncense = appliedIncense?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueappliedIncense
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseIncenseResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseIncenseResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseIncenseResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseIncenseResponse = Pogoprotos.Networking.Responses.UseIncenseResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseIncenseResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseIncenseResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseIncenseResponse.Result) -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unknown
           return self
        }
      public var hasAppliedIncense:Bool {
           get {
               return builderResult.hasAppliedIncense
           }
      }
      public var appliedIncense:Pogoprotos.Inventory.AppliedItem! {
           get {
               if appliedIncenseBuilder_ != nil {
                  builderResult.appliedIncense = appliedIncenseBuilder_.getMessage()
               }
               return builderResult.appliedIncense
           }
           set (value) {
               builderResult.hasAppliedIncense = true
               builderResult.appliedIncense = value
           }
      }
      private var appliedIncenseBuilder_:Pogoprotos.Inventory.AppliedItem.Builder! {
           didSet {
              builderResult.hasAppliedIncense = true
           }
      }
      public func getAppliedIncenseBuilder() -> Pogoprotos.Inventory.AppliedItem.Builder {
        if appliedIncenseBuilder_ == nil {
           appliedIncenseBuilder_ = Pogoprotos.Inventory.AppliedItem.Builder()
           builderResult.appliedIncense = appliedIncenseBuilder_.getMessage()
           if appliedIncense != nil {
              try! appliedIncenseBuilder_.mergeFrom(appliedIncense)
           }
        }
        return appliedIncenseBuilder_
      }
      public func setAppliedIncense(value:Pogoprotos.Inventory.AppliedItem!) -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        self.appliedIncense = value
        return self
      }
      public func mergeAppliedIncense(value:Pogoprotos.Inventory.AppliedItem) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        if builderResult.hasAppliedIncense {
          builderResult.appliedIncense = try Pogoprotos.Inventory.AppliedItem.builderWithPrototype(builderResult.appliedIncense).mergeFrom(value).buildPartial()
        } else {
          builderResult.appliedIncense = value
        }
        builderResult.hasAppliedIncense = true
        return self
      }
      public func clearAppliedIncense() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        appliedIncenseBuilder_ = nil
        builderResult.hasAppliedIncense = false
        builderResult.appliedIncense = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseIncenseResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseIncenseResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseIncenseResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseIncenseResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseIncenseResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseIncenseResponse) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseIncenseResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasAppliedIncense) {
            try mergeAppliedIncense(other.appliedIncense)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseIncenseResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.AppliedItem.Builder = Pogoprotos.Inventory.AppliedItem.Builder()
            if hasAppliedIncense {
              try subBuilder.mergeFrom(appliedIncense)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            appliedIncense = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseIncenseResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseIncenseResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueAppliedIncense = jsonMap["appliedIncense"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.appliedIncense = try Pogoprotos.Inventory.AppliedItem.Builder.decodeToBuilder(jsonValueAppliedIncense).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseIncenseResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseIncenseResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemCaptureResponse : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var hasItemCaptureMult:Bool = false
    public private(set) var itemCaptureMult:Double = Double(0)

    public private(set) var hasItemFleeMult:Bool = false
    public private(set) var itemFleeMult:Double = Double(0)

    public private(set) var hasStopMovement:Bool = false
    public private(set) var stopMovement:Bool = false

    public private(set) var hasStopAttack:Bool = false
    public private(set) var stopAttack:Bool = false

    public private(set) var hasTargetMax:Bool = false
    public private(set) var targetMax:Bool = false

    public private(set) var hasTargetSlow:Bool = false
    public private(set) var targetSlow:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasSuccess {
        try output.writeBool(1, value:success)
      }
      if hasItemCaptureMult {
        try output.writeDouble(2, value:itemCaptureMult)
      }
      if hasItemFleeMult {
        try output.writeDouble(3, value:itemFleeMult)
      }
      if hasStopMovement {
        try output.writeBool(4, value:stopMovement)
      }
      if hasStopAttack {
        try output.writeBool(5, value:stopAttack)
      }
      if hasTargetMax {
        try output.writeBool(6, value:targetMax)
      }
      if hasTargetSlow {
        try output.writeBool(7, value:targetSlow)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasSuccess {
        serialize_size += success.computeBoolSize(1)
      }
      if hasItemCaptureMult {
        serialize_size += itemCaptureMult.computeDoubleSize(2)
      }
      if hasItemFleeMult {
        serialize_size += itemFleeMult.computeDoubleSize(3)
      }
      if hasStopMovement {
        serialize_size += stopMovement.computeBoolSize(4)
      }
      if hasStopAttack {
        serialize_size += stopAttack.computeBoolSize(5)
      }
      if hasTargetMax {
        serialize_size += targetMax.computeBoolSize(6)
      }
      if hasTargetSlow {
        serialize_size += targetSlow.computeBoolSize(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemCaptureResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse? {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasSuccess {
        jsonMap["success"] = success
      }
      if hasItemCaptureMult {
        jsonMap["itemCaptureMult"] = NSNumber(double:itemCaptureMult)
      }
      if hasItemFleeMult {
        jsonMap["itemFleeMult"] = NSNumber(double:itemFleeMult)
      }
      if hasStopMovement {
        jsonMap["stopMovement"] = stopMovement
      }
      if hasStopAttack {
        jsonMap["stopAttack"] = stopAttack
      }
      if hasTargetMax {
        jsonMap["targetMax"] = targetMax
      }
      if hasTargetSlow {
        jsonMap["targetSlow"] = targetSlow
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
      return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      if hasItemCaptureMult {
        output += "\(indent) itemCaptureMult: \(itemCaptureMult) \n"
      }
      if hasItemFleeMult {
        output += "\(indent) itemFleeMult: \(itemFleeMult) \n"
      }
      if hasStopMovement {
        output += "\(indent) stopMovement: \(stopMovement) \n"
      }
      if hasStopAttack {
        output += "\(indent) stopAttack: \(stopAttack) \n"
      }
      if hasTargetMax {
        output += "\(indent) targetMax: \(targetMax) \n"
      }
      if hasTargetSlow {
        output += "\(indent) targetSlow: \(targetSlow) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            if hasItemCaptureMult {
               hashCode = (hashCode &* 31) &+ itemCaptureMult.hashValue
            }
            if hasItemFleeMult {
               hashCode = (hashCode &* 31) &+ itemFleeMult.hashValue
            }
            if hasStopMovement {
               hashCode = (hashCode &* 31) &+ stopMovement.hashValue
            }
            if hasStopAttack {
               hashCode = (hashCode &* 31) &+ stopAttack.hashValue
            }
            if hasTargetMax {
               hashCode = (hashCode &* 31) &+ targetMax.hashValue
            }
            if hasTargetSlow {
               hashCode = (hashCode &* 31) &+ targetSlow.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemCaptureResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemCaptureResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemCaptureResponse = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var hasItemCaptureMult:Bool {
           get {
                return builderResult.hasItemCaptureMult
           }
      }
      public var itemCaptureMult:Double {
           get {
                return builderResult.itemCaptureMult
           }
           set (value) {
               builderResult.hasItemCaptureMult = true
               builderResult.itemCaptureMult = value
           }
      }
      public func setItemCaptureMult(value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemCaptureMult = value
        return self
      }
      public func clearItemCaptureMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemCaptureMult = false
           builderResult.itemCaptureMult = Double(0)
           return self
      }
      public var hasItemFleeMult:Bool {
           get {
                return builderResult.hasItemFleeMult
           }
      }
      public var itemFleeMult:Double {
           get {
                return builderResult.itemFleeMult
           }
           set (value) {
               builderResult.hasItemFleeMult = true
               builderResult.itemFleeMult = value
           }
      }
      public func setItemFleeMult(value:Double) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.itemFleeMult = value
        return self
      }
      public func clearItemFleeMult() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasItemFleeMult = false
           builderResult.itemFleeMult = Double(0)
           return self
      }
      public var hasStopMovement:Bool {
           get {
                return builderResult.hasStopMovement
           }
      }
      public var stopMovement:Bool {
           get {
                return builderResult.stopMovement
           }
           set (value) {
               builderResult.hasStopMovement = true
               builderResult.stopMovement = value
           }
      }
      public func setStopMovement(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopMovement = value
        return self
      }
      public func clearStopMovement() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopMovement = false
           builderResult.stopMovement = false
           return self
      }
      public var hasStopAttack:Bool {
           get {
                return builderResult.hasStopAttack
           }
      }
      public var stopAttack:Bool {
           get {
                return builderResult.stopAttack
           }
           set (value) {
               builderResult.hasStopAttack = true
               builderResult.stopAttack = value
           }
      }
      public func setStopAttack(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.stopAttack = value
        return self
      }
      public func clearStopAttack() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasStopAttack = false
           builderResult.stopAttack = false
           return self
      }
      public var hasTargetMax:Bool {
           get {
                return builderResult.hasTargetMax
           }
      }
      public var targetMax:Bool {
           get {
                return builderResult.targetMax
           }
           set (value) {
               builderResult.hasTargetMax = true
               builderResult.targetMax = value
           }
      }
      public func setTargetMax(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetMax = value
        return self
      }
      public func clearTargetMax() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetMax = false
           builderResult.targetMax = false
           return self
      }
      public var hasTargetSlow:Bool {
           get {
                return builderResult.hasTargetSlow
           }
      }
      public var targetSlow:Bool {
           get {
                return builderResult.targetSlow
           }
           set (value) {
               builderResult.hasTargetSlow = true
               builderResult.targetSlow = value
           }
      }
      public func setTargetSlow(value:Bool) -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        self.targetSlow = value
        return self
      }
      public func clearTargetSlow() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder{
           builderResult.hasTargetSlow = false
           builderResult.targetSlow = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemCaptureResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemCaptureResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemCaptureResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemCaptureResponse) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemCaptureResponse() {
         return self
        }
        if other.hasSuccess {
             success = other.success
        }
        if other.hasItemCaptureMult {
             itemCaptureMult = other.itemCaptureMult
        }
        if other.hasItemFleeMult {
             itemFleeMult = other.itemFleeMult
        }
        if other.hasStopMovement {
             stopMovement = other.stopMovement
        }
        if other.hasStopAttack {
             stopAttack = other.stopAttack
        }
        if other.hasTargetMax {
             targetMax = other.targetMax
        }
        if other.hasTargetSlow {
             targetSlow = other.targetSlow
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            success = try input.readBool()

          case 17:
            itemCaptureMult = try input.readDouble()

          case 25:
            itemFleeMult = try input.readDouble()

          case 32:
            stopMovement = try input.readBool()

          case 40:
            stopAttack = try input.readBool()

          case 48:
            targetMax = try input.readBool()

          case 56:
            targetSlow = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder()
        if let jsonValueSuccess = jsonMap["success"] as? Bool {
          resultDecodedBuilder.success = jsonValueSuccess
        }
        if let jsonValueItemCaptureMult = jsonMap["itemCaptureMult"] as? NSNumber {
          resultDecodedBuilder.itemCaptureMult = jsonValueItemCaptureMult.doubleValue
        }
        if let jsonValueItemFleeMult = jsonMap["itemFleeMult"] as? NSNumber {
          resultDecodedBuilder.itemFleeMult = jsonValueItemFleeMult.doubleValue
        }
        if let jsonValueStopMovement = jsonMap["stopMovement"] as? Bool {
          resultDecodedBuilder.stopMovement = jsonValueStopMovement
        }
        if let jsonValueStopAttack = jsonMap["stopAttack"] as? Bool {
          resultDecodedBuilder.stopAttack = jsonValueStopAttack
        }
        if let jsonValueTargetMax = jsonMap["targetMax"] as? Bool {
          resultDecodedBuilder.targetMax = jsonValueTargetMax
        }
        if let jsonValueTargetSlow = jsonMap["targetSlow"] as? Bool {
          resultDecodedBuilder.targetSlow = jsonValueTargetSlow
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemCaptureResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemEggIncubatorResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorIncubatorNotFound = 2
        case ErrorPokemonEggNotFound = 3
        case ErrorPokemonIdNotEgg = 4
        case ErrorIncubatorAlreadyInUse = 5
        case ErrorPokemonAlreadyIncubating = 6
        case ErrorIncubatorNoUsesRemaining = 7
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorIncubatorNotFound: return "ERROR_INCUBATOR_NOT_FOUND"
          case .ErrorPokemonEggNotFound: return "ERROR_POKEMON_EGG_NOT_FOUND"
          case .ErrorPokemonIdNotEgg: return "ERROR_POKEMON_ID_NOT_EGG"
          case .ErrorIncubatorAlreadyInUse: return "ERROR_INCUBATOR_ALREADY_IN_USE"
          case .ErrorPokemonAlreadyIncubating: return "ERROR_POKEMON_ALREADY_INCUBATING"
          case .ErrorIncubatorNoUsesRemaining: return "ERROR_INCUBATOR_NO_USES_REMAINING"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_INCUBATOR_NOT_FOUND":  return .ErrorIncubatorNotFound
          case "ERROR_POKEMON_EGG_NOT_FOUND":  return .ErrorPokemonEggNotFound
          case "ERROR_POKEMON_ID_NOT_EGG":  return .ErrorPokemonIdNotEgg
          case "ERROR_INCUBATOR_ALREADY_IN_USE":  return .ErrorIncubatorAlreadyInUse
          case "ERROR_POKEMON_ALREADY_INCUBATING":  return .ErrorPokemonAlreadyIncubating
          case "ERROR_INCUBATOR_NO_USES_REMAINING":  return .ErrorIncubatorNoUsesRemaining
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorIncubatorNotFound: return ".ErrorIncubatorNotFound"
                case .ErrorPokemonEggNotFound: return ".ErrorPokemonEggNotFound"
                case .ErrorPokemonIdNotEgg: return ".ErrorPokemonIdNotEgg"
                case .ErrorIncubatorAlreadyInUse: return ".ErrorIncubatorAlreadyInUse"
                case .ErrorPokemonAlreadyIncubating: return ".ErrorPokemonAlreadyIncubating"
                case .ErrorIncubatorNoUsesRemaining: return ".ErrorIncubatorNoUsesRemaining"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasEggIncubator:Bool = false
    public private(set) var eggIncubator:Pogoprotos.Inventory.EggIncubator!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasEggIncubator {
        try output.writeMessage(2, value:eggIncubator)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasEggIncubator {
          if let varSizeeggIncubator = eggIncubator?.computeMessageSize(2) {
              serialize_size += varSizeeggIncubator
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse? {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasEggIncubator {
        jsonMap["eggIncubator"] = try eggIncubator.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
      return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasEggIncubator {
        output += "\(indent) eggIncubator {\n"
        if let outDescEggIncubator = eggIncubator {
          output += try outDescEggIncubator.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasEggIncubator {
                if let hashValueeggIncubator = eggIncubator?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueeggIncubator
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result) -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasEggIncubator:Bool {
           get {
               return builderResult.hasEggIncubator
           }
      }
      public var eggIncubator:Pogoprotos.Inventory.EggIncubator! {
           get {
               if eggIncubatorBuilder_ != nil {
                  builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
               }
               return builderResult.eggIncubator
           }
           set (value) {
               builderResult.hasEggIncubator = true
               builderResult.eggIncubator = value
           }
      }
      private var eggIncubatorBuilder_:Pogoprotos.Inventory.EggIncubator.Builder! {
           didSet {
              builderResult.hasEggIncubator = true
           }
      }
      public func getEggIncubatorBuilder() -> Pogoprotos.Inventory.EggIncubator.Builder {
        if eggIncubatorBuilder_ == nil {
           eggIncubatorBuilder_ = Pogoprotos.Inventory.EggIncubator.Builder()
           builderResult.eggIncubator = eggIncubatorBuilder_.getMessage()
           if eggIncubator != nil {
              try! eggIncubatorBuilder_.mergeFrom(eggIncubator)
           }
        }
        return eggIncubatorBuilder_
      }
      public func setEggIncubator(value:Pogoprotos.Inventory.EggIncubator!) -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        self.eggIncubator = value
        return self
      }
      public func mergeEggIncubator(value:Pogoprotos.Inventory.EggIncubator) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        if builderResult.hasEggIncubator {
          builderResult.eggIncubator = try Pogoprotos.Inventory.EggIncubator.builderWithPrototype(builderResult.eggIncubator).mergeFrom(value).buildPartial()
        } else {
          builderResult.eggIncubator = value
        }
        builderResult.hasEggIncubator = true
        return self
      }
      public func clearEggIncubator() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        eggIncubatorBuilder_ = nil
        builderResult.hasEggIncubator = false
        builderResult.eggIncubator = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasEggIncubator) {
            try mergeEggIncubator(other.eggIncubator)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.EggIncubator.Builder = Pogoprotos.Inventory.EggIncubator.Builder()
            if hasEggIncubator {
              try subBuilder.mergeFrom(eggIncubator)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            eggIncubator = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueEggIncubator = jsonMap["eggIncubator"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.eggIncubator = try Pogoprotos.Inventory.EggIncubator.Builder.decodeToBuilder(jsonValueEggIncubator).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemEggIncubatorResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemGymResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorCannotUse = 2
        case ErrorNotInRange = 3
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorCannotUse: return "ERROR_CANNOT_USE"
          case .ErrorNotInRange: return "ERROR_NOT_IN_RANGE"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_CANNOT_USE":  return .ErrorCannotUse
          case "ERROR_NOT_IN_RANGE":  return .ErrorNotInRange
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorCannotUse: return ".ErrorCannotUse"
                case .ErrorNotInRange: return ".ErrorNotInRange"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseItemGymResponse.Result = Pogoprotos.Networking.Responses.UseItemGymResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    // Gym Points (?)
    public private(set) var hasUpdatedGp:Bool = false
    public private(set) var updatedGp:Int64 = Int64(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasUpdatedGp {
        try output.writeInt64(2, value:updatedGp)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasUpdatedGp {
        serialize_size += updatedGp.computeInt64Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemGymResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemGymResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse? {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemGymResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemGymResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemGymResponse) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasUpdatedGp {
        jsonMap["updatedGp"] = "\(updatedGp)"
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
      return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasUpdatedGp {
        output += "\(indent) updatedGp: \(updatedGp) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasUpdatedGp {
               hashCode = (hashCode &* 31) &+ updatedGp.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemGymResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemGymResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemGymResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemGymResponse = Pogoprotos.Networking.Responses.UseItemGymResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemGymResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemGymResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseItemGymResponse.Result) -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasUpdatedGp:Bool {
           get {
                return builderResult.hasUpdatedGp
           }
      }
      public var updatedGp:Int64 {
           get {
                return builderResult.updatedGp
           }
           set (value) {
               builderResult.hasUpdatedGp = true
               builderResult.updatedGp = value
           }
      }
      public func setUpdatedGp(value:Int64) -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        self.updatedGp = value
        return self
      }
      public func clearUpdatedGp() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder{
           builderResult.hasUpdatedGp = false
           builderResult.updatedGp = Int64(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemGymResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemGymResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemGymResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemGymResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemGymResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemGymResponse) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemGymResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasUpdatedGp {
             updatedGp = other.updatedGp
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemGymResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            updatedGp = try input.readInt64()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemGymResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemGymResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueUpdatedGp = jsonMap["updatedGp"] as? String {
          resultDecodedBuilder.updatedGp = Int64(jsonValueUpdatedGp)!
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemGymResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemGymResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemPotionResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorNoPokemon = 2
        case ErrorCannotUse = 3
        case ErrorDeployedToFort = 4
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorNoPokemon: return "ERROR_NO_POKEMON"
          case .ErrorCannotUse: return "ERROR_CANNOT_USE"
          case .ErrorDeployedToFort: return "ERROR_DEPLOYED_TO_FORT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_NO_POKEMON":  return .ErrorNoPokemon
          case "ERROR_CANNOT_USE":  return .ErrorCannotUse
          case "ERROR_DEPLOYED_TO_FORT":  return .ErrorDeployedToFort
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorNoPokemon: return ".ErrorNoPokemon"
                case .ErrorCannotUse: return ".ErrorCannotUse"
                case .ErrorDeployedToFort: return ".ErrorDeployedToFort"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result = Pogoprotos.Networking.Responses.UseItemPotionResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasStamina:Bool = false
    public private(set) var stamina:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasStamina {
        try output.writeInt32(2, value:stamina)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemPotionResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemPotionResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse? {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemPotionResponse) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStamina {
        jsonMap["stamina"] = NSNumber(int:stamina)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
      return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemPotionResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemPotionResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemPotionResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemPotionResponse = Pogoprotos.Networking.Responses.UseItemPotionResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseItemPotionResponse.Result) -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      public func setStamina(value:Int32) -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        self.stamina = value
        return self
      }
      public func clearStamina() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemPotionResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemPotionResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemPotionResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemPotionResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemPotionResponse) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemPotionResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemPotionResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            stamina = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemPotionResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueStamina = jsonMap["stamina"] as? NSNumber {
          resultDecodedBuilder.stamina = jsonValueStamina.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemPotionResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemReviveResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorNoPokemon = 2
        case ErrorCannotUse = 3
        case ErrorDeployedToFort = 4
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorNoPokemon: return "ERROR_NO_POKEMON"
          case .ErrorCannotUse: return "ERROR_CANNOT_USE"
          case .ErrorDeployedToFort: return "ERROR_DEPLOYED_TO_FORT"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_NO_POKEMON":  return .ErrorNoPokemon
          case "ERROR_CANNOT_USE":  return .ErrorCannotUse
          case "ERROR_DEPLOYED_TO_FORT":  return .ErrorDeployedToFort
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorNoPokemon: return ".ErrorNoPokemon"
                case .ErrorCannotUse: return ".ErrorCannotUse"
                case .ErrorDeployedToFort: return ".ErrorDeployedToFort"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result = Pogoprotos.Networking.Responses.UseItemReviveResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasStamina:Bool = false
    public private(set) var stamina:Int32 = Int32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasStamina {
        try output.writeInt32(2, value:stamina)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasStamina {
        serialize_size += stamina.computeInt32Size(2)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemReviveResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemReviveResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse? {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemReviveResponse) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasStamina {
        jsonMap["stamina"] = NSNumber(int:stamina)
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
      return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasStamina {
        output += "\(indent) stamina: \(stamina) \n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasStamina {
               hashCode = (hashCode &* 31) &+ stamina.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemReviveResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemReviveResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemReviveResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemReviveResponse = Pogoprotos.Networking.Responses.UseItemReviveResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseItemReviveResponse.Result) -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasStamina:Bool {
           get {
                return builderResult.hasStamina
           }
      }
      public var stamina:Int32 {
           get {
                return builderResult.stamina
           }
           set (value) {
               builderResult.hasStamina = true
               builderResult.stamina = value
           }
      }
      public func setStamina(value:Int32) -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        self.stamina = value
        return self
      }
      public func clearStamina() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder{
           builderResult.hasStamina = false
           builderResult.stamina = Int32(0)
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemReviveResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemReviveResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemReviveResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemReviveResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemReviveResponse) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemReviveResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if other.hasStamina {
             stamina = other.stamina
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemReviveResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 16:
            stamina = try input.readInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemReviveResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueStamina = jsonMap["stamina"] as? NSNumber {
          resultDecodedBuilder.stamina = jsonValueStamina.intValue
        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemReviveResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

  final public class UseItemXpBoostResponse : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum Result:Int32, CustomDebugStringConvertible, CustomStringConvertible {
        case Unset = 0
        case Success = 1
        case ErrorInvalidItemType = 2
        case ErrorXpBoostAlreadyActive = 3
        case ErrorNoItemsRemaining = 4
        case ErrorLocationUnset = 5
        public func toString() -> String {
          switch self {
          case .Unset: return "UNSET"
          case .Success: return "SUCCESS"
          case .ErrorInvalidItemType: return "ERROR_INVALID_ITEM_TYPE"
          case .ErrorXpBoostAlreadyActive: return "ERROR_XP_BOOST_ALREADY_ACTIVE"
          case .ErrorNoItemsRemaining: return "ERROR_NO_ITEMS_REMAINING"
          case .ErrorLocationUnset: return "ERROR_LOCATION_UNSET"
          }
        }
        public static func fromString(str:String) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result {
          switch str {
          case "UNSET":  return .Unset
          case "SUCCESS":  return .Success
          case "ERROR_INVALID_ITEM_TYPE":  return .ErrorInvalidItemType
          case "ERROR_XP_BOOST_ALREADY_ACTIVE":  return .ErrorXpBoostAlreadyActive
          case "ERROR_NO_ITEMS_REMAINING":  return .ErrorNoItemsRemaining
          case "ERROR_LOCATION_UNSET":  return .ErrorLocationUnset
          default: throw ProtocolBuffersError.InvalidProtocolBuffer("Conversion String to Enum has failed.")
          }
        }
        public var debugDescription:String { return getDescription() }
        public var description:String { return getDescription() }
        private func getDescription() -> String { 
            switch self {
                case .Unset: return ".Unset"
                case .Success: return ".Success"
                case .ErrorInvalidItemType: return ".ErrorInvalidItemType"
                case .ErrorXpBoostAlreadyActive: return ".ErrorXpBoostAlreadyActive"
                case .ErrorNoItemsRemaining: return ".ErrorNoItemsRemaining"
                case .ErrorLocationUnset: return ".ErrorLocationUnset"
            }
        }
      }

      //Enum type declaration end 

    public private(set) var result:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result.Unset
    public private(set) var hasResult:Bool = false
    public private(set) var hasAppliedItems:Bool = false
    public private(set) var appliedItems:Pogoprotos.Inventory.AppliedItems!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasResult {
        try output.writeEnum(1, value:result.rawValue)
      }
      if hasAppliedItems {
        try output.writeMessage(2, value:appliedItems)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if (hasResult) {
        serialize_size += result.rawValue.computeEnumSize(1)
      }
      if hasAppliedItems {
          if let varSizeappliedItems = appliedItems?.computeMessageSize(2) {
              serialize_size += varSizeappliedItems
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Pogoprotos.Networking.Responses.UseItemXpBoostResponse> {
      var mergedArray = Array<Pogoprotos.Networking.Responses.UseItemXpBoostResponse>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse? {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromData(data, extensionRegistry:Pogoprotos.Networking.Responses.PogoprotosNetworkingResponsesRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.classBuilder() as! Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder
    }
    public func getBuilder() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return classBuilder() as! Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder
    }
    override public class func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
    }
    override public func classBuilder() -> MessageBuilder {
      return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
    }
    public func toBuilder() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Pogoprotos.Networking.Responses.UseItemXpBoostResponse) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder().mergeFrom(prototype)
    }
    override public func encode() throws -> Dictionary<String,AnyObject> {
      guard isInitialized() else {
        throw ProtocolBuffersError.InvalidProtocolBuffer("Uninitialized Message")
      }

      var jsonMap:Dictionary<String,AnyObject> = Dictionary<String,AnyObject>()
      if hasResult {
        jsonMap["result"] = result.toString()
      }
      if hasAppliedItems {
        jsonMap["appliedItems"] = try appliedItems.encode()
      }
      return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.decodeToBuilder(jsonMap).build()
    }
    override class public func fromJSON(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
      return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.fromJSONToBuilder(data).build()
    }
    override public func getDescription(indent:String) throws -> String {
      var output = ""
      if (hasResult) {
        output += "\(indent) result: \(result.description)\n"
      }
      if hasAppliedItems {
        output += "\(indent) appliedItems {\n"
        if let outDescAppliedItems = appliedItems {
          output += try outDescAppliedItems.getDescription("\(indent)  ")
        }
        output += "\(indent) }\n"
      }
      output += unknownFields.getDescription(indent)
      return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasResult {
               hashCode = (hashCode &* 31) &+ Int(result.rawValue)
            }
            if hasAppliedItems {
                if let hashValueappliedItems = appliedItems?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueappliedItems
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemXpBoostResponse"
    }
    override public func className() -> String {
        return "Pogoprotos.Networking.Responses.UseItemXpBoostResponse"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Pogoprotos.Networking.Responses.UseItemXpBoostResponse.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Pogoprotos.Networking.Responses.UseItemXpBoostResponse = Pogoprotos.Networking.Responses.UseItemXpBoostResponse()
      public func getMessage() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
          return builderResult
      }

      required override public init () {
         super.init()
      }
        public var hasResult:Bool{
            get {
                return builderResult.hasResult
            }
        }
        public var result:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result {
            get {
                return builderResult.result
            }
            set (value) {
                builderResult.hasResult = true
                builderResult.result = value
            }
        }
        public func setResult(value:Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result) -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
          self.result = value
          return self
        }
        public func clearResult() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
           builderResult.hasResult = false
           builderResult.result = .Unset
           return self
        }
      public var hasAppliedItems:Bool {
           get {
               return builderResult.hasAppliedItems
           }
      }
      public var appliedItems:Pogoprotos.Inventory.AppliedItems! {
           get {
               if appliedItemsBuilder_ != nil {
                  builderResult.appliedItems = appliedItemsBuilder_.getMessage()
               }
               return builderResult.appliedItems
           }
           set (value) {
               builderResult.hasAppliedItems = true
               builderResult.appliedItems = value
           }
      }
      private var appliedItemsBuilder_:Pogoprotos.Inventory.AppliedItems.Builder! {
           didSet {
              builderResult.hasAppliedItems = true
           }
      }
      public func getAppliedItemsBuilder() -> Pogoprotos.Inventory.AppliedItems.Builder {
        if appliedItemsBuilder_ == nil {
           appliedItemsBuilder_ = Pogoprotos.Inventory.AppliedItems.Builder()
           builderResult.appliedItems = appliedItemsBuilder_.getMessage()
           if appliedItems != nil {
              try! appliedItemsBuilder_.mergeFrom(appliedItems)
           }
        }
        return appliedItemsBuilder_
      }
      public func setAppliedItems(value:Pogoprotos.Inventory.AppliedItems!) -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        self.appliedItems = value
        return self
      }
      public func mergeAppliedItems(value:Pogoprotos.Inventory.AppliedItems) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        if builderResult.hasAppliedItems {
          builderResult.appliedItems = try Pogoprotos.Inventory.AppliedItems.builderWithPrototype(builderResult.appliedItems).mergeFrom(value).buildPartial()
        } else {
          builderResult.appliedItems = value
        }
        builderResult.hasAppliedItems = true
        return self
      }
      public func clearAppliedItems() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        appliedItemsBuilder_ = nil
        builderResult.hasAppliedItems = false
        builderResult.appliedItems = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      override public func clear() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        builderResult = Pogoprotos.Networking.Responses.UseItemXpBoostResponse()
        return self
      }
      override public func clone() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.builderWithPrototype(builderResult)
      }
      override public func build() throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse {
        let returnMe:Pogoprotos.Networking.Responses.UseItemXpBoostResponse = builderResult
        return returnMe
      }
      public func mergeFrom(other:Pogoprotos.Networking.Responses.UseItemXpBoostResponse) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        if other == Pogoprotos.Networking.Responses.UseItemXpBoostResponse() {
         return self
        }
        if other.hasResult {
             result = other.result
        }
        if (other.hasAppliedItems) {
            try mergeAppliedItems(other.appliedItems)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      override public func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let protobufTag = try input.readTag()
          switch protobufTag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8:
            let valueIntresult = try input.readEnum()
            if let enumsresult = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result(rawValue:valueIntresult){
                 result = enumsresult
            } else {
                 try unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntresult))
            }

          case 18:
            let subBuilder:Pogoprotos.Inventory.AppliedItems.Builder = Pogoprotos.Inventory.AppliedItems.Builder()
            if hasAppliedItems {
              try subBuilder.mergeFrom(appliedItems)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            appliedItems = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
      override class public func decodeToBuilder(jsonMap:Dictionary<String,AnyObject>) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let resultDecodedBuilder = Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder()
        if let jsonValueResult = jsonMap["result"] as? String {
          resultDecodedBuilder.result = try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Result.fromString(jsonValueResult)
        }
        if let jsonValueAppliedItems = jsonMap["appliedItems"] as? Dictionary<String,AnyObject> {
          resultDecodedBuilder.appliedItems = try Pogoprotos.Inventory.AppliedItems.Builder.decodeToBuilder(jsonValueAppliedItems).build()

        }
        return resultDecodedBuilder
      }
      override class public func fromJSONToBuilder(data:NSData) throws -> Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder {
        let jsonData = try NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions(rawValue: 0))
        guard let jsDataCast = jsonData as? Dictionary<String,AnyObject> else {
          throw ProtocolBuffersError.InvalidProtocolBuffer("Invalid JSON data")
        }
        return try Pogoprotos.Networking.Responses.UseItemXpBoostResponse.Builder.decodeToBuilder(jsDataCast)
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
